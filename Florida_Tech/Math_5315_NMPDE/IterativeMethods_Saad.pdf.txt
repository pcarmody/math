Iterative Methods

for Sparse
Linear Systems
Second Edition

0.19E+07

0.10E-06

Yousef Saad

Copyright c 2003 by the Society for Industrial and Applied Mathematics

Contents
Preface
Preface to. second
. . . . edition
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Preface to. first
. . edition
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

vii
vii
xiii

1 Background in Linear Algebra
1.1
Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2
Square Matrices and Eigenvalues . . . . . . . . . . . . . . . .
1.3
Types of Matrices . . . . . . . . . . . . . . . . . . . . . . . .
1.4
Vector Inner Products and Norms . . . . . . . . . . . . . . . .
1.5
Matrix Norms . . . . . . . . . . . . . . . . . . . . . . . . . .
1.6
Subspaces, Range, and Kernel . . . . . . . . . . . . . . . . . .
1.7
Orthogonal Vectors and Subspaces . . . . . . . . . . . . . . .
1.8
Canonical Forms of Matrices . . . . . . . . . . . . . . . . . .
1.8.1
Reduction to the Diagonal Form . . . . . . . . . .
1.8.2
The Jordan Canonical Form . . . . . . . . . . . .
1.8.3
The Schur Canonical Form . . . . . . . . . . . .
1.8.4
Application to Powers of Matrices . . . . . . . .
1.9
Normal and Hermitian Matrices . . . . . . . . . . . . . . . . .
1.9.1
Normal Matrices . . . . . . . . . . . . . . . . . .
1.9.2
Hermitian Matrices . . . . . . . . . . . . . . . .
1.10
Nonnegative Matrices, M-Matrices . . . . . . . . . . . . . . .
1.11
Positive-Definite Matrices . . . . . . . . . . . . . . . . . . . .
1.12
Projection Operators . . . . . . . . . . . . . . . . . . . . . . .
1.12.1
Range and Null Space of a Projector . . . . . . .
1.12.2
Matrix Representations . . . . . . . . . . . . . .
1.12.3
Orthogonal and Oblique Projectors . . . . . . . .
1.12.4
Properties of Orthogonal Projectors . . . . . . . .
1.13
Basic Concepts in Linear Systems . . . . . . . . . . . . . . . .
1.13.1
Existence of a Solution . . . . . . . . . . . . . .
1.13.2
Perturbation Analysis . . . . . . . . . . . . . . .

1
1
3
4
6
8
10
11
15
16
17
17
20
21
21
25
27
32
34
34
36
37
38
39
40
41

2 Discretization of PDEs
2.1
Partial Differential Equations . . . . . . . . . . . . . . . . . .
2.1.1
Elliptic Operators . . . . . . . . . . . . . . . . .

47
47
47

v

CONTENTS

vi

2.1.2
The Convection Diffusion Equation . . . . . . . .
Finite Difference Methods . . . . . . . . . . . . . . . . . . . .
2.2.1
Basic Approximations . . . . . . . . . . . . . . .
2.2.2
Difference Schemes for the Laplacean Operator .
2.2.3
Finite Differences for 1-D Problems . . . . . . . .
2.2.4
Upwind Schemes . . . . . . . . . . . . . . . . .
2.2.5
Finite Differences for 2-D Problems . . . . . . . .
2.2.6
Fast Poisson Solvers . . . . . . . . . . . . . . . .
The Finite Element Method . . . . . . . . . . . . . . . . . . .
Mesh Generation and Refinement . . . . . . . . . . . . . . . .
Finite Volume Method . . . . . . . . . . . . . . . . . . . . . .

50
50
50
52
53
54
56
58
62
69
69

3 Sparse Matrices
3.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2
Graph Representations . . . . . . . . . . . . . . . . . . . . . .
3.2.1
Graphs and Adjacency Graphs . . . . . . . . . . .
3.2.2
Graphs of PDE Matrices . . . . . . . . . . . . . .
3.3
Permutations and Reorderings . . . . . . . . . . . . . . . . . .
3.3.1
Basic Concepts . . . . . . . . . . . . . . . . . . .
3.3.2
Relations with the Adjacency Graph . . . . . . .
3.3.3
Common Reorderings . . . . . . . . . . . . . . .
3.3.4
Irreducibility . . . . . . . . . . . . . . . . . . . .
3.4
Storage Schemes . . . . . . . . . . . . . . . . . . . . . . . . .
3.5
Basic Sparse Matrix Operations . . . . . . . . . . . . . . . . .
3.6
Sparse Direct Solution Methods . . . . . . . . . . . . . . . . .
3.6.1
Minimum degree ordering . . . . . . . . . . . . .
3.6.2
Nested Dissection ordering . . . . . . . . . . . .
3.7
Test Problems . . . . . . . . . . . . . . . . . . . . . . . . . .

75
75
76
77
78
79
79
81
83
91
92
95
96
97
97
98

4 Basic Iterative Methods
4.1
Jacobi, Gauss-Seidel, and SOR . . . . . . . . . . . . . . . . .
4.1.1
Block Relaxation Schemes . . . . . . . . . . . .
4.1.2
Iteration Matrices and Preconditioning . . . . . .
4.2
Convergence . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.1
General Convergence Result . . . . . . . . . . . .
4.2.2
Regular Splittings . . . . . . . . . . . . . . . . .
4.2.3
Diagonally Dominant Matrices . . . . . . . . . .
4.2.4
Symmetric Positive Definite Matrices . . . . . . .
4.2.5
Property A and Consistent Orderings . . . . . . .
4.3
Alternating Direction Methods . . . . . . . . . . . . . . . . .

105
105
108
112
114
115
118
119
122
123
127

2.2

2.3
2.4
2.5

5 Projection Methods
133
5.1
Basic Definitions and Algorithms . . . . . . . . . . . . . . . . 133
5.1.1
General Projection Methods . . . . . . . . . . . . 134

CONTENTS

vii
5.1.2
Matrix Representation . . . . . . . . . . . . . . .
General Theory . . . . . . . . . . . . . . . . . . . . . . . . .
5.2.1
Two Optimality Results . . . . . . . . . . . . . .
5.2.2
Interpretation in Terms of Projectors . . . . . . .
5.2.3
General Error Bound . . . . . . . . . . . . . . . .
One-Dimensional Projection Processes . . . . . . . . . . . . .
5.3.1
Steepest Descent . . . . . . . . . . . . . . . . . .
5.3.2
Minimal Residual (MR) Iteration . . . . . . . . .
5.3.3
Residual Norm Steepest Descent . . . . . . . . .
Additive and Multiplicative Processes . . . . . . . . . . . . . .

135
137
137
138
140
142
142
145
147
147

6 Krylov Subspace Methods Part I
6.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.2
Krylov Subspaces . . . . . . . . . . . . . . . . . . . . . . . .
6.3
Arnoldi’s Method . . . . . . . . . . . . . . . . . . . . . . . .
6.3.1
The Basic Algorithm . . . . . . . . . . . . . . . .
6.3.2
Practical Implementations . . . . . . . . . . . . .
6.4
Arnoldi’s Method for Linear Systems (FOM) . . . . . . . . . .
6.4.1
Variation 1: Restarted FOM . . . . . . . . . . . .
6.4.2
Variation 2: IOM and DIOM . . . . . . . . . . .
6.5
GMRES . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.5.1
The Basic GMRES Algorithm . . . . . . . . . . .
6.5.2
The Householder Version . . . . . . . . . . . . .
6.5.3
Practical Implementation Issues . . . . . . . . . .
6.5.4
Breakdown of GMRES . . . . . . . . . . . . . .
6.5.5
Variation 1: Restarting . . . . . . . . . . . . . . .
6.5.6
Variation 2: Truncated GMRES Versions . . . . .
6.5.7
Relations between FOM and GMRES . . . . . . .
6.5.8
Residual smoothing . . . . . . . . . . . . . . . .
6.5.9
GMRES for complex systems . . . . . . . . . . .
6.6
The Symmetric Lanczos Algorithm . . . . . . . . . . . . . . .
6.6.1
The Algorithm . . . . . . . . . . . . . . . . . . .
6.6.2
Relation with Orthogonal Polynomials . . . . . .
6.7
The Conjugate Gradient Algorithm . . . . . . . . . . . . . . .
6.7.1
Derivation and Theory . . . . . . . . . . . . . . .
6.7.2
Alternative Formulations . . . . . . . . . . . . .
6.7.3
Eigenvalue Estimates from the CG Coefficients . .
6.8
The Conjugate Residual Method . . . . . . . . . . . . . . . .
6.9
GCR, ORTHOMIN, and ORTHODIR . . . . . . . . . . . . . .
6.10
The Faber-Manteuffel Theorem . . . . . . . . . . . . . . . . .
6.11
Convergence Analysis . . . . . . . . . . . . . . . . . . . . . .
6.11.1
Real Chebyshev Polynomials . . . . . . . . . . .
6.11.2
Complex Chebyshev Polynomials . . . . . . . . .
6.11.3
Convergence of the CG Algorithm . . . . . . . .

157
157
158
160
160
162
165
167
168
171
172
173
174
179
179
180
185
190
193
193
194
195
195
196
200
201
203
203
206
208
208
210
213

5.2

5.3

5.4

CONTENTS

viii

6.12

6.11.4
Convergence of GMRES . . . . . . . . . . . . . . 215
Block Krylov Methods . . . . . . . . . . . . . . . . . . . . . 218

7 Krylov Subspace Methods Part II
7.1
Lanczos Biorthogonalization . . . . . . . . . . . . . . . . . .
7.1.1
The Algorithm . . . . . . . . . . . . . . . . . . .
7.1.2
Practical Implementations . . . . . . . . . . . . .
7.2
The Lanczos Algorithm for Linear Systems . . . . . . . . . . .
7.3
The BCG and QMR Algorithms . . . . . . . . . . . . . . . . .
7.3.1
The Biconjugate Gradient Algorithm . . . . . . .
7.3.2
Quasi-Minimal Residual Algorithm . . . . . . . .
7.4
Transpose-Free Variants . . . . . . . . . . . . . . . . . . . . .
7.4.1
Conjugate Gradient Squared . . . . . . . . . . . .
7.4.2
BICGSTAB . . . . . . . . . . . . . . . . . . . .
7.4.3
Transpose-Free QMR (TFQMR) . . . . . . . . .

229
229
229
232
234
234
234
236
241
241
244
247

8 Methods Related to the Normal Equations
8.1
The Normal Equations . . . . . . . . . . . . . . . . . . . . . .
8.2
Row Projection Methods . . . . . . . . . . . . . . . . . . . .
8.2.1
Gauss-Seidel on the Normal Equations . . . . . .
8.2.2
Cimmino’s Method . . . . . . . . . . . . . . . .
8.3
Conjugate Gradient and Normal Equations . . . . . . . . . . .
8.3.1
CGNR . . . . . . . . . . . . . . . . . . . . . . .
8.3.2
CGNE . . . . . . . . . . . . . . . . . . . . . . .
8.4
Saddle-Point Problems . . . . . . . . . . . . . . . . . . . . . .

259
259
261
261
263
266
266
267
268

9 Preconditioned Iterations
9.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.2
Preconditioned Conjugate Gradient . . . . . . . . . . . . . . .
9.2.1
Preserving Symmetry . . . . . . . . . . . . . . .
9.2.2
Efficient Implementations . . . . . . . . . . . . .
9.3
Preconditioned GMRES . . . . . . . . . . . . . . . . . . . . .
9.3.1
Left-Preconditioned GMRES . . . . . . . . . . .
9.3.2
Right-Preconditioned GMRES . . . . . . . . . .
9.3.3
Split Preconditioning . . . . . . . . . . . . . . .
9.3.4
Comparison of Right and Left Preconditioning . .
9.4
Flexible Variants . . . . . . . . . . . . . . . . . . . . . . . . .
9.4.1
Flexible GMRES . . . . . . . . . . . . . . . . . .
9.4.2
DQGMRES . . . . . . . . . . . . . . . . . . . .
9.5
Preconditioned CG for the Normal Equations . . . . . . . . . .
9.6
The Concus, Golub, and Widlund Algorithm . . . . . . . . . .

275
275
276
276
279
282
282
284
285
285
287
287
290
291
292

10 Preconditioning Techniques
297
10.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
10.2
Jacobi, SOR, and SSOR Preconditioners . . . . . . . . . . . . 298

CONTENTS
10.3

ix
ILU Factorization Preconditioners . . . . . . . . . . . . . . .
10.3.1
Incomplete LU Factorizations . . . . . . . . . . .
10.3.2
Zero Fill-in ILU (ILU(0)) . . . . . . . . . . . . .
10.3.3
Level of Fill and ILU(p) . . . . . . . . . . . . . .
10.3.4
Matrices with Regular Structure . . . . . . . . . .
10.3.5
Modified ILU (MILU) . . . . . . . . . . . . . . .
Threshold Strategies and ILUT . . . . . . . . . . . . . . . . .
10.4.1
The ILUT Approach . . . . . . . . . . . . . . . .
10.4.2
Analysis . . . . . . . . . . . . . . . . . . . . . .
10.4.3
Implementation Details . . . . . . . . . . . . . .
10.4.4
The ILUTP Approach . . . . . . . . . . . . . . .
10.4.5
The ILUS Approach . . . . . . . . . . . . . . . .
10.4.6
The Crout ILU Approach . . . . . . . . . . . . .
Approximate Inverse Preconditioners . . . . . . . . . . . . . .
10.5.1
Approximating the Inverse of a Sparse Matrix . .
10.5.2
Global Iteration . . . . . . . . . . . . . . . . . .
10.5.3
Column-Oriented Algorithms . . . . . . . . . . .
10.5.4
Theoretical Considerations . . . . . . . . . . . .
10.5.5
Convergence of Self Preconditioned MR . . . . .
10.5.6
Approximate Inverses via bordering . . . . . . . .
10.5.7
Factored inverses via orthogonalization: AINV . .
10.5.8
Improving a Preconditioner . . . . . . . . . . . .
Reordering for ILU . . . . . . . . . . . . . . . . . . . . . . .
10.6.1
Symmetric permutations . . . . . . . . . . . . . .
10.6.2
Nonsymmetric reorderings . . . . . . . . . . . . .
Block Preconditioners . . . . . . . . . . . . . . . . . . . . . .
10.7.1
Block-Tridiagonal Matrices . . . . . . . . . . . .
10.7.2
General Matrices . . . . . . . . . . . . . . . . . .
Preconditioners for the Normal Equations . . . . . . . . . . .
10.8.1
Jacobi, SOR, and Variants . . . . . . . . . . . . .
10.8.2
IC(0) for the Normal Equations . . . . . . . . . .
10.8.3
Incomplete Gram-Schmidt and ILQ . . . . . . . .

301
301
307
310
315
319
321
321
323
325
327
330
332
336
336
337
339
340
342
345
348
349
350
350
352
354
354
356
356
357
357
359

11 Parallel Implementations
11.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.2
Forms of Parallelism . . . . . . . . . . . . . . . . . . . . . . .
11.2.1
Multiple Functional Units . . . . . . . . . . . . .
11.2.2
Pipelining . . . . . . . . . . . . . . . . . . . . .
11.2.3
Vector Processors . . . . . . . . . . . . . . . . .
11.2.4
Multiprocessing and Distributed Computing . . .
11.3
Types of Parallel Architectures . . . . . . . . . . . . . . . . .
11.3.1
Shared Memory Computers . . . . . . . . . . . .
11.3.2
Distributed Memory Architectures . . . . . . . .
11.4
Types of Operations . . . . . . . . . . . . . . . . . . . . . . .

369
369
370
370
370
371
371
371
372
374
376

10.4

10.5

10.6

10.7

10.8

CONTENTS

x
11.5

Matrix-by-Vector Products . . . . . . . . . . . . . . . . . . .
11.5.1
The CSR and CSC Formats . . . . . . . . . . . .
11.5.2
Matvecs in the Diagonal Format . . . . . . . . . .
11.5.3
The Ellpack-Itpack Format . . . . . . . . . . . .
11.5.4
The Jagged Diagonal Format . . . . . . . . . . .
11.5.5
The Case of Distributed Sparse Matrices . . . . .
Standard Preconditioning Operations . . . . . . . . . . . . . .
11.6.1
Parallelism in Forward Sweeps . . . . . . . . . .
11.6.2
Level Scheduling: the Case of 5-Point Matrices .
11.6.3
Level Scheduling for Irregular Graphs . . . . . .

378
378
380
381
382
383
386
386
387
388

12 Parallel Preconditioners
12.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . .
12.2
Block-Jacobi Preconditioners . . . . . . . . . . . . . . . . . .
12.3
Polynomial Preconditioners . . . . . . . . . . . . . . . . . . .
12.3.1
Neumann Polynomials . . . . . . . . . . . . . . .
12.3.2
Chebyshev Polynomials . . . . . . . . . . . . . .
12.3.3
Least-Squares Polynomials . . . . . . . . . . . .
12.3.4
The Nonsymmetric Case . . . . . . . . . . . . . .
12.4
Multicoloring . . . . . . . . . . . . . . . . . . . . . . . . . .
12.4.1
Red-Black Ordering . . . . . . . . . . . . . . . .
12.4.2
Solution of Red-Black Systems . . . . . . . . . .
12.4.3
Multicoloring for General Sparse Matrices . . . .
12.5
Multi-Elimination ILU . . . . . . . . . . . . . . . . . . . . . .
12.5.1
Multi-Elimination . . . . . . . . . . . . . . . . .
12.5.2
ILUM . . . . . . . . . . . . . . . . . . . . . . .
12.6
Distributed ILU and SSOR . . . . . . . . . . . . . . . . . . .
12.7
Other Techniques . . . . . . . . . . . . . . . . . . . . . . . .
12.7.1
Approximate Inverses . . . . . . . . . . . . . . .
12.7.2
Element-by-Element Techniques . . . . . . . . .
12.7.3
Parallel Row Projection Preconditioners . . . . .

393
393
394
395
396
397
400
403
406
406
407
408
409
410
412
414
417
417
417
419

13 Multigrid Methods
13.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . .
13.2
Matrices and spectra of model problems . . . . . . . . . . . .
13.2.1
Richardson’s iteration . . . . . . . . . . . . . . .
13.2.2
Weighted Jacobi iteration . . . . . . . . . . . . .
13.2.3
Gauss-Seidel iteration . . . . . . . . . . . . . . .
13.3
Inter-grid operations . . . . . . . . . . . . . . . . . . . . . . .
13.3.1
Prolongation . . . . . . . . . . . . . . . . . . . .
13.3.2
Restriction . . . . . . . . . . . . . . . . . . . . .
13.4
Standard multigrid techniques . . . . . . . . . . . . . . . . . .
13.4.1
Coarse problems and smoothers . . . . . . . . . .
13.4.2
Two-grid cycles . . . . . . . . . . . . . . . . . .

423
423
424
428
431
432
436
436
438
439
439
441

11.6

13.5

13.6

13.7

13.4.3
V-cycles and W-cycles . . . . . . . . . . . . . . .
13.4.4
Full Multigrid . . . . . . . . . . . . . . . . . . .
Analysis for the two-grid cycle . . . . . . . . . . . . . . . . .
13.5.1
Two important subspaces . . . . . . . . . . . . .
13.5.2
Convergence analysis . . . . . . . . . . . . . . .
Algebraic Multigrid . . . . . . . . . . . . . . . . . . . . . . .
13.6.1
Smoothness in AMG . . . . . . . . . . . . . . . .
13.6.2
Interpolation in AMG . . . . . . . . . . . . . . .
13.6.3
Defining coarse spaces in AMG . . . . . . . . . .
13.6.4
AMG via Multilevel ILU . . . . . . . . . . . . .
Multigrid vs Krylov methods . . . . . . . . . . . . . . . . . .

443
447
451
451
453
455
456
457
460
461
464

14 Domain Decomposition Methods
469
14.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
14.1.1
Notation . . . . . . . . . . . . . . . . . . . . . . 470
14.1.2
Types of Partitionings . . . . . . . . . . . . . . . 472
14.1.3
Types of Techniques . . . . . . . . . . . . . . . . 472
14.2
Direct Solution and the Schur Complement . . . . . . . . . . . 474
14.2.1
Block Gaussian Elimination . . . . . . . . . . . . 474
14.2.2
Properties of the Schur Complement . . . . . . . 475
14.2.3
Schur Complement for Vertex-Based Partitionings 476
14.2.4
Schur Complement for Finite-Element Partitionings 479
14.2.5
Schur Complement for the model problem . . . . 481
14.3
Schwarz Alternating Procedures . . . . . . . . . . . . . . . . . 484
14.3.1
Multiplicative Schwarz Procedure . . . . . . . . . 484
14.3.2
Multiplicative Schwarz Preconditioning . . . . . . 489
14.3.3
Additive Schwarz Procedure . . . . . . . . . . . . 491
14.3.4
Convergence . . . . . . . . . . . . . . . . . . . . 492
14.4
Schur Complement Approaches . . . . . . . . . . . . . . . . . 497
14.4.1
Induced Preconditioners . . . . . . . . . . . . . . 497
14.4.2
Probing . . . . . . . . . . . . . . . . . . . . . . . 500
14.4.3
Preconditioning Vertex-Based Schur Complements 500
14.5
Full Matrix Methods . . . . . . . . . . . . . . . . . . . . . . . 501
14.6
Graph Partitioning . . . . . . . . . . . . . . . . . . . . . . . . 504
14.6.1
Basic Definitions . . . . . . . . . . . . . . . . . . 504
14.6.2
Geometric Approach . . . . . . . . . . . . . . . . 505
14.6.3
Spectral Techniques . . . . . . . . . . . . . . . . 506
14.6.4
Graph Theory Techniques . . . . . . . . . . . . . 507
References

514

Index

535

xii

CONTENTS

Preface to the second edition
In the six years that passed since the publication of the first edition of this book,
iterative methods for linear systems have made good progress in scientific and engineering disciplines. This is due in great part to the increased complexity and size of
the new generation of linear and nonlinear systems which arise from typical applications. At the same time, parallel computing has penetrated the same application
areas, as inexpensive computer power became broadly available and standard communication languages such as MPI gave a much needed standardization. This has
created an incentive to utilize iterative rather than direct solvers because the problems solved are typically from 3-dimensional models for which direct solvers often
become ineffective. Another incentive is that iterative methods are far easier to implement on parallel computers,
Though iterative methods for linear systems have seen a significant maturation,
there are still many open problems. In particular, it still cannot be stated that an
arbitrary sparse linear system can be solved iteratively in an efficient way. If physical
information about the problem can be exploited, more effective and robust methods
can be tailored for the solutions. This strategy is exploited by multigrid methods. In
addition, parallel computers necessitate different ways of approaching the problem
and solution algorithms that are radically different from classical ones.
Several new texts on the subject of this book have appeared since the first edition.
Among these, are the books by Greenbaum [154], and Meurant [209]. The exhaustive
5-volume treatise by G. W. Stewart [274] is likely to become the de-facto reference
in numerical linear algebra in years to come. The related multigrid literature has
also benefited from a few notable additions, including a new edition of the excellent
“Multigrid tutorial” [65], and a new title by Trottenberg et al. [286].
Most notable among the changes from the first edition, is the addition of a sorely
needed chapter on Multigrid techniques. The chapters which have seen the biggest
changes are Chapter 3, 6, 10, and 12. In most cases, the modifications were made to
update the material by adding topics that were developed recently or gained importance in the last few years. In some instances some of the older topics were removed
or shortened. For example the discussion on parallel architecture has been shortened. In the mid-1990’s hypercubes and “fat-trees” were important topic to teach.
This is no longer the case, since manufacturers have taken steps to hide the topology
from the user, in the sense that communication has become much less sensitive to the
xiii

xiv

PREFACE

underlying architecture.
The bibliography has been updated to include work that has appeared in the last
few years, as well as to reflect change of emphasis when new topics have gained
importance. Similarly, keeping in mind the educational side of this book, many
new exercises have been added. The first edition suffered many typographical errors
which have been corrected. Many thanks to those readers who took the time to point
out errors.
I would like to reiterate my thanks to all my colleagues who helped make the
the first edition a success (see the preface to the first edition). I received support
and encouragement from many students and colleagues to put together this revised
volume. I also wish to thank those who proofread this book. I found that one of
the best way to improve clarity is to solicit comments and questions from students
in a course which teaches the material. Thanks to all students in Csci 8314 who
helped in this regard. Special thanks to Bernie Sheeham, who pointed out quite a
few typographical errors and made numerous helpful suggestions.
My sincere thanks to Michele Benzi, Howard Elman, and Steve Mc Cormick
for their reviews of this edition. Michele proof-read a few chapters thoroughly and
caught a few misstatements. Steve Mc Cormick’s review of Chapter 13 helped ensure
that my slight bias for Krylov methods (versus multigrid) was not too obvious. His
comments were at the origin of the addition of Section 13.7 (Multigrid vs Krylov
methods).
I would also like to express my appreciation to the SIAM staff, especially Linda
Thiel and Sara Murphy.

PREFACE

xv

Suggestions for teaching
This book can be used as a text to teach a graduate-level course on iterative methods
for linear systems. Selecting topics to teach depends on whether the course is taught
in a mathematics department or a computer science (or engineering) department, and
whether the course is over a semester or a quarter. Here are a few comments on the
relevance of the topics in each chapter.
For a graduate course in a mathematics department, much of the material in
Chapter 1 should be known already. For non-mathematics majors most of the chapter must be covered or reviewed to acquire a good background for later chapters.
The important topics for the rest of the book are in Sections: 1.8.1, 1.8.3, 1.8.4, 1.9,
1.11. Section 1.12 is best treated at the beginning of Chapter 5. Chapter 2 is essentially independent from the rest and could be skipped altogether in a quarter session,
unless multigrid methods are to be included in the course. One lecture on finite differences and the resulting matrices would be enough for a non-math course. Chapter
3 aims at familiarizing the student with some implementation issues associated with
iterative solution procedures for general sparse matrices. In a computer science or
engineering department, this can be very relevant. For mathematicians, a mention
of the graph theory aspects of sparse matrices and a few storage schemes may be
sufficient. Most students at this level should be familiar with a few of the elementary
relaxation techniques covered in Chapter 4. The convergence theory can be skipped
for non-math majors. These methods are now often used as preconditioners and this
may be the only motive for covering them.
Chapter 5 introduces key concepts and presents projection techniques in general terms. Non-mathematicians may wish to skip Section 5.2.3. Otherwise, it is
recommended to start the theory section by going back to Section 1.12 on general
definitions on projectors. Chapters 6 and 7 represent the heart of the matter. It is
recommended to describe the first algorithms carefully and put emphasis on the fact
that they generalize the one-dimensional methods covered in Chapter 5. It is also
important to stress the optimality properties of those methods in Chapter 6 and the
fact that these follow immediately from the properties of projectors seen in Section
1.12. Chapter 6 is rather long and the instructor will need to select what to cover
among the non-essential topics as well as topics for reading.
When covering the algorithms in Chapter 7, it is crucial to point out the main
differences between them and those seen in Chapter 6. The variants such as CGS,
BICGSTAB, and TFQMR can be covered in a short time, omitting details of the
algebraic derivations or covering only one of the three. The class of methods based
on the normal equation approach, i.e., Chapter 8, can be skipped in a math-oriented
course, especially in the case of a quarter system. For a semester course, selected
topics may be Sections 8.1, 8.2, and 8.4.
Preconditioning is known to be the determining ingredient in the success of iterative methods in solving real-life problems. Therefore, at least some parts of Chapter
9 and Chapter 10 should be covered. Section 9.2 and (very briefly) 9.3 are recommended. From Chapter 10, discuss the basic ideas in Sections 10.1 through 10.3.

PREFACE

xvi

The rest could be skipped in a quarter course.
Chapter 11 may be useful to present to computer science majors, but may be
skimmed through or skipped in a mathematics or an engineering course. Parts of
Chapter 12 could be taught primarily to make the students aware of the importance
of “alternative” preconditioners. Suggested selections are: 12.2, 12.4, and 12.7.2 (for
engineers).
Chapters 13 and 14 present important research areas and are primarily geared
to mathematics majors. Computer scientists or engineers may cover this material in
less detail.
To make these suggestions more specific, the following two tables are offered
as sample course outlines. Numbers refer to sections in the text. A semester course
represents approximately 30 lectures of 75 minutes each whereas a quarter course
is approximately 20 lectures of 75 minutes each. Different topics are selected for a
mathematics course and a non-mathematics course.

Semester course
Weeks

Mathematics

Computer Science / Eng.

1–3

1.9 –1.13
2.1 – 2.5
3.1 – 3.3

1.1 – 1.6 (Read) ; 1.7; 1.9;
1.11; 1.12; 2.1 – 2.2
3.1 – 3.6

4–6

4.1 – 4.2
5. 1 – 5.3; 6.1 – 6.4
6.5.1; 6.5.3 – 6.5.9

4.1 – 4.2.1; 4.2.3
5.1 – 5.2.1; 5.3
6.1 – 6.4; 6.5.1 – 6.5.5

7–9

6.6 – 6.8
6.9 – 6.11; 7.1 – 7.3
7.4.1; 7.4.2; 7.4.3 (Read)

6.7.1 6.8–6.9
6.11.3; 7.1 – 7.3
7.4.1 – 7.4.2; 7.4.3 (Read)

10 – 12

8.1; 8.2 ; 9.1 – 9.4;
10.1 – 10.3; 10.4.1;
10.5.1 – 10.5.7

8.1 – 8.3; 9.1 – 9.3
10.1 – 10.3 ; 10.4.1 – 10.4.3;
10.5.1 – 10.5.4; 10.5.7

13 – 15

12.2 – 12.4
13.1 – 13.5
14.1 – 14.6

11.1 – 11.4 (Read); 11.5 – 11.6
12.1 – 12.2 ; 12.4 – 12.7
14.1 – 14.3; 14.6

PREFACE

xvii
Quarter course

Weeks

Mathematics

Computer Science / Eng.

1–2

1.9 – 1.13
4.1 – 4.2; 5.1 – 5.4

1.1 – 1.6 (Read); 3.1 – 3.5
4.1; 1.12 (Read)

3–4

6.1 – 6.4
6.5.1; 6.5.3 – 6.5.5

5.1 – 5.2.1; 5.3
6.1 – 6.3

5–6

6.7.1; 6.11.3; 7.1 – 7.3
7.4.1 – 7.4.2; 7.4.3 (Read)

6.4; 6.5.1; 6.5.3 – 6.5.5
6.7.1; 6.11.3; 7.1 – 7.3

7–8

9.1 – 9.3
10.1 – 10.3; 10.5.1; 10.5.7

7.4.1 – 7.4.2 (Read); 9.1 – 9.3
10.1 – 10.3; 10.5.1; 10.5.7

9 – 10

13.1 – 13.5
14.1 – 14.4

11.1 – 11.4 (Read); 11.5; 11.6
12.1 – 12.2; 12.4 – 12.7

xviii

PREFACE

Preface to the first edition

Iterative methods for solving general, large sparse linear systems have been gaining popularity in many areas of scientific computing. Until recently, direct solution
methods were often preferred to iterative methods in real applications because of
their robustness and predictable behavior. However, a number of efficient iterative
solvers were discovered and the increased need for solving very large linear systems
triggered a noticeable and rapid shift toward iterative techniques in many applications.
This trend can be traced back to the 1960s and 1970s when two important developments revolutionized solution methods for large linear systems. First was the
realization that one can take advantage of “sparsity” to design special direct methods that can be quite economical. Initiated by electrical engineers, these “direct
sparse solution methods” led to the development of reliable and efficient general-purpose direct solution software codes over the next three decades. Second was
the emergence of preconditioned conjugate gradient-like methods for solving linear
systems. It was found that the combination of preconditioning and Krylov subspace
iterations could provide efficient and simple “general-purpose” procedures that could
compete with direct solvers. Preconditioning involves exploiting ideas from sparse
direct solvers. Gradually, iterative methods started to approach the quality of direct solvers. In earlier times, iterative methods were often special-purpose in nature.
They were developed with certain applications in mind, and their efficiency relied on
many problem-dependent parameters.
Now, three-dimensional models are commonplace and iterative methods are almost mandatory. The memory and the computational requirements for solving threedimensional Partial Differential Equations, or two-dimensional ones involving many
degrees of freedom per point, may seriously challenge the most efficient direct solvers
available today. Also, iterative methods are gaining ground because they are easier
to implement efficiently on high-performance computers than direct methods.
My intention in writing this volume is to provide up-to-date coverage of iterative methods for solving large sparse linear systems. I focused the book on practical
methods that work for general sparse matrices rather than for any specific class of
problems. It is indeed becoming important to embrace applications not necessarily governed by Partial Differential Equations, as these applications are on the rise.
xix

xx

PREFACE

Apart from two recent volumes by Axelsson [14] and Hackbusch [163], few books on
iterative methods have appeared since the excellent ones by Varga [293]. and later
Young [322]. Since then, researchers and practitioners have achieved remarkable
progress in the development and use of effective iterative methods. Unfortunately,
fewer elegant results have been discovered since the 1950s and 1960s. The field has
moved in other directions. Methods have gained not only in efficiency but also in
robustness and in generality. The traditional techniques which required rather complicated procedures to determine optimal acceleration parameters have yielded to the
parameter-free conjugate gradient class of methods.
The primary aim of this book is to describe some of the best techniques available
today, from both preconditioners and accelerators. One of the aims of the book is
to provide a good mix of theory and practice. It also addresses some of the current
research issues such as parallel implementations and robust preconditioners. The
emphasis is on Krylov subspace methods, currently the most practical and common
group of techniques used in applications. Although there is a tutorial chapter that
covers the discretization of Partial Differential Equations, the book is not biased
toward any specific application area. Instead, the matrices are assumed to be general
sparse, possibly irregularly structured.
The book has been structured in four distinct parts. The first part, Chapters 1 to 4,
presents the basic tools. The second part, Chapters 5 to 8, presents projection methods and Krylov subspace techniques. The third part, Chapters 9 and 10, discusses
preconditioning. The fourth part, Chapters 11 to 13, discusses parallel implementations and parallel algorithms.

Acknowledgments
I am grateful to a number of colleagues who proofread or reviewed different versions of the manuscript. Among them are Randy Bramley (University of Indiana
at Bloomingtin), Xiao-Chuan Cai (University of Colorado at Boulder), Tony Chan
(University of California at Los Angeles), Jane Cullum (IBM, Yorktown Heights),
Alan Edelman (Massachussett Institute of Technology), Paul Fischer (Brown University), David Keyes (Old Dominion University), Beresford Parlett (University of California at Berkeley) and Shang-Hua Teng (University of Minnesota). Their numerous
comments, corrections, and encouragements were a highly appreciated contribution.
In particular, they helped improve the presentation considerably and prompted the
addition of a number of topics missing from earlier versions.
This book evolved from several successive improvements of a set of lecture notes
for the course “Iterative Methods for Linear Systems” which I taught at the University of Minnesota in the last few years. I apologize to those students who used the
earlier error-laden and incomplete manuscripts. Their input and criticism contributed
significantly to improving the manuscript. I also wish to thank those students at MIT
(with Alan Edelman) and UCLA (with Tony Chan) who used this book in manuscript
form and provided helpful feedback. My colleagues at the university of Minnesota,
staff and faculty members, have helped in different ways. I wish to thank in particular

PREFACE

xxi

Ahmed Sameh for his encouragements and for fostering a productive environment in
the department. Finally, I am grateful to the National Science Foundation for their
continued financial support of my research, part of which is represented in this work.
Yousef Saad

Chapter 1

BACKGROUND IN LINEAR ALGEBRA

This chapter gives an overview of the relevant concepts in linear algebra which are useful in
later chapters. It begins with a review of basic matrix theory and introduces the elementary
notation used throughout the book. The convergence analysis of iterative methods requires a
good level of knowledge in mathematical analysis and in linear algebra. Traditionally, many of the
concepts presented specifically for these analyses have been geared toward matrices arising from
the discretization of Partial Differential Equations and basic relaxation-type methods. These
concepts are now becoming less important because of the trend toward projection-type methods
which have more robust convergence properties and require different analysis tools. The material
covered in this chapter will be helpful in establishing some theory for the algorithms and defining
the notation used throughout the book.

1.1

Matrices

For the sake of generality, all vector spaces considered in this chapter are complex,
unless otherwise stated. A complex n × m matrix A is an n × m array of complex
numbers
aij , i = 1, . . . , n, j = 1, . . . , m.
The set of all n × m matrices is a complex vector space denoted by Cn×m . The main
operations with matrices are the following:
• Addition: C = A + B, where A, B, and C are matrices of size n × m and
cij = aij + bij ,

i = 1, 2, . . . n,

j = 1, 2, . . . m.

• Multiplication by a scalar: C = αA, where
cij = α aij ,

i = 1, 2, . . . n,

1

j = 1, 2, . . . m.

2

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA
• Multiplication by another matrix:
C = AB,
where A ∈ Cn×m , B ∈ Cm×p , C ∈ Cn×p , and
cij =

m
X

aik bkj .

k=1

Sometimes, a notation with column vectors and row vectors is used. The column
vector a∗j is the vector consisting of the j-th column of A,



a1j
 a2j 

a∗j = 
 ...  .
anj

Similarly, the notation ai∗ will denote the i-th row of the matrix A
ai∗ = (ai1 , ai2 , . . . , aim ) .
For example, the following could be written
A = (a∗1 , a∗2 , . . . , a∗m ) ,
or




a1∗
 a2∗ 



A=
 . .
 . 
an∗

The transpose of a matrix A in Cn×m is a matrix C in Cm×n whose elements
are defined by cij = aji , i = 1, . . . , m, j = 1, . . . , n. It is denoted by AT . It is often
more relevant to use the transpose conjugate matrix denoted by AH and defined by
AH = ĀT = AT ,
in which the bar denotes the (element-wise) complex conjugation.
Matrices are strongly related to linear mappings between vector spaces of finite
dimension. This is because they represent these mappings with respect to two given
bases: one for the initial vector space and the other for the image vector space, or
range of A.

1.2. SQUARE MATRICES AND EIGENVALUES

1.2

3

Square Matrices and Eigenvalues

A matrix is square if it has the same number of columns and rows, i.e., if m = n. An
important square matrix is the identity matrix
I = {δij }i,j=1,...,n ,
where δij is the Kronecker symbol. The identity matrix satisfies the equality AI =
IA = A for every matrix A of size n. The inverse of a matrix, when it exists, is a
matrix C such that
CA = AC = I.
The inverse of A is denoted by A−1 .
The determinant of a matrix may be defined in several ways. For simplicity, the
following recursive definition is used here. The determinant of a 1 × 1 matrix (a) is
defined as the scalar a. Then the determinant of an n × n matrix is given by
n
X
(−1)j+1 a1j det(A1j ),
det(A) =
j=1

where A1j is an (n − 1) × (n − 1) matrix obtained by deleting the first row and the
j-th column of A. A matrix is said to be singular when det(A) = 0 and nonsingular
otherwise. We have the following simple properties:
• det(AB) = det(A)det(B).
• det(AT ) = det(A).
• det(αA) = αn det(A).
• det(Ā) = det(A).
• det(I) = 1.
From the above definition of determinants it can be shown by induction that the
function that maps a given complex value λ to the value pA (λ) = det(A − λI)
is a polynomial of degree n; see Exercise 8. This is known as the characteristic
polynomial of the matrix A.
Definition 1.1 A complex scalar λ is called an eigenvalue of the square matrix A
if a nonzero vector u of Cn exists such that Au = λu. The vector u is called an
eigenvector of A associated with λ. The set of all the eigenvalues of A is called the
spectrum of A and is denoted by σ(A).
A scalar λ is an eigenvalue of A if and only if det(A − λI) ≡ pA (λ) = 0. That
is true if and only if (iff thereafter) λ is a root of the characteristic polynomial. In
particular, there are at most n distinct eigenvalues.
It is clear that a matrix is singular if and only if it admits zero as an eigenvalue.
A well known result in linear algebra is stated in the following proposition.

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

4

Proposition 1.2 A matrix A is nonsingular if and only if it admits an inverse.
Thus, the determinant of a matrix determines whether or not the matrix admits an
inverse.
The maximum modulus of the eigenvalues is called spectral radius and is denoted by ρ(A)
ρ(A) = max |λ|.
λ∈σ(A)

The trace of a matrix is equal to the sum of all its diagonal elements
tr(A) =

n
X

aii .

i=1

It can be easily shown that the trace of A is also equal to the sum of the eigenvalues
of A counted with their multiplicities as roots of the characteristic polynomial.
Proposition 1.3 If λ is an eigenvalue of A, then λ̄ is an eigenvalue of AH . An
eigenvector v of AH associated with the eigenvalue λ̄ is called a left eigenvector of
A.
When a distinction is necessary, an eigenvector of A is often called a right eigenvector. Therefore, the eigenvalue λ as well as the right and left eigenvectors, u and
v, satisfy the relations
Au = λu, v H A = λv H ,
or, equivalently,
uH AH = λ̄uH ,

1.3

AH v = λ̄v.

Types of Matrices

The choice of a method for solving linear systems will often depend on the structure
of the matrix A. One of the most important properties of matrices is symmetry, because of its impact on the eigenstructure of A. A number of other classes of matrices
also have particular eigenstructures. The most important ones are listed below:
• Symmetric matrices: AT = A.
• Hermitian matrices: AH = A.
• Skew-symmetric matrices: AT = −A.
• Skew-Hermitian matrices: AH = −A.
• Normal matrices: AH A = AAH .
• Nonnegative matrices: aij ≥ 0, i, j = 1, . . . , n (similar definition for nonpositive, positive, and negative matrices).

1.3. TYPES OF MATRICES

5

• Unitary matrices: QH Q = I.
It is worth noting that a unitary matrix Q is a matrix whose inverse is its transpose
conjugate QH , since
QH Q = I → Q−1 = QH .
(1.1)

A matrix Q such that QH Q is diagonal is often called orthogonal.
Some matrices have particular structures that are often convenient for computational purposes. The following list, though incomplete, gives an idea of these special
matrices which play an important role in numerical analysis and scientific computing
applications.
• Diagonal matrices: aij = 0 for j 6= i. Notation:

A = diag (a11 , a22 , . . . , ann ) .

• Upper triangular matrices: aij = 0 for i > j.
• Lower triangular matrices: aij = 0 for i < j.
• Upper bidiagonal matrices: aij = 0 for j 6= i or j 6= i + 1.
• Lower bidiagonal matrices: aij = 0 for j 6= i or j 6= i − 1.
• Tridiagonal matrices: aij = 0 for any pair i, j such that |j − i| > 1. Notation:
A = tridiag (ai,i−1 , aii , ai,i+1 ) .

• Banded matrices: aij 6= 0 only if i − ml ≤ j ≤ i + mu , where ml and mu are
two nonnegative integers. The number ml + mu + 1 is called the bandwidth
of A.
• Upper Hessenberg matrices: aij = 0 for any pair i, j such that i > j + 1.
Lower Hessenberg matrices can be defined similarly.
• Outer product matrices: A = uv H , where both u and v are vectors.
• Permutation matrices: the columns of A are a permutation of the columns of
the identity matrix.
• Block diagonal matrices: generalizes the diagonal matrix by replacing each
diagonal entry by a matrix. Notation:
A = diag (A11 , A22 , . . . , Ann ) .
• Block tridiagonal matrices: generalizes the tridiagonal matrix by replacing
each nonzero entry by a square matrix. Notation:
A = tridiag (Ai,i−1 , Aii , Ai,i+1 ) .
The above properties emphasize structure, i.e., positions of the nonzero elements
with respect to the zeros. Also, they assume that there are many zero elements or
that the matrix is of low rank. This is in contrast with the classifications listed earlier,
such as symmetry or normality.

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

6

1.4

Vector Inner Products and Norms

An inner product on a (complex) vector space X is any mapping s from X × X into
C,
x ∈ X, y ∈ X → s(x, y) ∈ C,
which satisfies the following conditions:
1. s(x, y) is linear with respect to x, i.e.,
s(λ1 x1 + λ2 x2 , y) = λ1 s(x1 , y) + λ2 s(x2 , y),

∀ x1 , x2 ∈ X, ∀ λ1 , λ2 ∈ C.

2. s(x, y) is Hermitian, i.e.,
s(y, x) = s(x, y),

∀ x, y ∈ X.

3. s(x, y) is positive definite, i.e.,
s(x, x) > 0,

∀ x 6= 0.

Note that (2) implies that s(x, x) is real and therefore, (3) adds the constraint that
s(x, x) must also be positive for any nonzero x. For any x and y,
s(x, 0) = s(x, 0.y) = 0.s(x, y) = 0.
Similarly, s(0, y) = 0 for any y. Hence, s(0, y) = s(x, 0) = 0 for any x and y. In
particular the condition (3) can be rewritten as
s(x, x) ≥ 0

and

s(x, x) = 0

iff x = 0,

as can be readily shown. A useful relation satisfied by any inner product is the socalled Cauchy-Schwartz inequality:
|s(x, y)|2 ≤ s(x, x) s(y, y).

(1.2)

The proof of this inequality begins by expanding s(x − λy, x − λy) using the properties of s,
s(x − λy, x − λy) = s(x, x) − λ̄s(x, y) − λs(y, x) + |λ|2 s(y, y).
If y = 0 then the inequality is trivially satisfied. Assume that y 6= 0 and take
λ = s(x, y)/s(y, y). Then, from the above equality, s(x − λy, x − λy) ≥ 0 shows
that
|s(x, y)|2
|s(x, y)|2
+
s(y, y)
s(y, y)
2
|s(x, y)|
,
= s(x, x) −
s(y, y)

0 ≤ s(x − λy, x − λy) = s(x, x) − 2

1.4. VECTOR INNER PRODUCTS AND NORMS

7

which yields the result (1.2).
In the particular case of the vector space X = Cn , a “canonical” inner product
is the Euclidean inner product. The Euclidean inner product of two vectors x =
(xi )i=1,...,n and y = (yi )i=1,...,n of Cn is defined by
(x, y) =

n
X

xi ȳi ,

(1.3)

i=1

which is often rewritten in matrix notation as
(x, y) = y H x.

(1.4)

It is easy to verify that this mapping does indeed satisfy the three conditions required
for inner products, listed above. A fundamental property of the Euclidean inner
product in matrix computations is the simple relation
(Ax, y) = (x, AH y), ∀ x, y ∈ Cn .

(1.5)

The proof of this is straightforward. The adjoint of A with respect to an arbitrary
inner product is a matrix B such that (Ax, y) = (x, By) for all pairs of vectors x
and y. A matrix is self-adjoint, or Hermitian with respect to this inner product, if it
is equal to its adjoint. The following proposition is a consequence of the equality
(1.5).
Proposition 1.4 Unitary matrices preserve the Euclidean inner product, i.e.,
(Qx, Qy) = (x, y)
for any unitary matrix Q and any vectors x and y.
Proof. Indeed, (Qx, Qy) = (x, QH Qy) = (x, y).
A vector norm on a vector space X is a real-valued function x → kxk on X,
which satisfies the following three conditions:
1. kxk ≥ 0,

∀ x ∈ X,

2. kαxk = |α|kxk,

and

∀ x ∈ X,

3. kx + yk ≤ kxk + kyk,

kxk = 0 iff x = 0.
∀α ∈ C.

∀ x, y ∈ X.

For the particular case when X = Cn , we can associate with the inner product
(1.3) the Euclidean norm of a complex vector defined by
kxk2 = (x, x)1/2 .
It follows from Proposition 1.4 that a unitary matrix preserves the Euclidean norm
metric, i.e.,
kQxk2 = kxk2 , ∀ x.

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

8

The linear transformation associated with a unitary matrix Q is therefore an isometry.
The most commonly used vector norms in numerical linear algebra are special
cases of the Hölder norms
!1/p
n
X
p
.
(1.6)
|xi |
kxkp =
i=1

Note that the limit of kxkp when p tends to infinity exists and is equal to the maximum modulus of the xi ’s. This defines a norm denoted by k.k∞ . The cases p = 1,
p = 2, and p = ∞ lead to the most important norms in practice,
kxk1 = |x1 | + |x2 | + · · · + |xn |,

1/2
kxk2 = |x1 |2 + |x2 |2 + · · · + |xn |2
,

kxk∞ = max |xi |.
i=1,...,n

The Cauchy-Schwartz inequality of (1.2) becomes
|(x, y)| ≤ kxk2 kyk2 .

1.5

Matrix Norms

For a general matrix A in Cn×m , we define the following special set of norms
kAkpq =

kAxkp
.
x∈C , x6=0 kxkq
max
m

(1.7)

The norm k.kpq is induced by the two norms k.kp and k.kq . These norms satisfy the
usual properties of norms, i.e.,
kAk ≥ 0,

∀ A ∈ Cn×m ,

kαAk = |α|kAk, ∀ A ∈ C

kA + Bk ≤ kAk + kBk,

and
n×m

,

kAk = 0

∀α∈C

∀ A, B ∈ C

n×m

iff A = 0

(1.8)
(1.9)

.

(1.10)
(1.11)

A norm which satisfies the above three properties is nothing but a vector norm applied to the matrix considered as a vector consisting of the m columns stacked into a
vector of size nm.
The most important cases are again those associated with p, q = 1, 2, ∞. The
case q = p is of particular interest and the associated norm k.kpq is simply denoted
by k.kp and called a “p-norm.” A fundamental property of a p-norm is that
kABkp ≤ kAkp kBkp ,
an immediate consequence of the definition (1.7). Matrix norms that satisfy the above
property are sometimes called consistent. Often a norm satisfying the properties

1.5. MATRIX NORMS

9

(1.8–1.10) and which is consistent is called a matrix norm. A result of consistency is
that for any square matrix A,
kAk kp ≤ kAkkp .

In particular the matrix Ak converges to zero if any of its p-norms is less than 1.
The Frobenius norm of a matrix is defined by

1/2
n
m X
X
|aij |2  .
kAkF = 
(1.12)
j=1 i=1

2

This can be viewed as the 2-norm of the column (or row) vector in Cn consisting
of all the columns (respectively rows) of A listed from 1 to m (respectively 1 to n.)
It can be shown that this norm is also consistent, in spite of the fact that it is not
induced by a pair of vector norms, i.e., it is not derived from a formula of the form
(1.7); see Exercise 5. However, it does not satisfy some of the other properties of
the p-norms. For example, the Frobenius norm of the identity matrix is not equal to
one. To avoid these difficulties, we will only use the term matrix norm for a norm
that is induced by two norms as in the definition (1.7). Thus, we will not consider
the Frobenius norm to be a proper matrix norm, according to our conventions, even
though it is consistent.
The following equalities satisfied by the matrix norms defined above lead to alternative definitions that are often easier to work with:
n
X
kAk1 = max
|aij |,
(1.13)
j=1,...,m

kAk∞ = max

i=1,...,n

i=1

m
X

|aij |,

j=1
1/2
H


1/2

,
= ρ(AAH )
kAk2 = ρ(A A)




1/2
1/2
.
= tr(AAH )
kAkF = tr(AH A)

(1.14)
(1.15)
(1.16)

As will be shown later, the eigenvalues of AH A are nonnegative. Their square
roots are called singular values of A and are denoted by σi , i = 1, . . . , m. Thus, the
relation (1.15) states that kAk2 is equal to σ1 , the largest singular value of A.
Example 1.1. From the relation (1.15), it is clear that the spectral radius ρ(A) is
equal to the 2-norm of a matrix when the matrix is Hermitian. However, it is not
a matrix norm in general. For example, the first property of norms is not satisfied,
since for


0 1
A=
,
0 0

we have ρ(A) = 0 while A 6= 0. Also, the triangle inequality is not satisfied for the
pair A, and B = AT where A is defined above. Indeed,
ρ(A + B) = 1

while ρ(A) + ρ(B) = 0.

10

1.6

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

Subspaces, Range, and Kernel

A subspace of Cn is a subset of Cn that is also a complex vector space. The set of
all linear combinations of a set of vectors G = {a1 , a2 , . . . , aq } of Cn is a vector
subspace called the linear span of G,
span{G} = span {a1 , a2 , . . . , aq }
)
(
q
X
q
n
αi ai ; {αi }i=1,...,q ∈ C .
=
z ∈C z=
i=1

If the ai ’s are linearly independent, then each vector of span{G} admits a unique
expression as a linear combination of the ai ’s. The set G is then called a basis of the
subspace span{G}.
Given two vector subspaces S1 and S2 , their sum S is a subspace defined as the
set of all vectors that are equal to the sum of a vector of S1 and a vector of S2 . The
intersection of two subspaces is also a subspace. If the intersection of S1 and S2 is
reduced to {0},
L then the sum of S1 and S2 is called their direct sum and is denoted
by S = S1 S2 . When S is equal to Cn , then every vector x of Cn can be written
in a unique way as the sum of an element x1 of S1 and an element x2 of S2 . The
transformation P that maps x into x1 is a linear transformation that is idempotent,
i.e., such that P 2 = P . It is called a projector onto S1 along S2 .
Two important subspaces that are associated with a matrix A of Cn×m are its
range, defined by
Ran(A) = {Ax | x ∈ Cm },
(1.17)
and its kernel or null space
Null(A) = {x ∈ Cm | Ax = 0 }.
The range of A is clearly equal to the linear span of its columns. The rank of a
matrix is equal to the dimension of the range of A, i.e., to the number of linearly
independent columns. This column rank is equal to the row rank, the number of
linearly independent rows of A. A matrix in Cn×m is of full rank when its rank is
equal to the smallest of m and n. A fundamental result of linear algebra is stated by
the following relation
Cn = Ran(A) ⊕ Null(AT ) .
(1.18)
The same result applied to the transpose of A yields: Cm = Ran(AT ) ⊕ Null(A).
A subspace S is said to be invariant under a (square) matrix A whenever AS ⊂
S. In particular for any eigenvalue λ of A the subspace Null(A − λI) is invariant
under A. The subspace Null(A − λI) is called the eigenspace associated with λ and
consists of all the eigenvectors of A associated with λ, in addition to the zero-vector.

1.7. ORTHOGONAL VECTORS AND SUBSPACES

1.7

11

Orthogonal Vectors and Subspaces

A set of vectors G = {a1 , a2 , . . . , ar } is said to be orthogonal if
(ai , aj ) = 0 when i 6= j.
It is orthonormal if, in addition, every vector of G has a 2-norm equal to unity. A
vector that is orthogonal to all the vectors of a subspace S is said to be orthogonal to
this subspace. The set of all the vectors that are orthogonal to S is a vector subspace
called the orthogonal complement of S and denoted by S ⊥ . The space Cn is the
direct sum of S and its orthogonal complement. Thus, any vector x can be written in
a unique fashion as the sum of a vector in S and a vector in S ⊥ . The operator which
maps x into its component in the subspace S is the orthogonal projector onto S.
Every subspace admits an orthonormal basis which is obtained by taking any
basis and “orthonormalizing” it. The orthonormalization can be achieved by an algorithm known as the Gram-Schmidt process which we now describe.
Given a set of linearly independent vectors {x1 , x2 , . . . , xr }, first normalize the
vector x1 , which means divide it by its 2-norm, to obtain the scaled vector q1 of
norm unity. Then x2 is orthogonalized against the vector q1 by subtracting from x2
a multiple of q1 to make the resulting vector orthogonal to q1 , i.e.,
x2 ← x2 − (x2 , q1 )q1 .
The resulting vector is again normalized to yield the second vector q2 . The i-th step
of the Gram-Schmidt process consists of orthogonalizing the vector xi against all
previous vectors qj .
A LGORITHM 1.1 Gram-Schmidt

1.
2.
3.
4.

Compute r11 := kx1 k2 . If r11 = 0 Stop, else compute q1 := x1 /r11 .
For j = 2, . . . , r Do:
Compute rij := (xj , qi ) , for i = 1, 2, . . . , j − 1
j−1
P
q̂ := xj −
rij qi
i=1

5.
6.
7.

rjj := kq̂k2 ,
If rjj = 0 then Stop, else qj := q̂/rjj
EndDo

It is easy to prove that the above algorithm will not break down, i.e., all r steps
will be completed if and only if the set of vectors x1 , x2 , . . . , xr is linearly independent. From lines 4 and 5, it is clear that at every step of the algorithm the following
relation holds:
j
X
rij qi .
xj =
i=1

12

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

If X = [x1 , x2 , . . . , xr ], Q = [q1 , q2 , . . . , qr ], and if R denotes the r × r upper
triangular matrix whose nonzero elements are the rij defined in the algorithm, then
the above relation can be written as
X = QR.

(1.19)

This is called the QR decomposition of the n × r matrix X. From what was said
above, the QR decomposition of a matrix exists whenever the column vectors of X
form a linearly independent set of vectors.
The above algorithm is the standard Gram-Schmidt process. There are alternative formulations of the algorithm which have better numerical properties. The best
known of these is the Modified Gram-Schmidt (MGS) algorithm.
A LGORITHM 1.2 Modified Gram-Schmidt

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Define r11 := kx1 k2 . If r11 = 0 Stop, else q1 := x1 /r11 .
For j = 2, . . . , r Do:
Define q̂ := xj
For i = 1, . . . , j − 1, Do:
rij := (q̂, qi )
q̂ := q̂ − rij qi
EndDo
Compute rjj := kq̂k2 ,
If rjj = 0 then Stop, else qj := q̂/rjj
EndDo

Yet another alternative for orthogonalizing a sequence of vectors is the Householder algorithm. This technique uses Householder reflectors, i.e., matrices of the
form
P = I − 2wwT ,
(1.20)

in which w is a vector of 2-norm unity. Geometrically, the vector P x represents a
mirror image of x with respect to the hyperplane span{w}⊥ .
To describe the Householder orthogonalization process, the problem can be formulated as that of finding a QR factorization of a given n × m matrix X. For any
vector x, the vector w for the Householder transformation (1.20) is selected in such
a way that
P x = αe1 ,
where α is a scalar. Writing (I − 2wwT )x = αe1 yields
2wT x w = x − αe1 .
This shows that the desired w is a multiple of the vector x − αe1 ,
w=±

x − αe1
.
kx − αe1 k2

For (1.21) to be satisfied, we must impose the condition
2(x − αe1 )T x = kx − αe1 k22

(1.21)

1.7. ORTHOGONAL VECTORS AND SUBSPACES

13

which gives 2(kxk21 − αξ1 ) = kxk22 − 2αξ1 + α2 , where ξ1 ≡ eT1 x is the first
component of the vector x. Therefore, it is necessary that
α = ±kxk2 .
In order to avoid that the resulting vector w be small, it is customary to take
α = −sign(ξ1 )kxk2 ,
which yields
w=

x + sign(ξ1 )kxk2 e1
.
kx + sign(ξ1 )kxk2 e1 k2

(1.22)

Given an n × m matrix, its first column can be transformed to a multiple of the
column e1 , by premultiplying it by a Householder matrix P1 ,
X1 ≡ P1 X,

X1 e1 = αe1 .

Assume, inductively, that the matrix X has been transformed in k − 1 successive
steps into the partially upper triangular form


x11 x12 x13 · · ·
···
···
x1m

x22 x23 · · ·
···
···
x2m 



x33 · · ·
···
···
x3m 


..
..


.
···
···
.


..
Xk ≡ Pk−1 . . . P1 X1 = 
.
.
xkk
···





xk+1,k · · · xk+1,m 


..
..
..


.
.
.
xn,k

···

xn,m

This matrix is upper triangular up to column number k − 1. To advance by one
step, it must be transformed into one which is upper triangular up the k-th column,
leaving the previous columns in the same form. To leave the first k − 1 columns
unchanged, select a w vector which has zeros in positions 1 through k − 1. So the
next Householder reflector matrix is defined as
Pk = I − 2wk wkT ,

(1.23)

in which the vector wk is defined as
wk =

z
,
kzk2

where the components of the vector z are given by

if i < k
 0
β + xii if i = k
zi =

xik
if i > k

(1.24)

(1.25)

14

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

with
β = sign(xkk ) ×

n
X

x2ik

i=k

!1/2

.

(1.26)

We note in passing that the premultiplication of a matrix X by a Householder
transform requires only a rank-one update since,
(I − 2wwT )X = X − wv T

where

v = 2X T w.

Therefore, the Householder matrices need not, and should not, be explicitly formed.
In addition, the vectors w need not be explicitly scaled.
Assume now that m − 1 Householder transforms have been applied to a certain
matrix X of dimension n × m, to reduce it into the upper triangular form,


x11 x12 x13 · · · x1m

x22 x23 · · · x2m 



x33 · · · x3m 

.. 
..


.
. 

Xm ≡ Pm−1 Pm−2 . . . P1 X = 
(1.27)
.
xm,m 




0 

.. 

. 
..
.

Recall that our initial goal was to obtain a QR factorization of X. We now wish to
recover the Q and R matrices from the Pk ’s and the above matrix. If we denote by
P the product of the Pi on the left-side of (1.27), then (1.27) becomes
 
R
PX =
,
(1.28)
O
in which R is an m × m upper triangular matrix, and O is an (n − m) × m zero
block. Since P is unitary, its inverse is equal to its transpose and, as a result,
 
 
R
R
X = PT
= P1 P2 . . . Pm−1
.
O
O
If Em is the matrix of size n×m which consists of the first m columns of the identity
matrix, then the above equality translates into
X = P T Em R.
The matrix Q = P T Em represents the m first columns of P T . Since
T
QT Q = Em
P P T Em = I,

Q and R are the matrices sought. In summary,
X = QR,

1.8. CANONICAL FORMS OF MATRICES

15

in which R is the triangular matrix obtained from the Householder reduction of X
(see (1.27) and (1.28)) and
Qej = P1 P2 . . . Pm−1 ej .
A LGORITHM 1.3 Householder Orthogonalization

Define X = [x1 , . . . , xm ]
For k = 1, . . . , m Do:
If k > 1 compute rk := Pk−1 Pk−2 . . . P1 xk
Compute wk using (1.24), (1.25), (1.26)
Compute rk := Pk rk with Pk = I − 2wk wkT
Compute qk = P1 P2 . . . Pk ek
EndDo

1.
2.
3.
4.
5.
6.
7.

Note that line 6 can be omitted since the qi are not needed in the execution of the
next steps. It must be executed only when the matrix Q is needed at the completion of
the algorithm. Also, the operation in line 5 consists only of zeroing the components
k + 1, . . . , n and updating the k-th component of rk . In practice, a work vector can
be used for rk and its nonzero components after this step can be saved into an upper
triangular matrix. Since the components 1 through k of the vector wk are zero, the
upper triangular matrix R can be saved in those zero locations which would otherwise
be unused.

1.8

Canonical Forms of Matrices

This section discusses the reduction of square matrices into matrices that have simpler forms, such as diagonal, bidiagonal, or triangular. Reduction means a transformation that preserves the eigenvalues of a matrix.
Definition 1.5 Two matrices A and B are said to be similar if there is a nonsingular
matrix X such that
A = XBX −1 .
The mapping B → A is called a similarity transformation.
It is clear that similarity is an equivalence relation. Similarity transformations preserve the eigenvalues of matrices. An eigenvector uB of B is transformed into the
eigenvector uA = XuB of A. In effect, a similarity transformation amounts to representing the matrix B in a different basis.
We now introduce some terminology.
1. An eigenvalue λ of A has algebraic multiplicity µ, if it is a root of multiplicity
µ of the characteristic polynomial.
2. If an eigenvalue is of algebraic multiplicity one, it is said to be simple. A
nonsimple eigenvalue is multiple.

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

16

3. The geometric multiplicity γ of an eigenvalue λ of A is the maximum number
of independent eigenvectors associated with it. In other words, the geometric
multiplicity γ is the dimension of the eigenspace Null (A − λI).
4. A matrix is derogatory if the geometric multiplicity of at least one of its eigenvalues is larger than one.
5. An eigenvalue is semisimple if its algebraic multiplicity is equal to its geometric multiplicity. An eigenvalue that is not semisimple is called defective.
Often, λ1 , λ2 , . . . , λp (p ≤ n) are used to denote the distinct eigenvalues of
A. It is easy to show that the characteristic polynomials of two similar matrices are
identical; see Exercise 9. Therefore, the eigenvalues of two similar matrices are equal
and so are their algebraic multiplicities. Moreover, if v is an eigenvector of B, then
Xv is an eigenvector of A and, conversely, if y is an eigenvector of A then X −1 y is
an eigenvector of B. As a result the number of independent eigenvectors associated
with a given eigenvalue is the same for two similar matrices, i.e., their geometric
multiplicity is also the same.

1.8.1

Reduction to the Diagonal Form

The simplest form in which a matrix can be reduced is undoubtedly the diagonal
form. Unfortunately, this reduction is not always possible. A matrix that can be
reduced to the diagonal form is called diagonalizable. The following theorem characterizes such matrices.
Theorem 1.6 A matrix of dimension n is diagonalizable if and only if it has n linearly independent eigenvectors.
Proof. A matrix A is diagonalizable if and only if there exists a nonsingular matrix
X and a diagonal matrix D such that A = XDX −1 , or equivalently AX = XD,
where D is a diagonal matrix. This is equivalent to saying that n linearly independent
vectors exist — the n column-vectors of X — such that Axi = di xi . Each of these
column-vectors is an eigenvector of A.
A matrix that is diagonalizable has only semisimple eigenvalues. Conversely, if all
the eigenvalues of a matrix A are semisimple, then A has n eigenvectors. It can be
easily shown that these eigenvectors are linearly independent; see Exercise 2. As a
result, we have the following proposition.
Proposition 1.7 A matrix is diagonalizable if and only if all its eigenvalues are
semisimple.
Since every simple eigenvalue is semisimple, an immediate corollary of the above
result is: When A has n distinct eigenvalues, then it is diagonalizable.

1.8. CANONICAL FORMS OF MATRICES

1.8.2

17

The Jordan Canonical Form

From the theoretical viewpoint, one of the most important canonical forms of matrices is the well known Jordan form. A full development of the steps leading to
the Jordan form is beyond the scope of this book. Only the main theorem is stated.
Details, including the proof, can be found in standard books of linear algebra such
as [164]. In the following, mi refers to the algebraic multiplicity of the individual
eigenvalue λi and li is the index of the eigenvalue, i.e., the smallest integer for which
Null(A − λi I)li +1 = Null(A − λi I)li .
Theorem 1.8 Any matrix A can be reduced to a block diagonal matrix consisting
of p diagonal blocks, each associated with a distinct eigenvalue λi . Each of these
diagonal blocks has itself a block diagonal structure consisting of γi sub-blocks,
where γi is the geometric multiplicity of the eigenvalue λi . Each of the sub-blocks,
referred to as a Jordan block, is an upper bidiagonal matrix of size not exceeding
li ≤ mi , with the constant λi on the diagonal and the constant one on the super
diagonal.
The i-th diagonal block, i = 1, . . . , p, is known as the i-th Jordan submatrix (sometimes “Jordan Box”). The Jordan submatrix number i starts in column ji ≡ m1 +
m2 + · · · + mi−1 + 1. Thus,


J1


J2


..


.


X −1 AX = J = 
,
Ji




..


.
Jp

where each Ji is associated with λi and is of size mi the algebraic multiplicity of λi .
It has itself the following structure,




λi 1
Ji1
.. ..




Ji2
.
.
 with Jik = 
.
Ji = 
.



..
λi 1 
Jiγi
λi

Each of the blocks Jik corresponds to a different eigenvector associated with the
eigenvalue λi . Its size li is the index of λi .

1.8.3

The Schur Canonical Form

Here, it will be shown that any matrix is unitarily similar to an upper triangular
matrix. The only result needed to prove the following theorem is that any vector of
2-norm one can be completed by n − 1 additional vectors to form an orthonormal
basis of Cn .

18

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

Theorem 1.9 For any square matrix A, there exists a unitary matrix Q such that
QH AQ = R
is upper triangular.
Proof. The proof is by induction over the dimension n. The result is trivial for
n = 1. Assume that it is true for n − 1 and consider any matrix A of size n. The
matrix admits at least one eigenvector u that is associated with an eigenvalue λ. Also
assume without loss of generality that kuk2 = 1. First, complete the vector u into
an orthonormal set, i.e., find an n × (n − 1) matrix V such that the n × n matrix
U = [u, V ] is unitary. Then AU = [λu, AV ] and hence,
 H


u
λ uH AV
H
U AU =
[λu, AV ] =
.
(1.29)
VH
0 V H AV
Now use the induction hypothesis for the (n − 1) × (n − 1) matrix B = V H AV :
There exists an (n − 1) × (n − 1) unitary matrix Q1 such that QH
1 BQ1 = R1 is
upper triangular. Define the n × n matrix


1 0
Q̂1 =
0 Q1
and multiply both members of (1.29) by Q̂H
1 from the left and Q̂1 from the right. The
resulting matrix is clearly upper triangular and this shows that the result is true for
A, with Q = Q̂1 U which is a unitary n × n matrix.
A simpler proof that uses the Jordan canonical form and the QR decomposition is the
subject of Exercise 7. Since the matrix R is triangular and similar to A, its diagonal
elements are equal to the eigenvalues of A ordered in a certain manner. In fact, it is
easy to extend the proof of the theorem to show that this factorization can be obtained
with any order for the eigenvalues. Despite its simplicity, the above theorem has farreaching consequences, some of which will be examined in the next section.
It is important to note that for any k ≤ n, the subspace spanned by the first k
columns of Q is invariant under A. Indeed, the relation AQ = QR implies that for
1 ≤ j ≤ k, we have
i=j
X
rij qi .
Aqj =
i=1

If we let Qk = [q1 , q2 , . . . , qk ] and if Rk is the principal leading submatrix of dimension k of R, the above relation can be rewritten as
AQk = Qk Rk ,

which is known as the partial Schur decomposition of A. The simplest case of this
decomposition is when k = 1, in which case q1 is an eigenvector. The vectors qi are

1.8. CANONICAL FORMS OF MATRICES

19

usually called Schur vectors. Schur vectors are not unique and depend, in particular,
on the order chosen for the eigenvalues.
A slight variation on the Schur canonical form is the quasi-Schur form, also
called the real Schur form. Here, diagonal blocks of size 2 × 2 are allowed in the
upper triangular matrix R. The reason for this is to avoid complex arithmetic when
the original matrix is real. A 2 × 2 block is associated with each complex conjugate
pair of eigenvalues of the matrix.
Example 1.2. Consider the 3 × 3 matrix


1 10 0
A =  −1 3 1  .
−1 0 1

The matrix A has the pair of complex conjugate eigenvalues
2.4069 . . . ± i × 3.2110 . . .

and the real eigenvalue 0.1863 . . .. The standard (complex) Schur form is given by
the pair of matrices


0.3381 − 0.8462i
0.3572 − 0.1071i
0.1749
V =  0.3193 − 0.0105i −0.2263 − 0.6786i −0.6214 
0.1824 + 0.1852i −0.2659 − 0.5277i
0.7637
and




2.4069 + 3.2110i 4.6073 − 4.7030i −2.3418 − 5.2330i
S=
0 2.4069 − 3.2110i −2.0251 − 1.2016i  .
0
0
0.1863

It is possible to avoid complex arithmetic by using the quasi-Schur form which consists of the pair of matrices


−0.9768 0.1236
0.1749
U =  −0.0121 0.7834 −0.6214 
0.2138 0.6091
0.7637

and




1.3129 −7.7033
6.0407
R =  1.4938
3.5008 −1.3870  .
0
0
0.1863

We conclude this section by pointing out that the Schur and the quasi-Schur
forms of a given matrix are in no way unique. In addition to the dependence on the
ordering of the eigenvalues, any column of Q can be multiplied by a complex sign
eiθ and a new corresponding R can be found. For the quasi-Schur form, there are
infinitely many ways to select the 2 × 2 blocks, corresponding to applying arbitrary
rotations to the columns of Q associated with these blocks.

20

1.8.4

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

Application to Powers of Matrices

The analysis of many numerical techniques is based on understanding the behavior of
the successive powers Ak of a given matrix A. In this regard, the following theorem
plays a fundamental role in numerical linear algebra, more particularly in the analysis
of iterative methods.
Theorem 1.10 The sequence Ak , k = 0, 1, . . . , converges to zero if and only if
ρ(A) < 1.
Proof. To prove the necessary condition, assume that Ak → 0 and consider u1 a
unit eigenvector associated with an eigenvalue λ1 of maximum modulus. We have
Ak u1 = λk1 u1 ,
which implies, by taking the 2-norms of both sides,
|λk1 | = kAk u1 k2 → 0.
This shows that ρ(A) = |λ1 | < 1.
The Jordan canonical form must be used to show the sufficient condition. Assume that ρ(A) < 1. Start with the equality
Ak = XJ k X −1 .
To prove that Ak converges to zero, it is sufficient to show that J k converges to
zero. An important observation is that J k preserves its block form. Therefore, it is
sufficient to prove that each of the Jordan blocks converges to zero. Each block is of
the form
Ji = λi I + Ei
where Ei is a nilpotent matrix of index li , i.e., Eili = 0. Therefore, for k ≥ li ,
Jik =

lX
i −1
j=0

k!
λk−j Eij .
j!(k − j)! i

Using the triangle inequality for any norm and taking k ≥ li yields
kJik k ≤

lX
i −1
j=0

k!
|λi |k−j kEij k.
j!(k − j)!

Since |λi | < 1, each of the terms in this finite sum converges to zero as k → ∞.
Therefore, the matrix Jik converges to zero.
An equally important result is stated in the following theorem.

1.9. NORMAL AND HERMITIAN MATRICES
Theorem 1.11 The series

∞
X

21

Ak

k=0

converges if and only if ρ(A) < 1. Under this condition, I − A is nonsingular and
the limit of the series is equal to (I − A)−1 .
Proof. The first part of the theorem is an immediate consequence of Theorem 1.10.
Indeed, if the series converges, then kAk k → 0. By the previous theorem, this
implies that ρ(A) < 1. To show that the converse is also true, use the equality
I − Ak+1 = (I − A)(I + A + A2 + . . . + Ak )
and exploit the fact that since ρ(A) < 1, then I − A is nonsingular, and therefore,
(I − A)−1 (I − Ak+1 ) = I + A + A2 + . . . + Ak .
This shows that the series converges since the left-hand side will converge to (I −
A)−1 . In addition, it also shows the second part of the theorem.
Another important consequence of the Jordan canonical form is a result that relates the spectral radius of a matrix to its matrix norm.
Theorem 1.12 For any matrix norm k.k, we have
lim kAk k1/k = ρ(A).

k→∞

Proof. The proof is a direct application of the Jordan canonical form and is the
subject of Exercise 10.

1.9

Normal and Hermitian Matrices

This section examines specific properties of normal matrices and Hermitian matrices,
including some optimality properties related to their spectra. The most common
normal matrices that arise in practice are Hermitian or skew-Hermitian.

1.9.1

Normal Matrices

By definition, a matrix is said to be normal if it commutes with its transpose conjugate, i.e., if it satisfies the relation
AH A = AAH .
An immediate property of normal matrices is stated in the following lemma.
Lemma 1.13 If a normal matrix is triangular, then it is a diagonal matrix.

(1.30)

22

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

Proof. Assume, for example, that A is upper triangular and normal. Compare the
first diagonal element of the left-hand side matrix of (1.30) with the corresponding
element of the matrix on the right-hand side. We obtain that
2

|a11 | =

n
X
j=1

|a1j |2 ,

which shows that the elements of the first row are zeros except for the diagonal one.
The same argument can now be used for the second row, the third row, and so on to
the last row, to show that aij = 0 for i 6= j.
A consequence of this lemma is the following important result.
Theorem 1.14 A matrix is normal if and only if it is unitarily similar to a diagonal
matrix.
Proof. It is straightforward to verify that a matrix which is unitarily similar to a
diagonal matrix is normal. We now prove that any normal matrix A is unitarily
similar to a diagonal matrix. Let A = QRQH be the Schur canonical form of A
where Q is unitary and R is upper triangular. By the normality of A,
QRH QH QRQH = QRQH QRH QH
or,
QRH RQH = QRRH QH .
Upon multiplication by QH on the left and Q on the right, this leads to the equality
RH R = RRH which means that R is normal, and according to the previous lemma
this is only possible if R is diagonal.
Thus, any normal matrix is diagonalizable and admits an orthonormal basis of eigenvectors, namely, the column vectors of Q.
The following result will be used in a later chapter. The question that is asked
is: Assuming that any eigenvector of a matrix A is also an eigenvector of AH , is A
normal? If A had a full set of eigenvectors, then the result is true and easy to prove.
Indeed, if V is the n × n matrix of common eigenvectors, then AV = V D1 and
AH V = V D2 , with D1 and D2 diagonal. Then, AAH V = V D1 D2 and AH AV =
V D2 D1 and, therefore, AAH = AH A. It turns out that the result is true in general,
i.e., independently of the number of eigenvectors that A admits.
Lemma 1.15 A matrix A is normal if and only if each of its eigenvectors is also an
eigenvector of AH .
Proof. If A is normal, then its left and right eigenvectors are identical, so the sufficient condition is trivial. Assume now that a matrix A is such that each of its eigenvectors vi , i = 1, . . . , k, with k ≤ n is an eigenvector of AH . For each eigenvector vi

1.9. NORMAL AND HERMITIAN MATRICES

23

of A, Avi = λi vi , and since vi is also an eigenvector of AH , then AH vi = µvi . Observe that (AH vi , vi ) = µ(vi , vi ) and because (AH vi , vi ) = (vi , Avi ) = λ̄i (vi , vi ), it
follows that µ = λ̄i . Next, it is proved by contradiction that there are no elementary
divisors. Assume that the contrary is true for λi . Then, the first principal vector ui
associated with λi is defined by
(A − λi I)ui = vi .
Taking the inner product of the above relation with vi , we obtain
(Aui , vi ) = λi (ui , vi ) + (vi , vi ).

(1.31)

On the other hand, it is also true that
(Aui , vi ) = (ui , AH vi ) = (ui , λ̄i vi ) = λi (ui , vi ).

(1.32)

A result of (1.31) and (1.32) is that (vi , vi ) = 0 which is a contradiction. Therefore,
A has a full set of eigenvectors. This leads to the situation discussed just before the
lemma, from which it is concluded that A must be normal.
Clearly, Hermitian matrices are a particular case of normal matrices. Since a
normal matrix satisfies the relation A = QDQH , with D diagonal and Q unitary, the
eigenvalues of A are the diagonal entries of D. Therefore, if these entries are real it
is clear that AH = A. This is restated in the following corollary.
Corollary 1.16 A normal matrix whose eigenvalues are real is Hermitian.
As will be seen shortly, the converse is also true, i.e., a Hermitian matrix has real
eigenvalues.
An eigenvalue λ of any matrix satisfies the relation
λ=

(Au, u)
,
(u, u)

where u is an associated eigenvector. Generally, one might consider the complex
scalars
(Ax, x)
,
(1.33)
µ(x) =
(x, x)
defined for any nonzero vector in Cn . These ratios are known as Rayleigh quotients
and are important both for theoretical and practical purposes. The set of all possible
Rayleigh quotients as x runs over Cn is called the field of values of A. This set is
clearly bounded since each |µ(x)| is bounded by the the 2-norm of A, i.e., |µ(x)| ≤
kAk2 for all x.
If a matrix is normal, then any vector x in Cn can be expressed as
n
X
i=1

ξi q i ,

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

24

where the vectors qi form an orthogonal basis of eigenvectors, and the expression for
µ(x) becomes
Pn
n
X
λk |ξk |2
(Ax, x)
k=1
µ(x) =
= Pn
≡
βk λk ,
(1.34)
2
(x, x)
k=1 |ξk |
k=1

where

|ξi |2
≤ 1,
0 ≤ βi = Pn
2
k=1 |ξk |

and

n
X

βi = 1.

i=1

From a well known characterization of convex hulls established by Hausdorff (Hausdorff’s convex hull theorem), this means that the set of all possible Rayleigh quotients as x runs over all of Cn is equal to the convex hull of the λi ’s. This leads to
the following theorem which is stated without proof.
Theorem 1.17 The field of values of a normal matrix is equal to the convex hull of
its spectrum.
The next question is whether or not this is also true for nonnormal matrices and
the answer is no: The convex hull of the eigenvalues and the field of values of a
nonnormal matrix are different in general. As a generic example, one can take any
nonsymmetric real matrix which has real eigenvalues only. In this case, the convex
hull of the spectrum is a real interval but its field of values will contain imaginary
values. See Exercise 12 for another example. It has been shown (Hausdorff) that
the field of values of a matrix is a convex set. Since the eigenvalues are members
of the field of values, their convex hull is contained in the field of values. This is
summarized in the following proposition.
Proposition 1.18 The field of values of an arbitrary matrix is a convex set which
contains the convex hull of its spectrum. It is equal to the convex hull of the spectrum
when the matrix is normal.
A useful definition based on field of values is that of the numerical radius. The
numerical radius ν(A) of an arbitrary matrix A is the radius of the smallest disk
containing the field of values, i.e.,
ν(A) = maxn |µ(x)| .
x∈C

It is easy to see that
ρ(A) ≤ ν(A) ≤ kAk2 .

The spectral radius and numerical radius are identical for normal matrices. It can
also be easily shown (see Exercise 21) that ν(A) ≥ kAk2 /2, which means that

kAk2
≤ ν(A) ≤ kAk2 .
(1.35)
2
The numerical radius is a vector norm, i.e., it satisfies (1.8–1.10), but it is not consistent, see Exercise 22. However, it satisfies the power inequality (See [172, p333]):
ν(Ak ) ≤ ν(A)k .

(1.36)

1.9. NORMAL AND HERMITIAN MATRICES

1.9.2

25

Hermitian Matrices

A first result on Hermitian matrices is the following.
Theorem 1.19 The eigenvalues of a Hermitian matrix are real, i.e., σ(A) ⊂ R.
Proof. Let λ be an eigenvalue of A and u an associated eigenvector of 2-norm unity.
Then
λ = (Au, u) = (u, Au) = (Au, u) = λ,
which is the stated result.
It is not difficult to see that if, in addition, the matrix is real, then the eigenvectors
can be chosen to be real; see Exercise 24. Since a Hermitian matrix is normal, the
following is a consequence of Theorem 1.14.
Theorem 1.20 Any Hermitian matrix is unitarily similar to a real diagonal matrix.
In particular a Hermitian matrix admits a set of orthonormal eigenvectors that form
a basis of Cn .
In the proof of Theorem 1.17 we used the fact that the inner products (Au, u) are
real. Generally, it is clear that any Hermitian matrix is such that (Ax, x) is real for
any vector x ∈ Cn . It turns out that the converse is also true, i.e., it can be shown that
if (Az, z) is real for all vectors z in Cn , then the matrix A is Hermitian; see Exercise
15.
Eigenvalues of Hermitian matrices can be characterized by optimality properties
of the Rayleigh quotients (1.33). The best known of these is the min-max principle.
We now label all the eigenvalues of A in descending order:
λ1 ≥ λ2 ≥ · · · ≥ λn .
Here, the eigenvalues are not necessarily distinct and they are repeated, each according to its multiplicity. In the following theorem, known as the Min-Max Theorem, S
represents a generic subspace of Cn .
Theorem 1.21 The eigenvalues of a Hermitian matrix A are characterized by the
relation
(Ax, x)
.
(1.37)
λk =
min
max
x∈S,x6=0
(x, x)
S, dim (S)=n−k+1
Proof. Let {qi }i=1,...,n be an orthonormal basis of Cn consisting of eigenvectors of A
associated with λ1 , . . . , λn respectively. Let Sk be the subspace spanned by the first k
of these vectors and denote by µ(S) the maximum of (Ax, x)/(x, x) over all nonzero
vectors of a subspace S. Since the dimension of Sk is k, a well known theorem of
linear algebra shows that its intersection with any subspace S of dimension n − k + 1

26

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

T
P
is not reduced to {0}, i.e., there is vector x in S Sk . For this x = ki=1 ξi qi , we
have
Pk
λi |ξi |2
(Ax, x)
≥ λk
= Pi=1
k
2
(x, x)
|ξ
|
i
i=1

so that µ(S) ≥ λk .
Consider, on the other hand, the particular subspace S0 of dimension n − k + 1
which is spanned by qk , . . . , qn . For each vector x in this subspace, we have
Pn
2
(Ax, x)
i=k λi |ξi |
≤ λk
= P
n
2
(x, x)
i=k |ξi |

so that µ(S0 ) ≤ λk . In other words, as S runs over all the (n − k + 1)-dimensional
subspaces, µ(S) is always ≥ λk and there is at least one subspace S0 for which
µ(S0 ) ≤ λk . This shows the desired result.
The above result is often called the Courant-Fisher min-max principle or theorem.
As a particular case, the largest eigenvalue of A satisfies
λ1 = max
x6=0

(Ax, x)
.
(x, x)

(1.38)

Actually, there are four different ways of rewriting the above characterization.
The second formulation is
λk =

max
min
S, dim (S)=k x∈S,x6=0

(Ax, x)
(x, x)

(1.39)

and the two other ones can be obtained from (1.37) and (1.39) by simply relabeling
the eigenvalues increasingly instead of decreasingly. Thus, with our labeling of the
eigenvalues in descending order, (1.39) tells us that the smallest eigenvalue satisfies
(Ax, x)
,
x6=0 (x, x)

λn = min

(1.40)

with λn replaced by λ1 if the eigenvalues are relabeled increasingly.
In order for all the eigenvalues of a Hermitian matrix to be positive, it is necessary
and sufficient that
(Ax, x) > 0, ∀ x ∈ Cn , x 6= 0.
Such a matrix is called positive definite. A matrix which satisfies (Ax, x) ≥ 0 for any
x is said to be positive semidefinite. In particular, the matrix AH A is semipositive
definite for any rectangular matrix, since
(AH Ax, x) = (Ax, Ax) ≥ 0,

∀ x.

Similarly, AAH is also a Hermitian semipositive definite matrix. The square roots
of the eigenvalues of AH A for a general rectangular matrix A are called the singular
values of A and are denoted by σi . In Section 1.5, we have stated without proof that

1.10. NONNEGATIVE MATRICES, M-MATRICES

27

the 2-norm of any matrix A is equal to the largest singular value σ1 of A. This is now
an obvious fact, because
kAk22 = max
x6=0

(AH Ax, x)
(Ax, Ax)
kAxk22
=
max
= σ12
=
max
x6=0
x6=0
(x, x)
(x, x)
kxk22

which results from (1.38).
Another characterization of eigenvalues, known as the Courant characterization,
is stated in the next theorem. In contrast with the min-max theorem, this property is
recursive in nature.
Theorem 1.22 The eigenvalue λi and the corresponding eigenvector qi of a Hermitian matrix are such that
λ1 =

(Aq1 , q1 )
(Ax, x)
= max
x∈Cn ,x6=0 (x, x)
(q1 , q1 )

and for k > 1,
λk =

(Ax, x)
(Aqk , qk )
=
max
.
H
H
(qk , qk )
x6=0,q1 x=...=qk−1 x=0 (x, x)

(1.41)

In other words, the maximum of the Rayleigh quotient over a subspace that is
orthogonal to the first k − 1 eigenvectors is equal to λk and is achieved for the
eigenvector qk associated with λk . The proof follows easily from the expansion
(1.34) of the Rayleigh quotient.

1.10

Nonnegative Matrices, M-Matrices

Nonnegative matrices play a crucial role in the theory of matrices. They are important in the study of convergence of iterative methods and arise in many applications
including economics, queuing theory, and chemical engineering.
A nonnegative matrix is simply a matrix whose entries are nonnegative. More
generally, a partial order relation can be defined on the set of matrices.
Definition 1.23 Let A and B be two n × m matrices. Then
A≤B
if by definition, aij ≤ bij for 1 ≤ i ≤ n, 1 ≤ j ≤ m. If O denotes the n × m zero
matrix, then A is nonnegative if A ≥ O, and positive if A > O. Similar definitions
hold in which “positive” is replaced by “negative”.
The binary relation “≤” imposes only a partial order on Rn×m since two arbitrary
matrices in Rn×m are not necessarily comparable by this relation. For the remainder of this section, we now assume that only square matrices are involved. The next
proposition lists a number of rather trivial properties regarding the partial order relation just defined.

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

28

Proposition 1.24 The following properties hold.
1. The relation ≤ for matrices is reflexive (A ≤ A), antisymmetric (if A ≤ B and
B ≤ A, then A = B), and transitive (if A ≤ B and B ≤ C, then A ≤ C).
2. If A and B are nonnegative, then so is their product AB and their sum A + B.
3. If A is nonnegative, then so is Ak .
4. If A ≤ B, then AT ≤ B T .
5. If O ≤ A ≤ B, then kAk1 ≤ kBk1 and similarly kAk∞ ≤ kBk∞ .
The proof of these properties is left as Exercise 26.
A matrix is said to be reducible if there is a permutation matrix P such that
P AP T is block upper triangular. Otherwise, it is irreducible. An important result concerning nonnegative matrices is the following theorem known as the PerronFrobenius theorem.
Theorem 1.25 Let A be a real n × n nonnegative irreducible matrix. Then λ ≡
ρ(A), the spectral radius of A, is a simple eigenvalue of A. Moreover, there exists an
eigenvector u with positive elements associated with this eigenvalue.
A relaxed version of this theorem allows the matrix to be reducible but the conclusion
is somewhat weakened in the sense that the elements of the eigenvectors are only
guaranteed to be nonnegative.
Next, a useful property is established.
Proposition 1.26 Let A, B, C be nonnegative matrices, with A ≤ B. Then
AC ≤ BC

CA ≤ CB.

and

Proof. Consider the first inequality only, since the proof for the second is identical.
The result that is claimed translates into
n
X
k=1

aik ckj ≤

n
X

bik ckj ,

k=1

1 ≤ i, j ≤ n,

which is clearly true by the assumptions.
A consequence of the proposition is the following corollary.
Corollary 1.27 Let A and B be two nonnegative matrices, with A ≤ B. Then
Ak ≤ B k ,

∀ k ≥ 0.

(1.42)

1.10. NONNEGATIVE MATRICES, M-MATRICES

29

Proof. The proof is by induction. The inequality is clearly true for k = 0. Assume
that (1.42) is true for k. According to the previous proposition, multiplying (1.42)
from the left by A results in
Ak+1 ≤ AB k .
(1.43)

Now, it is clear that if B ≥ 0, then also B k ≥ 0, by Proposition 1.24. We now
multiply both sides of the inequality A ≤ B by B k to the right, and obtain
AB k ≤ B k+1 .

(1.44)

The inequalities (1.43) and (1.44) show that Ak+1 ≤ B k+1 , which completes the
induction proof.
A theorem which has important consequences on the analysis of iterative methods will now be stated.
Theorem 1.28 Let A and B be two square matrices that satisfy the inequalities
O ≤ A ≤ B.

(1.45)

ρ(A) ≤ ρ(B).

(1.46)

Then

Proof. The proof is based on the following equality stated in Theorem 1.12
ρ(X) = lim kX k k1/k
k→∞

for any matrix norm. Choosing the 1−norm, for example, we have from the last
property in Proposition 1.24
1/k

ρ(A) = lim kAk k1
k→∞

1/k

≤ lim kB k k1
k→∞

= ρ(B)

which completes the proof.
Theorem 1.29 Let B be a nonnegative matrix. Then ρ(B) < 1 if and only if I − B
is nonsingular and (I − B)−1 is nonnegative.
Proof. Define C = I − B. If it is assumed that ρ(B) < 1, then by Theorem 1.11,
C = I − B is nonsingular and
C

−1

−1

= (I − B)

=

∞
X

Bi.

(1.47)

i=0

In addition, since B ≥ 0, all the powers of B as well as their sum in (1.47) are also
nonnegative.

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

30

To prove the sufficient condition, assume that C is nonsingular and that its inverse is nonnegative. By the Perron-Frobenius theorem, there is a nonnegative eigenvector u associated with ρ(B), which is an eigenvalue, i.e.,
Bu = ρ(B)u
or, equivalently,
C −1 u =

1
u.
1 − ρ(B)

Since u and C −1 are nonnegative, and I − B is nonsingular, this shows that 1 −
ρ(B) > 0, which is the desired result.
Definition 1.30 A matrix is said to be an M -matrix if it satisfies the following four
properties:
1. ai,i > 0 for i = 1, . . . , n.
2. ai,j ≤ 0 for i 6= j, i, j = 1, . . . , n.
3. A is nonsingular.
4. A−1 ≥ 0.
In reality, the four conditions in the above definition are somewhat redundant and
equivalent conditions that are more rigorous will be given later. Let A be any matrix
which satisfies properties (1) and (2) in the above definition and let D be the diagonal
of A. Since D > 0,

A = D − (D − A) = D I − (I − D −1 A) .
Now define

B ≡ I − D −1 A.

Using the previous theorem, I − B = D −1 A is nonsingular and (I − B)−1 =
A−1 D ≥ 0 if and only if ρ(B) < 1. It is now easy to see that conditions (3) and (4)
of Definition 1.30 can be replaced by the condition ρ(B) < 1.
Theorem 1.31 Let a matrix A be given such that
1. ai,i > 0 for i = 1, . . . , n.
2. ai,j ≤ 0 for i 6= j, i, j = 1, . . . , n.
Then A is an M -matrix if and only if
3. ρ(B) < 1, where B = I − D −1 A.

1.10. NONNEGATIVE MATRICES, M-MATRICES

31

Proof. From the above argument, an immediate application of Theorem 1.29 shows
that properties (3) and (4) of the above definition are equivalent to ρ(B) < 1, where
B = I − C and C = D −1 A. In addition, C is nonsingular iff A is and C −1 is
nonnegative iff A is.
The next theorem shows that the condition (1) in Definition 1.30 is implied by
the other three.
Theorem 1.32 Let a matrix A be given such that
1. ai,j ≤ 0 for i 6= j, i, j = 1, . . . , n.
2. A is nonsingular.
3. A−1 ≥ 0.
Then
4. ai,i > 0 for i = 1, . . . , n, i.e., A is an M -matrix.
5. ρ(B) < 1 where B = I − D −1 A.
Proof. Define C ≡ A−1 . Writing that (AC)ii = 1 yields
n
X

aik cki = 1

k=1

which gives
aii cii = 1 −

n
X

aik cki .

k=1
k6=i

Since aik cki ≤ 0 for all k, the right-hand side is ≥ 1 and since cii ≥ 0, then aii > 0.
The second part of the result now follows immediately from an application of the
previous theorem.
Finally, this useful result follows.
Theorem 1.33 Let A, B be two matrices which satisfy
1. A ≤ B.
2. bij ≤ 0 for all i 6= j.
Then if A is an M -matrix, so is the matrix B.

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

32

Proof. Assume that A is an M -matrix and let DX denote the diagonal of a matrix
X. The matrix DB is positive because
DB ≥ DA > 0.
−1
B. Since A ≤ B, then
Consider now the matrix I − DB

DA − A ≥ DB − B ≥ O
−1
, yields
which, upon multiplying through by DA
−1
−1
−1
−1
B ≥ O.
(DB − B) = I − DB
(DB − B) ≥ DB
A ≥ DA
I − DA
−1
−1
A are nonnegative, Theorems 1.28 and
B and I − DA
Since the matrices I − DB
1.31 imply that
−1
−1
A) < 1.
B) ≤ ρ(I − DA
ρ(I − DB

This establishes the result by using Theorem 1.31 once again.

1.11

Positive-Definite Matrices

A real matrix is said to be positive definite or positive real if
(Au, u) > 0,

∀ u ∈ Rn , u 6= 0.

(1.48)

It must be emphasized that this definition is only useful when formulated entirely for
real variables. Indeed, if u were not restricted to be real, then assuming that (Au, u)
is real for all u complex would imply that A is Hermitian; see Exercise 15. If, in
addition to the definition stated by 1.48, A is symmetric (real), then A is said to be
Symmetric Positive Definite (SPD). Similarly, if A is Hermitian, then A is said to be
Hermitian Positive Definite (HPD). Some properties of HPD matrices were seen in
Section 1.9, in particular with regards to their eigenvalues. Now the more general
case where A is non-Hermitian and positive definite is considered.
We begin with the observation that any square matrix (real or complex) can be
decomposed as
A = H + iS,
(1.49)
in which
H =
S =

1
(A + AH )
2
1
(A − AH ).
2i

(1.50)
(1.51)

Note that both H and S are Hermitian while the matrix iS in the decomposition
(1.49) is skew-Hermitian. The matrix H in the decomposition is called the Hermitian part of A, while the matrix iS is the skew-Hermitian part of A. The above

1.11. POSITIVE-DEFINITE MATRICES

33

decomposition is the analogue of the decomposition of a complex number z into
z = x + iy,
1
1
x = ℜe(z) = (z + z̄), y = ℑm(z) = (z − z̄).
2
2i
When A is real and u is a real vector then (Au, u) is real and, as a result, the
decomposition (1.49) immediately gives the equality
(Au, u) = (Hu, u).

(1.52)

This results in the following theorem.
Theorem 1.34 Let A be a real positive definite matrix. Then A is nonsingular. In
addition, there exists a scalar α > 0 such that
(Au, u) ≥ αkuk22 ,

(1.53)

for any real vector u.
Proof. The first statement is an immediate consequence of the definition of positive
definiteness. Indeed, if A were singular, then there would be a nonzero vector such
that Au = 0 and as a result (Au, u) = 0 for this vector, which would contradict
(1.48). We now prove the second part of the theorem. From (1.52) and the fact that
A is positive definite, we conclude that H is HPD. Hence, from (1.40) based on the
min-max theorem, we get
(Hu, u)
(Au, u)
= min
≥ λmin (H) > 0.
u6=0 (u, u)
u6=0 (u, u)

min

Taking α ≡ λmin (H) yields the desired inequality (1.53).
A simple yet important result which locates the eigenvalues of A in terms of the
spectra of H and S can now be proved.
Theorem 1.35 Let A be any square (possibly complex) matrix and let H = 12 (A +
1
AH ) and S = 2i
(A − AH ). Then any eigenvalue λj of A is such that
λmin (H)

≤ ℜe(λj ) ≤

λmax (H)

(1.54)

λmin (S) ≤ ℑm(λj ) ≤ λmax (S).

(1.55)

Proof. When the decomposition (1.49) is applied to the Rayleigh quotient of the
eigenvector uj associated with λj , we obtain
λj = (Auj , uj ) = (Huj , uj ) + i(Suj , uj ),
assuming that kuj k2 = 1. This leads to
ℜe(λj ) = (Huj , uj )

ℑm(λj ) = (Suj , uj ).
The result follows using properties established in Section 1.9.

(1.56)

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

34

Thus, the eigenvalues of a matrix are contained in a rectangle defined by the
eigenvalues of its Hermitian part and its non-Hermitian part. In the particular case
where A is real, then iS is skew-Hermitian and its eigenvalues form a set that is
symmetric with respect to the real axis in the complex plane. Indeed, in this case, iS
is real and its eigenvalues come in conjugate pairs.
Note that all the arguments herein are based on the field of values and, therefore,
they provide ways to localize the eigenvalues of A from knowledge of the field of
values. However, this approximation can be inaccurate in some cases.
Example 1.3. Consider the matrix
A=



1
104

1
1



.

The eigenvalues of A are −99 and 101. Those of H are 1 ± (104 + 1)/2 and those
of iS are ±i(104 − 1)/2.
When a matrix B is Symmetric Positive Definite, the mapping
x, y

→

(x, y)B ≡ (Bx, y)

(1.57)

from Cn ×Cn to C is a proper inner product on Cn , in the sense defined in Section 1.4.
The associated norm is often referred to as the energy norm or A-norm. Sometimes,
it is possible to find an appropriate HPD matrix B which makes a given matrix A
Hermitian, i.e., such that
(Ax, y)B = (x, Ay)B ,

∀ x, y

although A is a non-Hermitian matrix with respect to the Euclidean inner product.
The simplest examples are A = B −1 C and A = CB, where C is Hermitian and B
is Hermitian Positive Definite.

1.12

Projection Operators

Projection operators or projectors play an important role in numerical linear algebra,
particularly in iterative methods for solving various matrix problems. This section
introduces these operators from a purely algebraic point of view and gives a few of
their important properties.

1.12.1

Range and Null Space of a Projector

A projector P is any linear mapping from Cn to itself which is idempotent, i.e., such
that
P 2 = P.
A few simple properties follow from this definition. First, if P is a projector, then so
is (I − P ), and the following relation holds,
Null(P ) = Ran(I − P ).

(1.58)

1.12. PROJECTION OPERATORS

35

In addition, the two subspaces Null(P ) and Ran(P ) intersect only at the element
zero. Indeed, if a vector x belongs to Ran(P ), then P x = x, by the idempotence
property. If it is also in Null(P ), then P x = 0. Hence, x = P x = 0 which proves
the result. Moreover, every element of Cn can be written as x = P x + (I − P )x.
Therefore, the space Cn can be decomposed as the direct sum
Cn = Null(P ) ⊕ Ran(P ).
Conversely, every pair of subspaces M and S which forms a direct sum of Cn defines
a unique projector such that Ran(P ) = M and Null(P ) = S. This associated
projector P maps an element x of Cn into the component x1 , where x1 is the M component in the unique decomposition x = x1 + x2 associated with the direct sum.
In fact, this association is unique, that is, an arbitrary projector P can be entirely
determined by two subspaces: (1) The range M of P , and (2) its null space S which
is also the range of I − P . For any x, the vector P x satisfies the conditions,
Px ∈ M

x − P x ∈ S.
The linear mapping P is said to project x onto M and along or parallel to the subspace S. If P is of rank m, then the range of I − P is of dimension n − m. Therefore,
it is natural to define S through its orthogonal complement L = S ⊥ which has dimension m. The above conditions that define u = P x for any x become
u ∈ M

(1.59)

x − u ⊥ L.

(1.60)

These equations define a projector P onto M and orthogonal to the subspace L.
The first statement, (1.59), establishes the m degrees of freedom, while the second,
(1.60), gives the m constraints that define P x from these degrees of freedom. The
general definition of projectors is illustrated in Figure 1.1.
Px ∈ M
x − Px ⊥ L

x
L
M

Px

Figure 1.1 Projection of x onto M and orthogonal to L.

36

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

The question now is: Given two arbitrary subspaces, M and L both of dimension
m, is it always possible to define a projector onto M orthogonal to L through the
conditions (1.59) and (1.60)? The following lemma answers this question.
Lemma 1.36 Given two subspaces M and L of the same dimension m, the following
two conditions are mathematically equivalent.
i. No nonzero vector of M is orthogonal to L;
ii. For any x in Cn there is a unique vector u which satisfies the conditions
(1.59) and (1.60).
Proof. The first condition states that any vector which is in M and also orthogonal
to L must be the zero vector. It is equivalent to the condition
M ∩ L⊥ = {0}.
Since L is of dimension m, L⊥ is of dimension n − m and the above condition is
equivalent to the condition that
C n = M ⊕ L⊥ .

(1.61)

This in turn is equivalent to the statement that for any x, there exists a unique pair of
vectors u, w such that
x = u + w,
where u belongs to M , and w = x − u belongs to L⊥ , a statement which is identical
with ii.
In summary, given two subspaces M and L, satisfying the condition M ∩ L⊥ = {0},
there is a projector P onto M orthogonal to L, which defines the projected vector u
of any vector x from equations (1.59) and (1.60). This projector is such that
Null(P ) = L⊥ .

Ran(P ) = M,

In particular, the condition P x = 0 translates into x ∈ Null(P ) which means that
x ∈ L⊥ . The converse is also true. Hence, the following useful property,
Px = 0

1.12.2

iff

x ⊥ L.

(1.62)

Matrix Representations

Two bases are required to obtain a matrix representation of a general projector: a
basis V = [v1 , . . . , vm ] for the subspace M = Ran(P ) and a second one W =
[w1 , . . . , wm ] for the subspace L. These two bases are biorthogonal when
(vi , wj ) = δij .

(1.63)

1.12. PROJECTION OPERATORS

37

In matrix form this means W H V = I. Since P x belongs to M , let V y be its
representation in the V basis. The constraint x − P x ⊥ L is equivalent to the
condition,
((x − V y), wj ) = 0 for j = 1, . . . , m.
In matrix form, this can be rewritten as
W H (x − V y) = 0.

(1.64)

If the two bases are biorthogonal, then it follows that y = W H x. Therefore, in this
case, P x = V W H x, which yields the matrix representation of P ,
P = V W H.

(1.65)

In case the bases V and W are not biorthogonal, then it is easily seen from the
condition (1.64) that
P = V (W H V )−1 W H .
(1.66)
If we assume that no vector of M is orthogonal to L, then it can be shown that the
m × m matrix W H V is nonsingular.

1.12.3

Orthogonal and Oblique Projectors

An important class of projectors is obtained in the case when the subspace L is equal
to M , i.e., when
Null(P ) = Ran(P )⊥ .
Then, the projector P is said to be the orthogonal projector onto M . A projector that
is not orthogonal is oblique. Thus, an orthogonal projector is defined through the
following requirements satisfied for any vector x,
Px ∈ M

and

(I − P ) x ⊥ M

(1.67)

or equivalently,
Px ∈ M

and

((I − P )x, y) = 0 ∀ y ∈ M.
x

Px ∈ M
x − Px ⊥ M

M
❄

Px

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

38

Figure 1.2 Orthogonal projection of x onto a subspace
M.
It is interesting to consider the mapping P H defined as the adjoint of P
(P H x, y) = (x, P y),

∀ x, ∀ y.

(1.68)

First note that P H is also a projector because for all x and y,
((P H )2 x, y) = (P H x, P y) = (x, P 2 y) = (x, P y) = (P H x, y).
A consequence of the relation (1.68) is
Null(P H ) = Ran(P )⊥

(1.69)

H ⊥

(1.70)

Null(P ) = Ran(P ) .
The above relations lead to the following proposition.
Proposition 1.37 A projector is orthogonal if and only if it is Hermitian.

Proof. By definition, an orthogonal projector is one for which Null(P ) = Ran(P )⊥ .
Therefore, by (1.69), if P is Hermitian, then it is orthogonal. Conversely, if P is orthogonal, then (1.69) implies Null(P ) = Null(P H ) while (1.70) implies Ran(P ) =
Ran(P H ). Since P H is a projector and since projectors are uniquely determined by
their range and null spaces, this implies that P = P H .
Given any unitary n × m matrix V whose columns form an orthonormal basis of
M = Ran(P ), we can represent P by the matrix P = V V H . This is a particular case
of the matrix representation of projectors (1.65). In addition to being idempotent, the
linear mapping associated with this matrix satisfies the characterization given above,
i.e.,
V V H x ∈ M and (I − V V H )x ∈ M ⊥ .
It is important to note that this representation of the orthogonal projector P is not
unique. In fact, any orthonormal basis V will give a different representation of P in
the above form. As a consequence for any two orthogonal bases V1 , V2 of M , we
must have V1 V1H = V2 V2H , an equality which can also be verified independently;
see Exercise 30.

1.12.4

Properties of Orthogonal Projectors

When P is an orthogonal projector, then the two vectors P x and (I − P )x in the
decomposition x = P x + (I − P )x are orthogonal. The following relation results:
kxk22 = kP xk22 + k(I − P )xk22 .
A consequence of this is that for any x,
kP xk2 ≤ kxk2 .

1.13. BASIC CONCEPTS IN LINEAR SYSTEMS

39

Thus, the maximum of kP xk2 /kxk2 , for all x in Cn does not exceed one. In addition
the value one is reached for any element in Ran(P ). Therefore,
kP k2 = 1
for any orthogonal projector P .
An orthogonal projector has only two eigenvalues: zero or one. Any vector of
the range of P is an eigenvector associated with the eigenvalue one. Any vector of
the null-space is obviously an eigenvector associated with the eigenvalue zero.
Next, an important optimality property of orthogonal projectors is established.
Theorem 1.38 Let P be the orthogonal projector onto a subspace M . Then for any
given vector x in Cn, the following is true:
min kx − yk2 = kx − P xk2 .

y∈M

(1.71)

Proof. Let y be any vector of M and consider the square of its distance from x. Since
x − P x is orthogonal to M to which P x − y belongs, then
kx − yk22 = kx − P x + (P x − y)k22 = kx − P xk22 + k(P x − y)k22 .
Therefore, kx − yk2 ≥ kx − P xk2 for all y in M . This establishes the result by
noticing that the minimum is reached for y = P x.
By expressing the conditions that define y ∗ ≡ P x for an orthogonal projector P
onto a subspace M , it is possible to reformulate the above result in the form of necessary and sufficient conditions which enable us to determine the best approximation
to a given vector x in the least-squares sense.
Corollary 1.39 Let a subspace M , and a vector x in Cn be given. Then
min kx − yk2 = kx − y ∗ k2 ,

y∈M

(1.72)

if and only if the following two conditions are satisfied,
 ∗
y
∈ M
x − y ∗ ⊥ M.

1.13

Basic Concepts in Linear Systems

Linear systems are among the most important and common problems encountered in
scientific computing. From the theoretical point of view, it is well understood when
a solution exists, when it does not, and when there are infinitely many solutions. In
addition, explicit expressions of the solution using determinants exist. However, the
numerical viewpoint is far more complex. Approximations may be available but it
may be difficult to estimate how accurate they are. This clearly will depend on the
data at hand, i.e., primarily on the coefficient matrix. This section gives a very brief
overview of the existence theory as well as the sensitivity of the solutions.

40

1.13.1

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

Existence of a Solution

Consider the linear system
Ax = b.

(1.73)

Here, x is termed the unknown and b the right-hand side. When solving the linear
system (1.73), we distinguish three situations.
Case 1 The matrix A is nonsingular. There is a unique solution given by x = A−1 b.
Case 2 The matrix A is singular and b ∈ Ran(A). Since b ∈ Ran(A), there is an
x0 such that Ax0 = b. Then x0 + v is also a solution for any v in Null(A). Since
Null(A) is at least one-dimensional, there are infinitely many solutions.
Case 3 The matrix A is singular and b ∈
/ Ran(A). There are no solutions.
Example 1.4. The simplest illustration of the above three cases is with small diagonal matrices. Let


 
2 0
1
A=
b=
.
0 4
8
Then A is nonsingular and there is a unique x given by


0.5
.
x=
2

Now let
A=



2
0

0
0



,

 
1
b=
.
0

Then A is singular and, as is easily seen, b ∈ Ran(A). For example, a particular
of all
element x0 such that Ax0 = b is x0 = 0.5
0 . The null space of A consists
0
vectors whose first component is zero, i.e., all vectors of the form α . Therefore,
there are infinitely many solution which are given by


0.5
x(α) =
∀ α.
α
Finally, let A be the same as in the previous case, but define the right-hand side as
 
1
b=
.
1
In this case there are no solutions because the second equation cannot be satisfied.

1.13. BASIC CONCEPTS IN LINEAR SYSTEMS

1.13.2

41

Perturbation Analysis

Consider the linear system (1.73) where A is an n × n nonsingular matrix. Given
any matrix E, the matrix A(ǫ) = A + ǫE is nonsingular for ǫ small enough, i.e., for
ǫ ≤ α where α is some small number; see Exercise 37. Assume that we perturb the
data in the above system, i.e., that we perturb the matrix A by ǫE and the right-hand
side b by ǫe. The solution x(ǫ) of the perturbed system satisfies the equation,
(A + ǫE)x(ǫ) = b + ǫe.

(1.74)

Let δ(ǫ) = x(ǫ) − x. Then,
(A + ǫE)δ(ǫ) = (b + ǫe) − (A + ǫE)x
= ǫ (e − Ex)

δ(ǫ) = ǫ (A + ǫE)−1 (e − Ex).
As an immediate result, the function x(ǫ) is differentiable at ǫ = 0 and its derivative
is given by
δ(ǫ)
= A−1 (e − Ex) .
(1.75)
x′ (0) = lim
ǫ→0 ǫ
The size of the derivative of x(ǫ) is an indication of the size of the variation that
the solution x(ǫ) undergoes when the data, i.e., the pair [A, b] is perturbed in the
direction [E, e]. In absolute terms, a small variation [ǫE, ǫe] will cause the solution
to vary by roughly ǫx′ (0) = ǫA−1 (e − Ex). The relative variation is such that


kek
kx(ǫ) − xk
−1
≤ ǫkA k
+ kEk + o(ǫ).
kxk
kxk
Using the fact that kbk ≤ kAkkxk in the above equation yields


kx(ǫ) − xk
kek kEk
−1
≤ ǫkAkkA k
+
+ o(ǫ)
kxk
kbk kAk

(1.76)

which relates the relative variation in the solution to the relative sizes of the perturbations. The quantity
κ(A) = kAk kA−1 k
is called the condition number of the linear system (1.73) with respect to the norm
k.k. The condition number is relative to a norm. When using the standard norms k.kp ,
p = 1, . . . , ∞, it is customary to label κ(A) with the same label as the associated
norm. Thus,
κp (A) = kAkp kA−1 kp .
For large matrices, the determinant of a matrix is almost never a good indication
of “near” singularity or degree of sensitivity of the linear system. The reason is that
det(A) is the product of the eigenvalues which depends very much on a scaling of a
matrix, whereas the condition number of a matrix is scaling-invariant. For example,

42

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

for A = αI the determinant is det(A) = αn , which can be very small if |α| < 1,
whereas κ(A) = 1 for any of the standard norms.
In addition, small eigenvalues do not always give a good indication of poor conditioning. Indeed, a matrix can have all its eigenvalues equal to one yet be poorly
conditioned.
Example 1.5. The simplest example is provided by matrices of the form
An = I + αe1 eTn
for large α. The inverse of An is
T
A−1
n = I − αe1 en

and for the ∞-norm we have
kAn k∞ = kA−1
n k∞ = 1 + |α|
so that
κ∞ (An ) = (1 + |α|)2 .
For a large α, this can give a very large condition number, whereas all the eigenvalues
of An are equal to unity.
When an iterative procedure is used for solving a linear system, we typically
face the problem of choosing a good stopping procedure for the algorithm. Often a
residual norm,
krk = kb − Ax̃k
is available for some current approximation x̃ and an estimate of the absolute error
kx − x̃k or the relative error kx − x̃k/kxk is desired. The following simple relation
is helpful in this regard,
kx − x̃k
krk
≤ κ(A)
.
kxk
kbk

It is necessary to have an estimate of the condition number κ(A) in order to exploit
the above relation.

P ROBLEMS
P-1.1 Verify that the Euclidean inner product defined by (1.4) does indeed satisfy the general definition of inner products on vector spaces.
P-1.2 Show that two eigenvectors associated with two distinct eigenvalues are linearly independent. In a more general sense, show that a family of eigenvectors associated with distinct
eigenvalues forms a linearly independent family.

1.13. BASIC CONCEPTS IN LINEAR SYSTEMS

43

P-1.3 Show that if λ is any nonzero eigenvalue of the matrix AB, then it is also an eigenvalue of the matrix BA. Start with the particular case where A and B are square and B
is nonsingular, then consider the more general case where A, B may be singular or even
rectangular (but such that AB and BA are square).
P-1.4 Let A be an n×n orthogonal matrix, i.e., such that AH A = D, where D is a diagonal
matrix. Assuming that D is nonsingular, what is the inverse of A? Assuming that D > 0,
how can A be transformed into a unitary matrix (by operations on its rows or columns)?
P-1.5 Show that the Frobenius norm is consistent. Can this norm be associated to two vector
norms via (1.7)? What is the Frobenius norm of a diagonal matrix? What is the p-norm of a
diagonal matrix (for any p)?
P-1.6 Find the Jordan canonical form of the matrix:


1 2 −4
A = 0 1 2 .
0 0 2

Same question for the matrix obtained by replacing the element a33 by 1.
P-1.7 Give an alternative proof of Theorem 1.9 on the Schur form by starting from the
Jordan canonical form. [Hint: Write A = XJX −1 and use the QR decomposition of X.]
P-1.8 Show from the definition of determinants used in Section 1.2 that the characteristic
polynomial is a polynomial of degree n for an n × n matrix.
P-1.9 Show that the characteristic polynomials of two similar matrices are equal.
P-1.10 Show that
lim kAk k1/k = ρ(A),

k→∞

for any matrix norm. [Hint: Use the Jordan canonical form.]
P-1.11 Let X be a nonsingular matrix and, for any matrix norm k.k, define kAkX = kAXk.
Show that this is indeed a matrix norm. Is this matrix norm consistent? Show the same for
kXAk and kY AXk where Y is also a nonsingular matrix. These norms are not, in general,
associated with any vector norms, i.e., they can’t be defined by a formula of the form (1.7).
Why? What can you say about the particular case when Y = X −1 ? Is kX −1AXk induced
by a vector norm in this particular case?
P-1.12 Find the field of values of the matrix

0
A=
0

1
0



and verify that it is not equal to the convex hull of its eigenvalues.
P-1.13 Show that for a skew-Hermitian matrix S,
ℜe(Sx, x) = 0

for any x ∈ Cn .

P-1.14 Given an arbitrary matrix S, show that if (Sx, x) = 0 for all x in Cn , then it is true
that
(Sy, z) + (Sz, y) = 0 ∀ y, z ∈ Cn .
(1.77)
[Hint: Expand (S(y + z), y + z).]

44

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

P-1.15 Using the results of the previous two problems, show that if (Ax, x) is real for all
x in Cn , then A must be Hermitian. Would this result be true if the assumption were to be
replaced by: (Ax, x) is real for all real x? Explain.
P-1.16 Show that if (Sx, x) = 0 for all complex vectors x, then S is zero. [Hint: Start by
doing Problem 14. Then selecting y = ek , z = eθ ej in (1.77), for an arbitrary θ, establish
that skj e2θ = −sjk and conclude that sjk = sjk = 0]. Is the result true if (Sx, x) = 0 for
all real vectors x?
P-1.17 The definition of a positive definite matrix is that (Ax, x) be real and positive for all
real vectors x. Show that this is equivalent to requiring that the Hermitian part of A, namely,
1
H
2 (A + A ), be (Hermitian) positive definite.
P-1.18 Let A1 = B −1 C and A2 = CB where C is a Hermitian matrix and B is a Hermitian
Positive Definite matrix. Are A1 and A2 Hermitian in general? Show that A1 and A2 are
Hermitian (self-adjoint) with respect to the B-inner product.
P-1.19 Let a matrix A be such that AH = p(A) where p is a polynomial. Show that A is
normal. Given a diagonal complex matrix D, show that there exists a polynomial of degree
< n such that D̄ = p(D). Use this to show that a normal matrix satisfies AH = p(A) for
a certain polynomial of p of degree < n. As an application, use this result to provide an
alternative proof of Lemma 1.13.
P-1.20 Show that A is normal iff its Hermitian and skew-Hermitian parts, as defined in
Section 1.11, commute.
P-1.21 The goal of this exercise is to establish the relation (1.35). Consider the numerical
radius ν(A) of an arbitrary matrix A. Show that ν(A) ≤ kAk2 . Show that for a normal
matrix ν(A) = kAk2 . Consider the decomposition of a matrix into its Hermtian and skewHermitian parts as shown in (1.49), (1.50), and (1.51). Show that kAk2 ≤ ν(H)+ν(S). Now,
using this inequality and the definition of the numerical radius show that kAk2 ≤ 2ν(A).
P-1.22 Show that the numerical radius is a vector norm in the sense that it satisfies the three
properties (1.8–1.10) of norms. [Hint: For (1.8) solve exercise 16 first]. Find a counterexample to show that the numerical radius is not a (consistent) matrix norm, i.e., that ν(AB)
can be larger than ν(A) ν(B).
P-1.23 Let A be a Hermitian matrix and B a Hermitian Positive Definite matrix defining a
B-inner product. Show that A is Hermitian (self-adjoint) with respect to the B-inner product
if and only if A and B commute. What condition must satisfy B for the same condition to
hold in the more general case where A is not Hermitian?
P-1.24 Let A be a real symmetric matrix and λ an eigenvalue of A. Show that if u is an
eigenvector associated with λ, then so is ū. As a result, prove that for any eigenvalue of a
real symmetric matrix, there is an associated eigenvector which is real.
P-1.25 Show that a Hessenberg matrix H such that hj+1,j 6= 0, j = 1, 2, . . . , n − 1, cannot
be derogatory.
P-1.26 Prove all the properties listed in Proposition 1.24.
P-1.27 Let A be an M -matrix and u, v two nonnegative vectors such that v T A−1 u < 1.
Show that A − uv T is an M -matrix.

P-1.28 Show that if O ≤ A ≤ B then O ≤ AT A ≤ B T B. Conclude that under the same
assumption, we have kAk2 ≤ kBk2 .

1.13. BASIC CONCEPTS IN LINEAR SYSTEMS

45

P-1.29 Consider the subspace M of R4 spanned by the vectors
 


1
1
0
 −1 
v1 =   ; v2 = 

1
0
1
−1

a. Write down the matrix representing the orthogonal projector onto M .

b. What is the null space of P ?
c. What is its range?
d. Find the vector x in S which is the closest in the 2-norm sense to the vector c =
[1, 1, 1, 1]T
P-1.30 Show that for two orthonormal bases V1 , V2 of the same subspace M of Cn we have
V1 V1H x = V2 V2H x, ∀ x.
P-1.31 What are the eigenvalues of a projector? What about its eigenvectors?
P-1.32 Show that if two projectors P1 and P2 commute, then their product P = P1 P2 is a
projector. What are the range and kernel of P ?
P-1.33 Theorem 1.32 shows that the condition (2) in Definition 1.30 is not needed, i.e., it
is implied by (4) (and the other conditions). One is tempted to say that only one of (2) or (4)
is required. Is this true? In other words, does (2) also imply (4)? [Prove or show a counter
example]
P-1.34 Consider the matrix A of size n × n and the vector x ∈ Rn ,

 1 −1 −1 −1 . . . −1 
1
 1/2
 0 1 −1 −1 . . . −1 



1 −1 . . . −1 
 1/4
0 0


.
..
..
..
.
x
=
A=
.
.

 1/8
.
.
. 
.
.

.
..
.
.
.
.
.


.
..
.
.
..
..
..
..
0

0

0

...

0

1

1/2n−1






.




a. Compute Ax, kAxk2 , and kxk2 .
√
b. Show that kAk2 ≥ n.
c. Give a lower bound for κ2 (A).

P-1.35 What is the inverse of the matrix A of the previous exercise? Give an expression of
κ1 (A) and κ∞ (A) based on this.
P-1.36 Find a small rank-one perturbation which makes the matrix A in Exercise 34 singular. Derive a lower bound for the singular values of A.
P-1.37 Consider a nonsingular matrix A. Given any matrix E, show that there exists α such
that the matrix A(ǫ) = A+ǫE is nonsingular for all ǫ < α. What is the largest possible value
for α satisfying the condition? [Hint: Consider the eigenvalues of the generalized eigenvalue
problem Au = λEu.]
N OTES AND R EFERENCES . For additional reading on the material presented in this chapter, see Golub
and Van Loan [149], Meyer [210], Demmel [99], Datta [93], Stewart [273], and Varga [293]. Volume
2 (“Eigensystems”) of the series [274], offers an up-to-date coverage of algorithms for eigenvalue

46

CHAPTER 1. BACKGROUND IN LINEAR ALGEBRA

problems. The excellent treatise of nonnegative matrices in the book by Varga [293] remains a good
reference on this topic and on iterative methods four decades after its first publication. State-of-the-art
coverage on iterative methods up to the very beginning of the 1970s can be found in the book by Young
[322] which covers M -matrices and related topics in great detail. For a good overview of the linear
algebra aspects of matrix theory and a complete proof of Jordan’s canonical form, Halmos [164] is
recommended.

Chapter 2

DISCRETIZATION OF PDES

Partial Differential Equations (PDEs) constitute by far the biggest source of sparse matrix
problems. The typical way to solve such equations is to discretize them, i.e., to approximate
them by equations that involve a finite number of unknowns. The matrix problems that arise
from these discretizations are generally large and sparse, i.e., they have very few nonzero entries.
There are several different ways to discretize a Partial Differential Equation. The simplest method
uses finite difference approximations for the partial differential operators. The Finite Element
Method replaces the original function by a function which has some degree of smoothness over
the global domain, but which is piecewise polynomial on simple cells, such as small triangles
or rectangles. This method is probably the most general and well understood discretization
technique available. In between these two methods, there are a few conservative schemes called
Finite Volume Methods, which attempt to emulate continuous conservation laws of physics. This
chapter introduces these three different discretization methods.

2.1

Partial Differential Equations

Physical phenomena are often modeled by equations that relate several partial derivatives of physical quantities, such as forces, momentums, velocities, energy, temperature, etc. These equations rarely have a closed-form (explicit) solution. In this chapter, a few types of Partial Differential Equations are introduced, which will serve as
models throughout the book. Only one- or two-dimensional problems are considered,
and the space variables are denoted by x in the case of one-dimensional problems or
x1 and x2 for two-dimensional problems. In two dimensions, x denotes the “vector”
of components (x1 , x2 ).

2.1.1

Elliptic Operators

One of the most common Partial Differential Equations encountered in various areas
of engineering is Poisson’s equation:
 
∂2u ∂2u
x1
in Ω
(2.1)
+ 2 = f, for x =
2
x2
∂x1 ∂x2
where Ω is a bounded, open domain in R2 . Here, x1 , x2 are the two space variables.
47

CHAPTER 2. DISCRETIZATION OF PDES

48

Γ
~n
x2

Ω

x1
Figure 2.1: Domain Ω for Poisson’s equation.
The above equation is to be satisfied only for points that are located at the interior
of the domain Ω. Equally important are the conditions that must be satisfied on the
boundary Γ of Ω. These are termed boundary conditions, and they come in three
common types:
Dirichlet condition
Neumann condition
Cauchy condition

u(x) = φ(x)
= 0
∂u
∂~
n (x) + α(x)u(x) = γ(x)
∂u
∂~
n (x)

The vector ~n usually refers to a unit vector that is normal to Γ and directed
outwards. Note that the Neumann boundary conditions are a particular case of the
Cauchy conditions with γ = α = 0. For a given unit vector, ~v with components v1
and v2 , the directional derivative ∂u/∂~v is defined by
u(x + h~v ) − u(x)
h→0
h
∂u
∂u
=
(x)v1 +
(x)v2
∂x1
∂x2
= ∇u.~v

(2.2)

!

(2.4)

∂u
(x) =
∂~v

lim

where ∇u is the gradient of u,
∇u =

∂u
∂x1
∂u
∂x2

,

(2.3)

and the dot in (2.3) indicates a dot product of two vectors in R2 .
In reality, Poisson’s equation is often a limit case of a time-dependent problem.
Its solution can, for example, represent the steady-state temperature distribution in
a region Ω when there is a heat source f that is constant with respect to time. The
boundary conditions should then model heat loss across the boundary Γ.
The particular case where f (x) = 0, i.e., the equation
∆u = 0,

2.1. PARTIAL DIFFERENTIAL EQUATIONS

49

to which boundary conditions must be added, is called the Laplace equation and its
solutions are called harmonic functions.
Many problems in physics have boundary conditions of mixed type, e.g., of
Dirichlet type in one part of the boundary and of Cauchy type in another. Another observation is that the Neumann conditions do not define the solution uniquely. Indeed,
if u is a solution, then so is u + c for any constant c.
The operator
∂2
∂2
+
∆=
∂x21 ∂x22
is called the Laplacean operator and appears in many models of physical and mechanical phenomena. These models often lead to more general elliptic operators of
the form




∂
∂
∂
∂
a
+
a
L =
∂x1
∂x1
∂x2
∂x2
= ∇. (a∇)
(2.5)
where the scalar function a depends on the coordinate and may represent some specific parameter of the medium, such as density, porosity, etc. At this point it may
be useful to recall some notation which is widely used in physics and mechanics.
The ∇ operator can be considered as a vector consisting of the components ∂x∂ 1 and
∂
∂x2 . When applied to a scalar function u, this operator is nothing but the gradient
∂u
∂u
operator, since it yields a vector with the components ∂x
and ∂x
as is shown in
1
2
2
(2.4). The dot notation allows dot products of vectors in R to be defined. These
vectors can include
 partial differential operators. For example, the dot product ∇.u
of ∇ with u = uu12 yields the scalar quantity,
∂u1 ∂u2
+
,
∂x1 ∂x2

 
which is called the divergence of the vector function ~u = uu12 . Applying this
divergence operator to u = a∇, where a is a scalar function, yields the L operator
in (2.5). The divergence of the vector function ~v is often denoted by div ~v or ∇.~v .
Thus,
∂v1
∂v2
div ~v = ∇.~v =
+
.
∂x1 ∂x2
The closely related operator




∂
∂
∂
∂
a1
+
a2
L =
∂x1
∂x1
∂x2
∂x2
= ∇ (~a. ∇)
(2.6)
is a further generalization of the Laplacean operator ∆ in the case where the medium
is anisotropic and inhomogeneous. The coefficients a1 , a2 depend on the space variable x and reflect the position as well as the directional dependence of the material
properties, such as porosity in the case of fluid flow or dielectric constants in electrostatics. In fact, the above operator can be viewed as a particular case of L = ∇.(A∇),
where A is a 2 × 2 matrix which acts on the two components of ∇.

CHAPTER 2. DISCRETIZATION OF PDES

50

2.1.2

The Convection Diffusion Equation

Many physical problems involve a combination of “diffusion” and “convection” phenomena. Such phenomena are modeled by the convection-diffusion equation
∂u
∂u
∂u
+ b1
+ b2
= ∇.(a∇)u + f
∂t
∂x1
∂x2
or

∂u ~
+ b.∇u = ∇.(a∇)u + f
∂t
the steady-state version of which can be written as
−∇.(a∇)u + ~b.∇u = f.

(2.7)

Problems of this type are often used as model problems because they represent the
simplest form of conservation of mass in fluid mechanics. Note that the vector ~b is
sometimes quite large, which may cause some difficulties either to the discretization
schemes or to the iterative solution techniques.

2.2

Finite Difference Methods

The finite difference method is based on local approximations of the partial derivatives in a Partial Differential Equation, which are derived by low order Taylor series
expansions. The method is quite simple to define and rather easy to implement.
Also, it is particularly appealing for simple regions, such as rectangles, and when
uniform meshes are used. The matrices that result from these discretizations are
often well structured, which means that they typically consist of a few nonzero diagonals. Another advantage is that there are a number of “fast Poisson solvers” for
constant coefficient problems, which can deliver the solution in logarithmic time per
grid point. This means the total number of operations is of the order of n log(n)
where n is the total number of discretization points. This section gives an overview
of finite difference discretization techniques.

2.2.1

Basic Approximations

The simplest way to approximate the first derivative of a function u at the point x is
via the formula
 
u(x + h) − u(x)
du
.
(2.8)
(x) ≈
dx
h

When u is differentiable at x, then the limit of the above ratio when h tends to zero is
the derivative of u at x. For a function that is C 4 in the neighborhood of x, we have
by Taylor’s formula
u(x + h) = u(x) + h

du h2 d2 u h3 d3 u h4 d4 u
+
+
+
(ξ+ ),
dx
2 dx2
6 dx3 24 dx4

(2.9)

2.2. FINITE DIFFERENCE METHODS

51

for some ξ+ in the interval (x, x + h). Therefore, the above approximation (2.8)
satisfies
u(x + h) − u(x) h d2 u(x)
du
=
−
+ O(h2 ).
(2.10)
dx
h
2 dx2
The formula (2.9) can be rewritten with h replaced by −h to obtain
u(x − h) = u(x) − h

du h2 d2 u h3 d3 u h4 d4 u(ξ− )
+
−
+
,
dx
2 dx2
6 dx3 24 dx4

(2.11)

in which ξ− belongs to the interval (x − h, x). Adding (2.9) and (2.11), dividing
through by h2 , and using the mean value theorem for the fourth order derivatives
results in the following approximation of the second derivative
d2 u(x)
u(x + h) − 2u(x) + u(x − h) h2 d4 u(ξ)
=
−
,
dx2
h2
12 dx4

(2.12)

where ξ− ≤ ξ ≤ ξ+ . The above formula is called a centered difference approximation of the second derivative since the point at which the derivative is being approximated is the center of the points used for the approximation. The dependence of
this derivative on the values of u at the points involved in the approximation is often
represented by a “stencil” or “molecule,” shown in Figure 2.2.

1

−2

1

Figure 2.2: The three-point stencil for the centered difference approximation to the
second order derivative.
The approximation (2.8) for the first derivative is forward rather than centered.
Also, a backward formula can be used which consists of replacing h with −h in (2.8).
The two formulas can also be averaged to obtain the centered difference formula:
du(x)
u(x + h) − u(x − h)
≈
.
dx
2h

(2.13)

It is easy to show that the above centered difference formula is of the second
order, while (2.8) is only first order accurate. Denoted by δ+ and δ− , the forward
and backward difference operators are defined by
δ+ u(x) = u(x + h) − u(x)
−

δ u(x) = u(x) − u(x − h).

(2.14)
(2.15)

All previous approximations can be rewritten using these operators.
In addition to standard first order and second order derivatives, it is sometimes
necessary to approximate the second order operator


d
d
a(x)
.
dx
dx

CHAPTER 2. DISCRETIZATION OF PDES

52

A centered difference formula for this, which has second order accuracy, is given by



d
du
1 +
δ ai−1/2 δ− u + O(h2 )
(2.16)
a(x)
=
2
dx
dx
h
ai+1/2 (ui+1 − ui ) − ai−1/2 (ui − ui−1 )
.
≈
h2

2.2.2

Difference Schemes for the Laplacean Operator
2

2

∂
∂
If the approximation (2.12) is used for both the ∂x
2 and ∂x2 terms in the Laplacean
1
2
operator, using a mesh size of h1 for the x1 variable and h2 for the x2 variable, the
following second order accurate approximation results:

∆u(x) ≈

u(x1 + h1 , x2 ) − 2u(x1 , x2 ) + u(x − h1 , x2 )
+
h21
u(x1 , x2 + h2 ) − 2u(x1 , x2 ) + u(x1 , x2 − h2 )
.
h22

In the particular case where the mesh sizes h1 and h2 are the same and equal to a
mesh size h, the approximation becomes
∆u(x) ≈

1
[u(x1 + h, x2 ) + u(x1 − h, x2 ) + u(x1 , x2 + h)
h2
+ u(x1 , x2 − h) − 4u(x1 , x2 )] ,

(2.17)

which is called the five-point centered approximation to the Laplacean. The stencil
of this finite difference approximation is illustrated in (a) of Figure 2.3.
(b)

(a)
1

1

-4

1

1

1

1

-4

1

1

Figure 2.3: Five-point stencils for the centered difference approximation to the
Laplacean operator: (a) the standard stencil, (b) the skewed stencil.
Another approximation may be obtained by exploiting the four points u(x1 ±
h, x2 ± h) located on the two diagonal lines from u(x1 , x2 ). These points can be

2.2. FINITE DIFFERENCE METHODS

53

used in the same manner as in the previous approximation except that the mesh size
has changed. The corresponding stencil is illustrated in (b) of Figure 2.3.
The approximation (2.17) is second order accurate and the error takes the form


∂4u
h2 ∂ 4 u
+
+ O(h3 ).
12 ∂ 4 x1 ∂ 4 x2
There are other schemes that utilize nine-point formulas as opposed to five-point formulas. Two such schemes obtained by combining the standard and skewed stencils
described above are shown in Figure 2.4. Both approximations (c) and (d) are second order accurate. However, (d) is sixth order for harmonic functions, i.e., functions
whose Laplacean is zero.
(d)

(c)
1

1

1

1

4

1

1

-8

1

4

-20

4

1

1

1

1

4

1

Figure 2.4: Two nine-point centered difference stencils for the Laplacean operator.

2.2.3

Finite Differences for 1-D Problems

Consider the one-dimensional equation,
−u′′ (x) = f (x) for x ∈ (0, 1)

u(0) = u(1) = 0.

(2.18)
(2.19)

The interval [0,1] can be discretized uniformly by taking the n + 2 points
xi = i × h, i = 0, . . . , n + 1
where h = 1/(n + 1). Because of the Dirichlet boundary conditions, the values
u(x0 ) and u(xn+1 ) are known. At every other point, an approximation ui is sought
for the exact solution u(xi ).
If the centered difference approximation (2.12) is used, then by the equation
(2.18) expressed at the point xi , the unknowns ui , ui−1 , ui+1 satisfy the relation
−ui−1 + 2ui − ui+1 = h2 fi ,

CHAPTER 2. DISCRETIZATION OF PDES

54

in which fi ≡ f (xi ). Notice that for i = 1 and i = n, the equation will involve
u0 and un+1 which are known quantities, both equal to zero in this case. Thus, for
n = 6, the linear system obtained is of the form
Ax = f
where

2.2.4




2 −1
 −1 2 −1




1 
−1 2 −1

.
A= 2 

−1 2 −1
h 


−1 2 −1 
−1 2

Upwind Schemes

Consider now the one-dimensional version of the convection-diffusion equation (2.7)
in which the coefficients a and b are constant, and f = 0, using Dirichlet boundary
conditions,

−a u′′ + b u′
= 0, 0 < x < L = 1
(2.20)
u(0) = 0, u(L) = 1.

In this particular case, it is easy to verify that the exact solution to the above equation
is given by
1 − eRx
u(x) =
1 − eR
where R is the so-called Péclet number defined by R = bL/a. Now consider the
approximate solution provided by using the centered difference schemes seen above,
for both the first- and second order derivatives. The equation for unknown number i
becomes
ui+1 − 2ui + ui−1
ui+1 − ui−1
−a
= 0,
b
2h
h2
or, defining c = Rh/2,
−(1 − c)ui+1 + 2ui − (1 + c)ui−1 = 0.

(2.21)

This is a second order homogeneous linear difference equation and the usual way to
solve it is to seek a general solution in the form uj = r j . Substituting in (2.21), r
must satisfy
(1 − c)r 2 − 2r + (c + 1) = 0.
Therefore, r1 = 1 is a root and the second root is r2 = (1 + c)/(1 − c). The general
solution of the above difference equation is now sought as a linear combination of
the two solutions corresponding to these two roots,


1+c i
i
i
.
ui = αr1 + βr2 = α + β
1−c

2.2. FINITE DIFFERENCE METHODS

55

Because of the boundary condition u0 = 0, it is necessary that β = −α. Likewise,
the boundary condition un+1 = 1 yields
α=
Thus, the solution is

1
1 − σ n+1

with σ ≡

1+c
.
1−c

1 − σi
.
1 − σ n+1
When h > 2/R the factor σ becomes negative and the above approximations will
oscillate around zero. In contrast, the exact solution is positive and monotone in
the range [0, 1]. In this situation the solution is very inaccurate regardless of the
arithmetic. In other words, the scheme itself creates the oscillations. To avoid this, a
small enough mesh h can be taken to ensure that c < 1. The resulting approximation
is in much better agreement with the exact solution. Unfortunately, this condition
can limit the mesh size too drastically for large values of b.
Note that when b < 0, the oscillations disappear since σ < 1. In fact, a linear
algebra interpretation of the oscillations comes from comparing the tridiagonal matrices obtained from the discretization. Again, for the case n = 6, the tridiagonal
matrix resulting from discretizing the equation (2.7) takes the form


2
−1 + c
 −1 − c

2
−1 + c




1 
−1 − c
2
−1 + c
.
A= 2

−1 − c
2
−1 + c
h 


−1 − c
2
−1 + c 
ui =

−1 − c

2

The above matrix is no longer a diagonally dominant M-matrix. Observe that if the
backward difference formula for the first order derivative is used, we obtain
b

ui−1 − 2ui + ui+1
ui − ui−1
−a
= 0.
h
h2

Then (weak) diagonal dominance is preserved if b > 0. This is because the new
matrix obtained for the above backward scheme is


2+c
−1
 −1 − c 2 + c

−1



1 
−1 − c 2 + c
−1


A= 2

−1 − c 2 + c
−1
h 


−1 − c 2 + c
−1 
−1 − c 2 + c

where c is now defined by c = Rh. Each diagonal term aii gets reinforced by the
positive term c while each subdiagonal term ai,i−1 increases by the same amount in
absolute value. In the case where b < 0, the forward difference formula
b

ui−1 − 2ui + ui+1
ui+1 − ui
−a
=0
h
h2

CHAPTER 2. DISCRETIZATION OF PDES

56

can be used to achieve the same effect. Generally speaking, if b depends on the
space variable x, the effect of weak-diagonal dominance can be achieved by simply
adopting the following discretization known as an “upwind scheme”:
b

ui−1 − 2ui + ui+1
δi∗ ui
−a
=0
h
h2

where
δi∗ =



δi−
δi+

if b > 0
if b < 0.

The above difference scheme can be rewritten by introducing the sign function sign (b) =
|b|/b. The approximation to u′ at xi is then defined by
1
δ+ ui 1
δ− ui
u′ (xi ) ≈ (1 − sign(b))
+ (1 + sign(b))
.
2
h
2
h
Making use of the notation
1
(x)+ = (x + |x|),
2

1
(x)− = (x − |x|),
2

(2.22)

a slightly more elegant formula can be obtained by expressing the approximation of
the product b(xi )u′ (xi ),
b(xi )u′ (xi ) ≈
≈

1
δ + ui 1
δ − ui
(bi − |bi |)
+ (bi + |bi |)
2
h
2
h

1 +
−
−bi ui−1 + |bi |ui + bi ui+1 ,
h

(2.23)

where bi stands for b(xi ). The diagonal term in the resulting tridiagonal matrix is
nonnegative, the offdiagonal terms are nonpositive, and the diagonal term is the negative sum of the offdiagonal terms. This property characterizes upwind schemes.
A notable disadvantage of upwind schemes is the low order of approximation
which they yield. An advantage is that upwind schemes yield linear systems that are
easier to solve by iterative methods.

2.2.5

Finite Differences for 2-D Problems

Similar to the previous case, consider this simple problem,
 2

∂ u ∂2u
−
+
= f in Ω
∂x21 ∂x22
u = 0 on Γ

(2.24)
(2.25)

where Ω is now the rectangle (0, l1 ) × (0, l2 ) and Γ its boundary. Both intervals can
be discretized uniformly by taking n1 + 2 points in the x1 direction and n2 + 2 points
in the x2 directions:
x1,i = i × h1 , i = 0, . . . , n1 + 1 x2,j = j × h2 , j = 0, . . . , n2 + 1

2.2. FINITE DIFFERENCE METHODS

57

✻

11

12

13

14

15

6

7

8

9

10

1

2

3

4

5

✲

Figure 2.5: Natural ordering of the unknowns for a 7 × 5 two-dimensional grid.
where

l1
l2
h2 =
.
n1 + 1
n2 + 1
Since the values at the boundaries are known, we number only the interior points,
i.e., the points (x1,i , x2,j ) with 0 < i < n1 and 0 < j < n2 . The points are labeled
from the bottom up, one horizontal line at a time. This labeling is called natural
ordering and is shown in Figure 2.5 for the very simple case when n1 = 7 and
n2 = 5. The pattern of the matrix corresponding to the above equations appears in
Figure 2.6.
h1 =

Figure 2.6: Pattern of matrix associated with the 7 × 5 finite difference mesh of
Figure 2.5.

CHAPTER 2. DISCRETIZATION OF PDES

58

In the case when h1 = h2 = h the matrix has the following block structure:




4 −1
B −I
 −1 4 −1

1
.
A = 2  −I B −I  with B = 

−1 4 −1 
h
−I B
−1 4

2.2.6

Fast Poisson Solvers

A number of special techniques have been developed for solving linear systems arising from finite difference discretizations of the Poisson equation on rectangular grids.
These are termed Fast Poisson Solvers (FPS) because of the relatively low number
of arithmetic operations whuch they require, typically of the order of O(N log(N ))
where N is the size of the matrix.
Consider first the linear systems seen in the previous subsection, which have the
form (after scaling by h2 )

 



u1
b1
B −I
 −I B −I
  u2 
 b2 

  . 
 . 
..
..
..




 . 
.
(2.26)
.
.
.

  . =  . 






−I B −I
um−1
bm−1
−I B
um
bm

in which



4 −1
 −1 4 −1

..
..
B=
.
.


−1

..

.
4
−1







−1 

(2.27)

4

The notation has changed slightly in that we call p and m the mesh sizes in the x1
and x2 directions respectively. Therefore, each ui if of dimension p and corresponds
to a block of solution components along one horizontal line.
Fourier methods exploit the knowledge of the eigenvalues and eigenvectors of
the matrix B. The eigenvalues are known to be


jπ
j = 1, . . . , p
λj = 4 − 2 cos
p+1
and, defining θj ≡ (jπ)/(p + 1), the corresponding eigenvectors are given by:
r
2
qj =
× [sin θj , sin(2θj ), . . . , sin(pθj )]T .
p+1
Defining,
Q = [q1 , . . . , qp ]

2.2. FINITE DIFFERENCE METHODS

59

it is clear that QT BQ = Λ = diag (λj ). The j-th (block)-row of the system (2.26)
which can be written as
−uj−1 + Buj − uj+1 = bj ,
will now be transformed by applying the similarity transformation Q to the above
equation, leading to
−QT uj−1 + (QT BQ) QT uj − QT uj+1 = QT bj
If we denote by a bar quantities expressed in the Q basis, then the above equation
becomes
−ūj−1 + Λūj − ūj+1 = b̄j .
Note that the transformation from uj to ūj can be performed with a (real) Fast Fourier
Transform and this will be exploited shortly. Together the above equations yield the
large system,

 



ū1
b̄1
Λ −I
 −I Λ −I
  ū2 
 b̄2 

  . 
 . 
..
..
..




 . 
.
(2.28)
.
.
.

  . =  . 






−I Λ −I
ūm−1
b̄m−1
−I Λ
ūm
b̄m

As it turns out, the above system disguises a set of m independent tridiagonal systems. Indeed, taking the i-th row of each block, yields

 



λi −1
ūi1
b̄i1
 −1 λi −1
  ūi2 
 b̄i2 

  . 


.
.
.

  ..  =  ... 
..
..
..
(2.29)

 









−1 λi −1
ūip−1
b̄ip−1
−1 λi
ūip
b̄ip
where uij and bij represent the j-th components of the vectors uj and bj respectively.
The procedure becomes clear and is described in the next algorithm.
A LGORITHM 2.1 FFT-based Fast-Poisson Solver

1.
2.
3.

Compute b̄j = QT bj , j = 1, . . . , m
Solve the tridiagonal systems (2.29) for i = 1, . . . , p
Compute uj = Qūj , j = 1, . . . , m

The operations in Lines 1 and 3 are performed by FFT transforms, and require a
total of O(p log2 p) operations each, leading to a total of O(m × p log2 p) operations.
Solving the m tridiagonal systems requires a total of 8 × p × m operations. As a
result, the complexity of the algorithm is O(N logN ) where N = p × m.

CHAPTER 2. DISCRETIZATION OF PDES

60

A second class of Fast Poisson Solvers utilize Block Cyclic Reduction (BCR).
For simplicity, assume that p = 2µ − 1. Denoting 2r by h, at the r-th step of BCR,
the system is of the following form:
 (r)
 



uh
bh
B
−I
 −I B (r) −I
  u2h 
 b2h 

 



..
..
..
..
..






(2.30)
.
.
.
.
.

 
= 


(r)





−I B
−I
u(pr −1)h
b(pr −1)h
−I B (r)
upr h
bpr h

Equations whose block-index j is odd are now eliminated by multiplying each equation indexed 2jh by B (r) and adding it to equations (2j − 1)h and (2j + 1)h. This
would yield a system with a size half that of (2.30), which involves only the equations
with indices that are even multiples of h:
h
i
−u(2j−2)h + (B (r) )2 − 2I u2jh − u(2j+2)h = B (r) b2jh + b(2j−1)h + b(2j+1)h .

The process can then be repeated until we have only one system of m equations. This
could then be solved and the other unknowns recovered from it in a back-substitution.
The method based on this direct approach is not stable.
A stable modification due to Buneman [69] consists of writing the right-hand
sides differently. Each bjh is written as
(r)

(r)

(r)

bjh = B (r) pjh + qjh
(0)

(2.31)
(0)

Initially, when r = 0, the vector pi is zero and qi ≡ bj . The elimination of
block-row jh proceeds in the same manner, as was described above, leading to
h
i
(r)
−u(2j−2)h + (B (r) )2 − 2I u2jh − u(2j+2)h = (B (r) )2 p2jh +
(r)

(r)

(r)

(r)

(r)

.
B (r) (q2jh + p(2j−1)h + p(2j+1)h ) + q(2j−1)h + q(2j+1)h (2.32)

It is clear that the diagonal block matrix for the next step is
B (r+1) = (B (r) )2 − 2I .

(2.33)

It remains to recast Equation (2.32) in a such way that the right-hand side blocks are
again in the form (2.31). The new right-hand side is rewritten as
i
h
(r)
(r)
(r)
(r)
(r)
(r)
(r+1)
b2jh = (B (r) )2 p2jh + (B (r) )−1 (q2jh + p(2j−1)h + p(2j+1)h ) +q(2j−1)h +q(2j+1)h .
(r+1)

The term in the brackets is defined as p2jh
(r+1)

p2jh

(r)

(r)

(r)

(r)

= p2jh + (B (r) )−1 (q2jh + p(2j−1)h + p(2j+1)h ),

so that,
(r+1)

b2jh

(r+1)

= (B (r) )2 p2jh

(r)

(r)

+ q(2j−1)h + q(2j+1)h
(r+1)

= [(B (r) )2 − 2I]p2jh

(r+1)

+ 2p2jh

(r)

(r)

+ q(2j−1)h + q(2j+1)h .

(2.34)

2.2. FINITE DIFFERENCE METHODS
(r+1)

Then it becomes clear that q2jh
(r+1)

q2jh

61

should be defined as
(r+1)

= 2p2jh

(r)

(r)

+ q(2j−1)h + q(2j+1)h .

(2.35)

After µ − 1 steps of the above transformation, the original system (2.26) is reduced to a system with a single block which can be solved directly. The other unknown are then obtained by back-substitution, computing the ujh ’s for odd values of
j from the the ujh ’s with even values of j:
(r+1)

ujh

= (B (r) )−1 [brjh + u(j−1)h + u(j+1)h ]
r
+ u(j−1)h + u(j+1)h ]
= (B (r) )−1 [B (r) prjh + qjh
r
= prjh + (B (r) )−1 [qjh
+ u(j−1)h + u(j+1)h ] .

These substitutions are done for h = 2r decreasing from h = 2µ , to h = 20 . Buneman’s algorithm is described below.
A LGORITHM 2.2 Block Cyclic Reduction (Buneman’s version)

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.

(0)

(0)

Initialize: pi = 0, qj = bj , j = 1, . . . , p and h = 1, r = 0.
Forward solution: While (h = 2r < p) Do:
Form the matrix Yr with columns
(r)
(r)
(r)
q2jh + p(2j−1)h + p(2j+1)h , j = 1, . . . , (p + 1)/2h − 1
Solve the (multi)- linear system B (r) Xr = Yr
Update the vectors p and q according to (2.34) and (2.35)
r := r + 1
EndWhile
(r)
Solve for u: B (r) u = q1 and set uh = ph + u.
Backward substitution: while h ≥ 1 do
h := h/2
Form the matrix Yr with column vectors
(r)
qjh + u(j−1)h + u(j+1)h , j = 1, 3, 5, . . . , n/h.
Solve the (multi)- linear system B (r) Wr = Yr
Update the solution vectors ujh , j = 1, 3 , . . . , by
Ur = Pr + Wr , where Ur (resp. Pr ) is the matrix with vector
columns ujh (resp. pjh ).
EndWhile

The bulk of the work in the above algorithms lies in Lines 5 and 14, where systems of equations with multiple right-hand sides are solved with the same coefficient
matrix B (r) . For this purpose the matrix B (r) is not formed explicitly. Instead, it is
observed that B (r) is a known polynomial in B, specifically:
B (r) ≡ ph (A) = 2Ch (B/2) =

h
Y
(r)
(B − λi I)
i=1

CHAPTER 2. DISCRETIZATION OF PDES

62

where Ck denotes the Chebyshev polynomial of degree k of the first kind (See section
6.11.1 of Chapter 6 for a brief discussion of Chebyshev polynomials). The roots λi
of the polynomials ph are easily determined from those of Ch :


(2i − 1)π
(r)
λi = 2 cos
i = 1, . . . , h
2h
Thus, if p = 2µ − 1, the systems in Line 5 can be written as
r

2
Y
(r)
(A − λi I)[x1 | · · · |x2µ−r−1 −1 ] = [y1 | · · · |y2µ−r−1 −1 ].

(2.36)

i=1

An interesting, and more efficient technique, consists of combining BCR with the
FFT approach [280, 170]. In this technique a small number of cyclic reduction steps
are taken and the resulting system is then solved using the Fourier-based approach
described earlier. The cost of the algorithm is still of the form O(mp log p) but the
constant in the cost is smaller.
Block cyclic reduction can also be applied for solving general ‘separable’ equations using the algorithm described by Swartzrauber [279]. However, the roots of the
polynomial must be computed since they are not known in advance.

2.3

The Finite Element Method

The finite element method is best illustrated with the solution of a simple elliptic
Partial Differential Equation in a two-dimensional space. Consider again Poisson’s
equation (2.24) with the Dirichlet boundary condition (2.25), where Ω is a bounded
open domain in R2 and Γ its boundary. The Laplacean operator
∆=

∂2
∂2
+
∂x21 ∂x22

appears in many models of physical and mechanical phenomena. Equations involving the more general elliptic operators (2.5) and (2.6) can be treated in the same way
as Poisson’s equation (2.24) and (2.25), at least from the viewpoint of the numerical
solutions techniques.
An essential ingredient for understanding the finite element method is Green’s
formula. The setting for this formula is an open set Ω whose boundary consists of a
closed
  and smooth curve Γ as illustrated in Figure 2.1. A vector-valued function ~v =
v1
v2 , which is continuously differentiable in Ω, is given. The divergence theorem in
two-dimensional spaces states that
Z
Z
(2.37)
div~v dx = ~v .~n ds.
Ω

Γ

The dot in the right-hand side represents a dot product of two vectors in R2 . In this
case it is between the vector ~v and the unit vector ~n which is normal to Γ at the point

2.3. THE FINITE ELEMENT METHOD

63

of consideration and oriented outward. Toderive Green’s formula, consider a scalar
1
function v and a vector function w
~= w
w2 . By standard differentiation,
∇.(v w)
~ = (∇v).w
~ + v∇.w,
~

which expresses ∇v.w
~ as
∇v.w
~ = −v∇.w
~ + ∇.(v w).
~

(2.38)

Integrating the above equality over Ω and using the divergence theorem, we obtain
Z
Z
Z
∇.(v w)
~ dx
~ dx +
∇v.w
~ dx = − v∇.w
Ω
Ω
Ω
Z
Z
~ n ds.
(2.39)
~ dx + v w.~
= − v∇.w
Ω

Γ

The above equality can be viewed as a generalization of the standard integration by
part formula in calculus. Green’s formula results from (2.39) by simply taking a
vector w
~ which is itself a gradient of a scalar function u, namely, w
~ = ∇u,
Z
Z
Z
∇v.∇u dx = − v∇.∇u dx + v∇u.~n ds.
Ω

Ω

Γ

Observe that ∇.∇u = ∆u. Also the function ∇u.~n is called the normal derivative
and is denoted by
∂u
∇u.~n =
.
∂~n
With this, we obtain Green’s formula
Z
Z
Z
∂u
v∆u dx + v
∇v.∇u dx = −
ds.
(2.40)
n
Γ ∂~
Ω
Ω

We now return to the initial problem (2.24-2.25). To solve this problem approximately, it is necessary to (1) take approximations to the unknown function u, and (2)
translate the equations into a system which can be solved numerically. The options
for approximating u are numerous. However, the primary requirement is that these
approximations should be in a (small) finite dimensional space. There are also some
additional desirable numerical properties. For example, it is difficult to approximate
high degree polynomials numerically. To extract systems of equations which yield
the solution, it is common to use the weak formulation of the problem. Let us define

Z 
Z
∂u ∂v
∂u ∂v
∇u.∇v dx =
+
a(u, v) ≡
dx,
∂x2 ∂x2
Ω ∂x1 ∂x1
ZΩ
f v dx.
(f, v) ≡
Ω

An immediate property of the functional a is that it is bilinear. That means that it is
linear with respect to u and v, namely,
a(µ1 u1 + µ2 u2 , v) = µ1 a(u1 , v) + µ2 a(u2 , v),
a(u, λ1 v1 + λ2 v2 ) = λ1 a(u, v1 ) + λ2 a(u, v2 ),

∀µ1 , µ2 ∈ R,

∀λ1 , λ2 ∈ R.

CHAPTER 2. DISCRETIZATION OF PDES

64

Notice that (u, v) denotes the L2 -inner product of u and v in Ω, i.e.,
Z
u(x)v(x)dx,
(u, v) =
Ω

then, for functions satisfying the Dirichlet boundary conditions, which are at least
twice differentiable, Green’s formula (2.40) shows that
a(u, v) = −(∆u, v).
The weak formulation of the initial problem (2.24-2.25) consists of selecting a subspace of reference V of L2 and then defining the following problem:
Find

u ∈V

such that

a(u, v) = (f, v),

∀ v ∈ V.

(2.41)

In order to understand the usual choices for the space V , note that the definition of
the weak problem only requires the dot products of the gradients of u and v and the
functions f and v to be L2 –integrable. The most general V under these conditions
is the space of all functions whose derivatives up to the first order are in L2 . This
is known as H 1 (Ω). However, this space does not take into account the boundary
conditions. The functions in V must be restricted to have zero values on Γ. The
resulting space is called H01 (Ω).
The finite element method consists of approximating the weak problem by a
finite-dimensional problem obtained by replacing V with a subspace of functions
that are defined as low-degree polynomials on small pieces (elements) of the original
domain.

Figure 2.7: Finite element triangulation of a domain.

Consider a region Ω in the plane which is triangulated as shown in Figure 2.7. In
this example, the domain is simply an ellipse but the external enclosing curve is not
shown. The original domain is thus approximated by the union Ωh of m triangles
Ki ,
m
[
Ki .
Ωh =
i=1

2.3. THE FINITE ELEMENT METHOD

65

For the triangulation to be valid, these triangles must have no vertex that lies on the
edge of any other triangle. The mesh size h is defined by
h = max diam(Ki )
i=1,...,m

where diam(K), the diameter of a triangle K, is the length of its longest side.
Then the finite dimensional space Vh is defined as the space of all functions
which are piecewise linear and continuous on the polygonal region Ωh , and which
vanish on the boundary Γ. More specifically,
Vh = {φ | φ|Ωh continuous, φ|Γh = 0, φ|Kj linear ∀ j}.
Here, φ|X represents the restriction of the function φ to the subset X. If xj , j =
1, . . . , n are the nodes of the triangulation, then a function φj in Vh can be associated with each node xj , so that the family of functions φj ’s satisfies the following
conditions:

1 if xi = xj
.
(2.42)
φj (xi ) = δij =
0 if xi 6= xj
These conditions define φi , i = 1, . . . , n uniquely. In addition, the φi ’s form a basis
of the space Vh .
Each function of Vh can be expressed as
φ(x) =

n
X

ξi φi (x).

i=1

The finite element approximation consists of writing the Galerkin condition (2.41)
for functions in Vh . This defines the approximate problem:
Find

u ∈ Vh

such that

a(u, v) = (f, v), ∀ v ∈ Vh .

(2.43)

Since u is in Vh , there are n degrees of freedom. By the linearity of a with respect
to v, it is only necessary to impose the condition a(u, φi ) = (f, φi ) for i = 1, . . . , n.
This results in n constraints.
Writing the desired solution u in the basis {φi } as
u=

n
X

ξj φj (x)

j=1

and substituting in (2.43) gives the linear problem
n
X

αij ξj = βi

j=1

where
αij = a(φi , φj ),

βi = (f, φi ).

(2.44)

CHAPTER 2. DISCRETIZATION OF PDES

66

The above equations form a linear system of equations
Ax = b,
in which the coefficients of A are the αij ’s; those of b are the βj ’s. In addition, A is
a Symmetric Positive Definite matrix. Indeed, it is clear that
Z
Z
∇φj . ∇φi dx,
∇φi . ∇φj dx =
Ω

Ω

which means that αij = αji . To see that A is positive definite, first note that
a(u, u) ≥ 0 for any function u. If a(φ, φ) = 0 for a function in Vh , then it must
be true that ∇φ = 0 almost everywhere in Ωh . Since φ is linear in each triangle
and continuous, then it is clear that it must be constant on all Ω. Since, in addition,
it vanishes on the boundary, then it must be equal to zero on all of Ω. The result
follows by exploiting the relation
(Aξ, ξ) = a(φ, φ)

with

φ=

n
X

ξi φi ,

i=1

which is valid for any vector {ξi }i=1....,n .
Another important observation is that the matrix A is also sparse. Indeed, αij is
nonzero only when the two basis functions φi and φj have common support triangles, or equivalently when the nodes i and j are the vertices of a common triangle.
Specifically, for a given node i, the coefficient αij will be nonzero only when the
node j is one of the nodes of a triangle that is adjacent to node i.
In practice, the matrix is built by summing up the contributions of all triangles
by applying the formula
X
a(φi , φj ) =
aK (φi , φj )
K

in which the sum is over all the triangles K and
Z
∇φi ∇φj dx.
aK (φi , φj ) =
K

Note that aK (φi , φj ) is zero unless the nodes i and j are both vertices of K. Thus, a
triangle contributes nonzero values to its three vertices from the above formula. The
3 × 3 matrix


aK (φi , φi ) aK (φi , φj ) aK (φi , φk )
AK =  aK (φj , φi ) aK (φj , φj ) aK (φj , φk ) 
aK (φk , φi ) aK (φk , φj ) aK (φk , φk )
associated with the triangle K(i, j, k) with vertices i, j, k is called an element stiffness matrix. In order to form the matrix A, it is necessary to sum up all the contributions aK (φk , φm ) to the position k, m of the matrix. This process is called an
assembly process. In the assembly, the matrix is computed as
A=

nel
X
e=1

A[e] ,

(2.45)

2.3. THE FINITE ELEMENT METHOD

67

in which nel is the number of elements. Each of the matrices A[e] is of the form
A[e] = Pe AKe PeT
where AKe is the element matrix for the element Ke as defined above. Also Pe is an
n × 3 Boolean connectivity matrix which maps the coordinates of the 3 × 3 matrix
AKe into the coordinates of the full matrix A.
Finite element mesh
6

Assembled matrix
4
4

5
3
2

2

3
1

1

Figure 2.8: A simple finite element mesh and the pattern of the corresponding assembled matrix.
Example 2.1. The assembly process can be illustrated with a very simple example. Consider the finite element mesh shown in Figure 2.8. The four elements are
numbered from bottom to top as indicated by the labels located at their centers. There
are six nodes in this mesh and their labeling is indicated in the circled numbers. The
four matrices A[e] associated with these elements are shown in Figure 2.9. Thus, the
first element will contribute to the nodes 1, 2, 3, the second to nodes 2, 3, 5, the third
to nodes 2, 4, 5, and the fourth to nodes 4, 5, 6.
A[1]

A[2]

A[3]

A[4]

Figure 2.9: The element matrices A[e] , e = 1, . . . , 4 for the finite element mesh
shown in Figure 2.8.

CHAPTER 2. DISCRETIZATION OF PDES

68

In fact there are two different ways to represent and use the matrix A. We can
form all the element matrices one by one and then we can store them, e.g., in an
nel × 3 × 3 rectangular array. This representation is often called the unassembled
form of A. Then the matrix A may be assembled if it is needed. However, element
stiffness matrices can also be used in different ways without having to assemble the
matrix. For example, frontal techniques are direct solution methods that take the
linear system in unassembled form and compute the solution by a form of Gaussian
elimination.
There are also iterative solution techniques which work directly with unassembled matrices. One of the main operations required in many iterative methods is to
compute y = Ax, the product of the matrix A by an arbitrary vector x. In unassembled form, this can be achieved as follows:
y = Ax =

nel
X
e=1

A[e] x =

nel
X

Pe AKe (PeT x).

(2.46)

e=1

Thus, the product PeT x gathers the x data associated with the e-element into a 3vector consistent with the ordering of the matrix AKe . After this is done, this vector
must be multiplied by AKe . Finally, the result is added to the current y vector in
appropriate locations determined by the Pe array. This sequence of operations must
be done for each of the nel elements.
A more common, and somewhat more appealing, technique is to perform the assembly of the matrix. All the elements are scanned one by one and the nine associated
contributions aK (φk , φm ), k, m ∈ {i, j, k} added to the corresponding positions in
the global “stiffness” matrix. The assembled matrix must now be stored but the element matrices may be discarded. The structure of the assembled matrix depends
on the ordering of the nodes. To facilitate the computations, a widely used strategy
transforms all triangles into a reference triangle with vertices (0, 0), (0, 1), (1, 0).
The area of the triangle is then simply the determinant of the Jacobian of the transformation that allows passage from one set of axes to the other.
Simple boundary conditions such as Neumann or Dirichlet do not cause any
difficulty. The simplest way to handle Dirichlet conditions is to include boundary
values as unknowns and modify the assembled system to incorporate the boundary
values. Thus, each equation associated with the boundary point in the assembled
system is replaced by the equation ui = fi . This yields a small identity block hidden
within the linear system.
For Neumann conditions, Green’s formula will give rise to the equations
Z
Z
Z
∂u
ds,
(2.47)
f φj dx + φj
∇u.∇φj dx =
∂~n
Γ
Ω
Ω
∂u
which will involve the Neumann data ∂~
n over the boundary. Since the Neumann
data is typically given at some points only (the boundary nodes), linear interpolation
(trapezoidal rule) or the mid-line value (midpoint rule) can be used to approximate
the integral. Note that (2.47) can be viewed as the j-th equation of the linear system.

2.4. MESH GENERATION AND REFINEMENT

69

Another important point is that if the boundary conditions are only of Neumann type,
then the resulting system is singular. An equation must be removed, or the linear
system must be solved by taking this singularity into account.

2.4

Mesh Generation and Refinement

Generating a finite element triangulation can be done easily by exploiting some initial
grid and then refining the mesh a few times either uniformly or in specific areas. The
simplest refinement technique consists of taking the three midpoints of a triangle,
thus creating four smaller triangles from a larger triangle and losing one triangle,
namely, the original one. A systematic use of one level of this strategy is illustrated
for the mesh in Figure 2.8, and is shown in Figure 2.10.
This approach has the advantage of preserving the angles of the original triangulation. This is an important property since the angles of a good quality triangulation
must satisfy certain bounds. On the other hand, the indiscriminate use of the uniform
refinement strategy may lead to some inefficiencies. It is desirable to introduce more
triangles in areas where the solution is likely to have large variations. In terms of vertices, midpoints should be introduced only where needed. To obtain standard finite
element triangles, the points that have been created on the edges of a triangle must
be linked to existing vertices in the triangle. This is because no vertex of a triangle is
allowed to lie on the edge of another triangle.
Figure 2.11 shows three possible cases that can arise. The original triangle is (a).
In (b), only one new vertex (numbered 4) has appeared on one edge of the triangle
and it is joined to the vertex opposite to it. In (c), two new vertices appear inside the
original triangle. There is no alternative but to join vertices (4) and (5). However,
after this is done, either vertices (4) and (3) or vertices (1) and (5) must be joined.
If angles are desired that will not become too small with further refinements, the
second choice is clearly better in this case. In fact, various strategies for improving
the quality of the triangles have been devised. The final case (d) corresponds to the
“uniform refinement” case where all edges have been split in two. There are three
new vertices and four new elements, and the larger initial element is removed.

2.5

Finite Volume Method

The finite volume method is geared toward the solution of conservation laws of the
form:
∂u
~ = Q.
+ ∇.F
(2.48)
∂t
In the above equation, F~ (u, t) is a certain vector function of u and time, possibly
nonlinear. This is called the “flux vector.” The source term Q is a function of space
and time. We now apply the principle used in the weak formulation, described before.
Multiply both sides by a test function w, and take the integral
Z
Z
Z
∂u
~
w Q dx.
w ∇.F dx =
dx +
w
∂t
Ω
Ω
Ω

CHAPTER 2. DISCRETIZATION OF PDES

70
Finite element mesh
6
16
15

14

Assembled matrix

4
15

14
4

5

12
13

12
10

3
13

10

11
11

2
8

9
8

2
7

3
6

1
9

7
5

1

Figure 2.10: The simple finite element mesh of Figure 2.8 after one level of refinement and the corresponding matrix.
Then integrate by part using formula (2.39) for the second term on the left-hand side
to obtain
Z
Z
Z
Z
∂u
~
~
w Q dx.
∇w.F dx + w F .~n ds =
dx −
w
∂t
Ω
Γ
Ω
Ω
Consider now a control volume consisting, for example, of an elementary triangle
Ki in the two-dimensional case, such as those used in the finite element method.
Take for w a function wi whose value is one on the triangle and zero elsewhere. The
second term in the above equation vanishes and the following relation results:
Z
Z
Z
∂u
~
F .~n ds =
Q dx.
(2.49)
dx +
Ki ∂t
Ki
Γi
The above relation is at the basis of the finite volume approximation. To go a little
further, the assumptions will be simplified slightly by taking a vector function F~ that
is linear with respect to u. Specifically, assume


λ1 u
~
F =
≡ ~λu.
λ2 u

Note that, in this case, the term ∇.F~ in (2.48) becomes F~ (u) = ~λ.∇u. In addition,
the right-hand side and the first term in the left-hand side of (2.49) can be approximated as follows:
Z
Z
∂ui
∂u
dx ≈
|Ki |,
Q dx ≈ qi |Ki |.
∂t
Ki
Ki ∂t

2.5. FINITE VOLUME METHOD
3

71

(a)

3

(b)

4

1

3

1

2

1

2

(c)

3

(d)

5

6

5

1

4

4

2

2

Figure 2.11: Original triangle (a) and three possible refinement scenarios.
Here, |Ki | represents the volume of Ki , and qi is some average value of Q in the cell
Ki (Note that in two dimensions, “volume” is considered to mean area). These are
crude approximations but they serve the purpose of illustrating the scheme.
The finite volume equation (2.49) yields
Z
∂ui
~
u ~n ds = qi |Ki |.
(2.50)
|Ki | + λ.
∂t
Γi
The contour integral

Z

u ~n ds

Γi

is the sum of the integrals over all edges of the control volume. Let the value of u
on each edge j be approximated by some “average” ūj . In addition, sj denotes the
length of each edge and a common notation is
~sj = sj ~nj .
Then the contour integral is approximated by
Z
X
X
~λ.
u ~n ds ≈
ūj ~λ.~nj sj =
ūj ~λ.~sj .
Γi

edges

(2.51)

edges

The situation in the case where the control volume is a simple triangle is depicted in
Figure 2.12. The unknowns are the approximations ui of the function u associated
with each cell. These can be viewed as approximations of u at the centers of gravity
of each cell i. This type of model is called cell-centered finite volume approximations. Other techniques based on using approximations on the vertices of the cells
are known as cell-vertex finite volume techniques.

CHAPTER 2. DISCRETIZATION OF PDES

72

k

n~k

j

■

n~j

✯

i

n~l ✎
l
Figure 2.12: Finite volume cell associated with node i and three neighboring cells.

The value ūj required in (2.51) can be taken simply as the average between the
approximation ui of u in cell i and the approximation uj in the cell j on the other
side of the edge
1
(2.52)
ūj = (uj + ui ).
2
This gives
∂ui
1X
(ui + uj )~λ.~sj = qi |Ki |.
|Ki | +
∂t
2
j

One further simplification takes place by observing that
X
~sj = 0
j

and therefore

X

ui~λ.~sj = ui~λ.

j

This yields

X

~sj = 0.

j

∂ui
1X ~
uj λ.~sj = qi |Ki |.
|Ki | +
∂t
2
j

In the above equation, the summation is over all the neighboring cells j. One
problem with such simple approximations is that they do not account for large gradients of u in the components. In finite volume approximations, it is typical to exploit
upwind schemes which are more suitable in such cases. By comparing with onedimensional upwind schemes, it can be easily seen that the suitable modification to
(2.52) is as follows:


1
1
(2.53)
ūj = (uj + ui ) − sign ~λ.~sj (uj − ui ).
2
2

2.5. FINITE VOLUME METHOD

73

This gives
X
∂ui
~λ.~sj
|Ki | +
∂t
j




1
1
~
(uj + ui ) − sign(λ.~sj )(uj − ui ) = qi |Ki |.
2
2

Now write

X 1
∂ui
1~
~
|Ki | +
(uj + ui )λ.~sj − |λ.~sj |(uj − ui ) = qi |Ki |
∂t
2
2
j


X
∂ui
|Ki | +
ui (~λ.~sj )+ + uj (~λ.~sj )− = qi |Ki |
∂t
j

where
(z)± ≡

z ± |z|
.
2

The equation for cell i takes the form
X
∂ui
|Ki | + βi ui +
αij uj = qi |Ki |,
∂t
j

where
βi =

X
(~λ.~sj )+ ≥ 0,

(2.54)

j

αij

= (~λ.~sj )− ≤ 0.

(2.55)

Thus, the diagonal elements of the matrix are nonnegative, while its offdiagonal
elements are nonpositive. In addition, the row-sum of the elements, i.e., the sum of
all elements in the same row, is equal to zero. This is because
X
X
X
X
X
~λ.~sj = ~λ.
~sj = 0.
βi +
αij =
(~λ.~sj )+ +
(~λ.~sj )− =
j

j

j

j

j

The matrices obtained have the same desirable property of weak diagonal dominance
seen in the one-dimensional case. A disadvantage of upwind schemes, whether in the
context of irregular grids or in one-dimensional equations, is the loss of accuracy due
to the low order of the schemes.

P ROBLEMS
P-2.1 Derive Forward Difference formulas similar to (2.8), i.e., involving u(x), u(x +
h), u(x + 2h), . . ., which are of second and third order. Write down the discretization errors explicitly.
P-2.2 Derive a Centered Difference formula for the first derivative, similar to (2.13), which
is at least of third order.

74

CHAPTER 2. DISCRETIZATION OF PDES

P-2.3 Show that the Upwind Difference scheme described in 2.2.4, when a and ~b are constant, is stable for the model problem (2.7).
P-2.4 Develop the two nine-point formulas illustrated in Figure 2.4. Find the corresponding
discretization errors. [Hint: Combine 31 of the five-point formula (2.17) plus 23 of the same
formula based on the diagonal stencil {(x, y), (x + h, y + h) + (x + h, y − h), (x − h, y +
h), (x − h, y − h)} to get one formula. Use the reverse combination 32 , 13 to get the other
formula.]
P-2.5 Consider a (two-dimensional) rectangular mesh which is discretized as in the finite
difference approximation. Show that the finite volume approximation to ~λ.∇u yields the
same matrix as an upwind scheme applied to the same problem. What would be the mesh of
the equivalent upwind finite difference approximation?
P-2.6 Show that the right-hand side of equation (2.16) can also be written as

1 −
+
1 δ u
.
δ
a
i+ 2
h2

P-2.7 Show that the formula (2.16) is indeed second order accurate for functions that are in
C4.
P-2.8 Show that the functions φi ’s defined by (2.42) form a basis of Vh .
P-2.9 Develop the equivalent of Green’s formula for the elliptic operator L defined in (2.6).
P-2.10 Write a short FORTRAN or C program to perform a matrix-by-vector product when
the matrix is stored in unassembled form.
P-2.11 Consider the finite element mesh of Example 2.1. Compare the number of operations required to perform a matrix-by-vector product when the matrix is in assembled and
in unassembled form. Compare also the storage required in each case. For a general finite
element matrix, what can the ratio be between the two in the worst case (consider only linear
approximations on triangular elements) for arithmetic? Express the number of operations in
terms of the number of nodes and edges of the mesh. You may make the assumption that the
maximum number of elements that are adjacent to a given node is p (e.g., p = 8).
P-2.12 Let K be a polygon in R2 with m edges, and let ~sj = sj ~nj , for j = 1, . . . , m, where
sj is the length of the j-th edge and
P ~nj is the unit outward normal at the j-th edge. Use the
divergence theorem to prove that m
sj = 0.
j=1 ~
N OTES AND R EFERENCES . The books by C. Johnson [179], P. Ciarlet [84], and G. Strang and G.
Fix [277] are recommended for a good coverage of the finite element method. Axelsson and Barker
[15] discuss solution techniques for finite element problems emphasizing iterative methods. For finite
difference and finite volume methods, see C. Hirsch’s book [168] which also discusses equations and
solution methods for fluid flow problems. A 1965 article by Hockney [169] describes a one-level block
cyclic reduction method which seems to be the first “Fast Poisson Solver”. Block cyclic reduction was
developed by Buneman [69] and Hockney [171] for Poisson’s equations, and extended by Swartzrauber
[279] to separable elliptic equations. An efficient combination of block cyclic reduction and Fourier
analysis known as FACR(l), was developed by Hockney [171] and later extended in [280] and [170].
Parallel block cyclic reduction algorithms were considered in [138, 281].

Chapter 3

SPARSE MATRICES

As described in the previous chapter, standard discretizations of Partial Differential Equations
typically lead to large and sparse matrices. A sparse matrix is defined, somewhat vaguely, as
a matrix which has very few nonzero elements. But, in fact, a matrix can be termed sparse
whenever special techniques can be utilized to take advantage of the large number of zero
elements and their locations. These sparse matrix techniques begin with the idea that the
zero elements need not be stored. One of the key issues is to define data structures for these
matrices that are well suited for efficient implementation of standard solution methods, whether
direct or iterative. This chapter gives an overview of sparse matrices, their properties, their
representations, and the data structures used to store them.

3.1

Introduction

The natural idea to take advantage of the zeros of a matrix and their location was initiated by engineers in various disciplines. In the simplest case involving banded matrices, special techniques are straightforward to develop. Electrical engineers dealing
with electrical networks in the 1960s were the first to exploit sparsity to solve general
sparse linear systems for matrices with irregular structure. The main issue, and the
first addressed by sparse matrix technology, was to devise direct solution methods
for linear systems. These had to be economical, both in terms of storage and computational effort. Sparse direct solvers can handle very large problems that cannot be
tackled by the usual “dense” solvers.
Essentially, there are two broad types of sparse matrices: structured and unstructured. A structured matrix is one whose nonzero entries form a regular pattern, often
along a small number of diagonals. Alternatively, the nonzero elements may lie in
blocks (dense submatrices) of the same size, which form a regular pattern, typically
along a small number of (block) diagonals. A matrix with irregularly located entries
is said to be irregularly structured. The best example of a regularly structured matrix is a matrix that consists of only a few diagonals. Finite difference matrices on
rectangular grids, such as the ones seen in the previous chapter, are typical examples
of matrices with regular structure. Most finite element or finite volume techniques
75

CHAPTER 3. SPARSE MATRICES

76

applied to complex geometries lead to irregularly structured matrices. Figure 3.2
shows a small irregularly structured sparse matrix associated with the finite element
grid problem shown in Figure 3.1.
13

41

43

40

42

9

18

10

23

11

27

12

31

14

19

17

21

22

25

26

29

30

33

1

20

2

24

3

28

4

32

6

34

35

5

15

45

44

16

39

8

37

36

38

7

Figure 3.1: A small finite element grid model.
The distinction between the two types of matrices may not noticeably affect direct solution techniques, and it has not received much attention in the past. However,
this distinction can be important for iterative solution methods. In these methods,
one of the essential operations is matrix-by-vector products. The performance of
these operations can differ significantly on high performance computers, depending
on whether they are regularly structured or not. For example, on vector computers,
storing the matrix by diagonals is ideal, but the more general schemes may suffer
because they require indirect addressing.
The next section discusses graph representations of sparse matrices. This is followed by an overview of some of the storage schemes used for sparse matrices and
an explanation of how some of the simplest operations with sparse matrices can be
performed. Then sparse linear system solution methods will be covered. Finally,
Section 3.7 discusses test matrices.

3.2

Graph Representations

Graph theory is an ideal tool for representing the structure of sparse matrices and for
this reason it plays a major role in sparse matrix techniques. For example, graph theory is the key ingredient used in unraveling parallelism in sparse Gaussian elimination or in preconditioning techniques. In the following section, graphs are discussed
in general terms and then their applications to finite element or finite difference matrices are discussed.

3.2. GRAPH REPRESENTATIONS

77

Figure 3.2: Sparse matrix associated with the finite element grid of Figure 3.1.

3.2.1

Graphs and Adjacency Graphs

Remember that a graph is defined by two sets, a set of vertices
V = {v1 , v2 , . . . , vn },
and a set of edges E which consists of pairs (vi , vj ), where vi , vj are elements of V ,
i.e.,
E ⊆ V × V.
This graph G = (V, E) is often represented by a set of points in the plane linked by
a directed line between the points that are connected by an edge. A graph is a way
of representing a binary relation between objects of a set V . For example, V can
represent the major cities of the world. A line is drawn between any two cities that
are linked by a nonstop airline connection. Such a graph will represent the relation
“there is a nonstop flight from city (A) to city (B).” In this particular example, the
binary relation is likely to be symmetric, i.e., when there is a nonstop flight from (A)
to (B) there is also a nonstop flight from (B) to (A). In such situations, the graph is
said to be undirected, as opposed to a general graph which is directed.
Going back to sparse matrices, the adjacency graph of a sparse matrix is a graph
G = (V, E), whose n vertices in V represent the n unknowns. Its edges represent
the binary relations established by the equations in the following manner: There is
an edge from node i to node j when aij 6= 0. This edge will therefore represent the
binary relation equation i involves unknown j. Note that the adjacency graph is an
undirected graph when the matrix pattern is symmetric, i.e., when aij 6= 0 iff aji 6= 0
for all 1 ≤ i, j ≤ n).
When a matrix has a symmetric nonzero pattern, i.e., when aij and aji are always nonzero at the same time, then the graph is undirected. Thus, for undirected

CHAPTER 3. SPARSE MATRICES

78

graphs, every edge points in both directions. As a result, undirected graphs can be
represented with nonoriented edges.
As an example of the use of graph models, parallelism in Gaussian elimination
can be extracted by finding unknowns that are independent at a given stage of the
elimination. These are unknowns which do not depend on each other according to the
above binary relation. The rows corresponding to such unknowns can then be used
as pivots simultaneously. Thus, in one extreme, when the matrix is diagonal, then all
unknowns are independent. Conversely, when a matrix is dense, each unknown will
depend on all other unknowns. Sparse matrices lie somewhere between these two
extremes.
1
2

4

3
1

4

2

3

Figure 3.3: Graphs of two 4 × 4 sparse matrices.
There are a few interesting simple properties of adjacency graphs. The graph
of A2 can be interpreted as an n-vertex graph whose edges are the pairs (i, j) for
which there exists at least one path of length exactly two from node i to node j in
the original graph of A. Similarly, the graph of Ak consists of edges which represent
the binary relation “there is at least one path of length k from node i to node j.” For
details, see Exercise 4.

3.2.2

Graphs of PDE Matrices

For Partial Differential Equations involving only one physical unknown per mesh
point, the adjacency graph of the matrix arising from the discretization is often the
graph represented by the mesh itself. However, it is common to have several unknowns per mesh point. For example, the equations modeling fluid flow may involve
the two velocity components of the fluid (in two dimensions) as well as energy and
momentum at each mesh point.
In such situations, there are two choices when labeling the unknowns. They
can be labeled contiguously at each mesh point. Thus, for the example just men-

3.3. PERMUTATIONS AND REORDERINGS

79

tioned, we can label all four variables (two velocities followed by momentum and
then pressure) at a given mesh point as u(k), . . ., u(k + 3). Alternatively, all unknowns associated with one type of variable can be labeled first (e.g., first velocity
components), followed by those associated with the second type of variables (e.g.,
second velocity components), etc. In either case, it is clear that there is redundant
information in the graph of the adjacency matrix.
The quotient graph corresponding to the physical mesh can be used instead. This
results in substantial savings in storage and computation. In the fluid flow example
mentioned above, the storage can be reduced by a factor of almost 16 for the integer
arrays needed to represent the graph. This is because the number of edges has been
reduced by this much, while the number of vertices, which is usually much smaller,
remains the same.

3.3

Permutations and Reorderings

Permuting the rows or the columns, or both the rows and columns, of a sparse matrix
is a common operation. In fact, reordering rows and columns is one of the most
important ingredients used in parallel implementations of both direct and iterative
solution techniques. This section introduces the ideas related to these reordering
techniques and their relations to the adjacency graphs of the matrices. Recall the
notation introduced in Chapter 1 that the j-th column of a matrix is denoted by a∗j
and the i-th row by ai∗ .

3.3.1

Basic Concepts

We begin with a definition and new notation.
Definition 3.1 Let A be a matrix and π = {i1 , i2 , . . . , in } a permutation of the set
{1, 2, . . . , n}. Then the matrices
Aπ,∗ = {aπ(i),j }i=1,...,n;j=1,...,m ,
A∗,π = {ai,π(j) }i=1,...,n;j=1,...,m

are called row π-permutation and column π-permutation of A, respectively.
It is well known that any permutation of the set {1, 2, . . . , n} results from at most
n interchanges, i.e., elementary permutations in which only two entries have been
interchanged. An interchange matrix is the identity matrix with two of its rows interchanged. Denote by Xij such matrices, with i and j being the numbers of the
interchanged rows. Note that in order to interchange rows i and j of a matrix A, we
only need to premultiply it by the matrix Xij . Let π = {i1 , i2 , . . . , in } be an arbitrary permutation. This permutation is the product of a sequence of n consecutive
interchanges σ(ik , jk ), k = 1, . . . , n. Then the rows of a matrix can be permuted by
interchanging rows i1 , j1 , then rows i2 , j2 of the resulting matrix, etc., and finally by
interchanging in , jn of the resulting matrix. Each of these operations can be achieved

CHAPTER 3. SPARSE MATRICES

80

by a premultiplication by Xik ,jk . The same observation can be made regarding the
columns of a matrix: In order to interchange columns i and j of a matrix, postmultiply it by Xij . The following proposition follows from these observations.
Proposition 3.2 Let π be a permutation resulting from the product of the interchanges σ(ik , jk ), k = 1, . . . , n. Then,
Aπ,∗ = Pπ A,

A∗,π = AQπ ,

where
Pπ = Xin ,jn Xin−1 ,jn−1 . . . Xi1 ,j1 ,

(3.1)

Qπ = Xi1 ,j1 Xi2 ,j2 . . . Xin ,jn .

(3.2)

Products of interchange matrices are called permutation matrices. Clearly, a permutation matrix is nothing but the identity matrix with its rows (or columns) permuted.
2 = I, i.e., the square of an interchange matrix is the identity, or
Observe that Xi,j
equivalently, the inverse of an interchange matrix is equal to itself, a property which
is intuitively clear. It is easy to see that the matrices (3.1) and (3.2) satisfy
Pπ Qπ = Xin ,jn Xin−1 ,jn−1 . . . Xi1 ,j1 × Xi1 ,j1 Xi2 ,j2 . . . Xin ,jn = I,
which shows that the two matrices Qπ and Pπ are nonsingular and that they are the
inverse of one another. In other words, permuting the rows and the columns of a matrix, using the same permutation, actually performs a similarity transformation. Another important consequence arises because the products involved in the definitions
(3.1) and (3.2) of Pπ and Qπ occur in reverse order. Since each of the elementary
matrices Xik ,jk is symmetric, the matrix Qπ is the transpose of Pπ . Therefore,
Qπ = PπT = Pπ−1 .
Since the inverse of the matrix Pπ is its own transpose, permutation matrices are
unitary.
Another way of deriving the above relationships is to express the permutation
matrices Pπ and PπT in terms of the identity matrix, whose columns or rows are
permuted. It can easily be seen (See Exercise 3) that
Pπ = Iπ,∗ ,

PπT = I∗,π .

It is then possible to verify directly that
Aπ,∗ = Iπ,∗ A = Pπ A,

A∗,π = AI∗,π = APπT .

It is important to interpret permutation operations for the linear systems to be
solved. When the rows of a matrix are permuted, the order in which the equations
are written is changed. On the other hand, when the columns are permuted, the
unknowns are in effect relabeled, or reordered.

3.3. PERMUTATIONS AND REORDERINGS

81

Example 3.1. Consider, for example, the linear system Ax = b where


a11 0 a13 0
 0 a22 a23 a24 

A=
 a31 a32 a33 0 
0 a42 0 a44

and π = {1, 3, 2, 4}, then the (column-) permuted linear system is

   
a11 a13 0
0
x1
b1
 0 a23 a22 a24   x3   b2 

   
 a31 a33 a32 0   x2  =  b3  .
0
0 a42 a44
x4
b4

Note that only the unknowns have been permuted, not the equations, and in particular,
the right-hand side has not changed.
In the above example, only the columns of A have been permuted. Such onesided permutations are not as common as two-sided permutations in sparse matrix
techniques. In reality, this is often related to the fact that the diagonal elements in
linear systems play a distinct and important role. For instance, diagonal elements are
typically large in PDE applications and it may be desirable to preserve this important
property in the permuted matrix. In order to do so, it is typical to apply the same
permutation to both the columns and the rows of A. Such operations are called
symmetric permutations, and if denoted by Aπ,π , then the result of such symmetric
permutations satisfies the relation
Aπ,π = Pπ APπT .
The interpretation of the symmetric permutation is quite simple. The resulting matrix corresponds to renaming, or relabeling, or reordering the unknowns and then
reordering the equations in the same manner.
Example 3.2. For the previous example, if the rows are permuted with the same
permutation as the columns, the linear system obtained is

   
a11 a13 0
0
x1
b1
 a31 a33 a32 0   x3   b3 

   
 0 a23 a22 a24   x2  =  b2  .
0
0 a42 a44
x4
b4

Observe that the diagonal elements are now diagonal elements from the original matrix, placed in a different order on the main diagonal.

3.3.2

Relations with the Adjacency Graph

From the point of view of graph theory, another important interpretation of a symmetric permutation is that it is equivalent to relabeling the vertices of the graph without

CHAPTER 3. SPARSE MATRICES

82

altering the edges. Indeed, let (i, j) be an edge in the adjacency graph of the original
matrix A and let A′ be the permuted matrix. Then a′ij = aπ(i),π(j) and as a result
(i, j) is an edge in the adjacency graph of the permuted matrix A′ , if and only if
(π(i), π(j)) is an edge in the graph of the original matrix A. In essence, it is as if
we simply relabel each node with the “old” label π(i) with the “new” label i. This is
pictured in the following diagram:
i

j

← new labels

π(i)

π(j)

← old labels

Thus, the graph of the permuted matrix has not changed; rather, the labeling of the
vertices has. In contrast, nonsymmetric permutations do not preserve the graph. In
fact, they can transform an indirected graph into a directed one. Symmetric permutations change the order in which the nodes are considered in a given algorithm (such
as Gaussian elimination) and this may have a tremendous impact on the performance
of the algorithm.
7
6

5

8

9

1

4

2
3

Figure 3.4: Pattern of a 9 × 9 arrow matrix and its adjacency graph.

Example 3.3. Consider the matrix illustrated in Figure 3.4 together with its adjacency graph. Such matrices are sometimes called “arrow” matrices because of their
shape, but it would probably be more accurate to term them “star” matrices because
of the structure of their graphs. If the equations are reordered using the permutation
9, 8, . . . , 1, the matrix and graph shown in Figure 3.5 are obtained.
Although the difference between the two graphs may seem slight, the matrices
have a completely different structure, which may have a significant impact on the
algorithms. As an example, if Gaussian elimination is used on the reordered matrix,
no fill-in will occur, i.e., the L and U parts of the LU factorization will have the same
structure as the lower and upper parts of A, respectively.

3.3. PERMUTATIONS AND REORDERINGS

83

3
4

5

2

9

6

1

8
7

Figure 3.5: Adjacency graph and matrix obtained from above figure after permuting
the nodes in reverse order.

On the other hand, Gaussian elimination on the original matrix results in disastrous fill-ins. Specifically, the L and U parts of the LU factorization are now dense
matrices after the first step of Gaussian elimination. With direct sparse matrix techniques, it is important to find permutations of the matrix that will have the effect of
reducing fill-ins during the Gaussian elimination process.
To conclude this section, it should be mentioned that two-sided nonsymmetric
permutations may also arise in practice. However, they are more common in the
context of direct methods.

3.3.3

Common Reorderings

The type of reordering, or permutations, used in applications depends on whether a
direct or an iterative method is being considered. The following is a sample of such
reorderings which are more useful for iterative methods.
Level-set orderings. This class of orderings contains a number of techniques that
are based on traversing the graph by level sets. A level set is defined recursively as
the set of all unmarked neighbors of all the nodes of a previous level set. Initially, a
level set consists of one node, although strategies with several starting nodes are also
important and will be considered later. As soon as a level set is traversed, its nodes
are marked and numbered. They can, for example, be numbered in the order in which
they are traversed. In addition, the order in which each level itself is traversed gives
rise to different orderings. For instance, the nodes of a certain level can be visited
in the natural order in which they are listed. The neighbors of each of these nodes
are then inspected. Each time, a neighbor of a visited vertex that is not numbered is
encountered, it is added to the list and labeled as the next element of the next level
set. This simple strategy is called Breadth First Search (BFS) traversal in graph
theory. The ordering will depend on the way in which the nodes are traversed in each

CHAPTER 3. SPARSE MATRICES

84

level set. In BFS the elements of a level set are always traversed in the natural order
in which they are listed. In the Cuthill-McKee ordering the nodes adjacent a a visited
node are always traversed from lowest to highest degree.
A LGORITHM 3.1 BFS(G, v)

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.

Initialize S = {v}, seen = 1, π(seen) = v ; Mark v ;
While seen < n Do
Snew = ∅;
For each node v in S do
For each unmarked w in adj(v ) do
Add w to Snew ;
Mark w;
π(+ + seen) = w;
EndDo
S := Snew
EndDo
EndWhile

In the above algorithm, the notation π(+ + seen) = w in Line 8, uses a style borrowed from the C/C++ language. It states that seen should be first incremented by
one, and then π(seen) is assigned w. Two important modifications will be made to
this algorithm to obtain the Cuthill Mc Kee ordering. The first concerns the selection
of the first node to begin the traversal. The second, mentioned above, is the orde in
which the nearest neighbors of a given node are traversed.
A LGORITHM 3.2 Cuthill-McKee ( G)

0.
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.

Find an intial node v for the traversal
Initialize S = {v}, seen = 1, π(seen) = v ; Mark v ;
While seen < n Do
Snew = ∅;
For each node v Do:
π(+ + seen) = v ;
For each unmarked w in adj(v ), going from lowest to highest degree Do:
Add w to Snew ;
Mark w;
EndDo
S := Snew
EndDo
EndWhile

The π array obtained from the procedure lists the nodes in the order in which
they are visited and can, in a practical implementation, be used to store the level sets
in succession. A pointer is needed to indicate where each set starts.

3.3. PERMUTATIONS AND REORDERINGS

85

The main property of level sets is that, at the exception of the first and the last
levels, they are are graph separators. A graph separator is a set of vertices, the
removal of which separates the graph in two disjoint components. In fact if there
are l levels and V1 = S1 U S2 . . . Si−1 , V2 = Si+1 U . . . Sl , then the nodes of V1 are
V2 are not coupled. This is easy to prove by contradiction. A major consequence of
this property is that the matrix resulting from the Cuthill-McKee (or BFS) ordering
is block-tridiagonal, with the i-th block being of size |Si |.
I order to explain the concept of level sets, the previous two algorithms were
described with the explicit use of level sets. A more common, and somewhat simpler,
implementation relies on queues. The queue implementation is as follows.
A LGORITHM 3.3 Cuthill-McKee (G) – Queue implementation

0.
1.
2.
3.
4.
5.
6.
7.
8.

Find an intial node v for the traversal
Initialize Q = {v}, Mark v ;
While |Q| < n Do
head + + ;
For each unmarked w in adj(h), going from lowest to highest degree Do:
Append w to Q;
Mark w;
EndDo
EndWhile

The final array Q will give the desired permutation π. Clearly, this implementation
can also be applied to BFS. As an example, consider the finite element mesh problem
illustrated in Figure 2.10 of Chapter 2, and assume that v = 3 is the initial node of
the traversal. The state of the Q array after each step along with the head vertex head
and its adjacency list are shown in the following table. Note that the adjacency lists
in the third column are listed by increasing degrees.
Q

head

adj(head)

3
3, 7, 10, 8
3, 7, 10, 8, 1, 9
3, 7, 10, 8, 1, 9, 5, 11
3, 7, 10, 8, 1, 9, 5, 11, 2
3, 7, 10, 8, 1, 9, 5, 11, 2
3, 7, 10, 8, 1, 9, 5, 11, 2
3, 7, 10, 8, 1, 9, 5, 11, 2, 14, 12
3, 7, 10, 8, 1, 9, 5, 11, 2, 14, 12, 13
3, 7, 10, 8, 1, 9, 5, 11, 2, 14, 12, 13
3, 7, 10, 8, 1, 9, 5, 11, 2, 14, 12, 13, 6, 15
3, 7, 10, 8, 1, 9, 5, 11, 2, 14, 12, 13, 6, 15, 4

3
7
10
8
1
9
5
11
2
14
12

7, 10, 8
1, 9
5, 11
2
14, 12
13
6, 15
4

An implementation using explicit levels, would find the sets S1 = {3}, S2 =
{7, 8, 10}, S3 = {1, 9, 5, 11, 2}, S4 = {14, 12, 13}, and S5 = {6, 15, 4}. The

CHAPTER 3. SPARSE MATRICES

86

new labeling of the graph along with the corresponding matrix pattern are shown in
Figure 3.6. The partitionning of the matrix pattern corresponds to the levels.
In 1971, George [142] observed that reversing the Cuthill-McKee ordering yields
a better scheme for sparse Gaussian elimination. The simplest way to understand
this is to look at the two graphs produced by these orderings. The results of the
standard and reversed Cuthill-McKee orderings on the sample finite element mesh
problem seen earlier are shown in Figures 3.6 and 3.7, when the initial node is i1 = 3
(relative to the labeling of the original ordering of Figure 2.10). The case of the
figure, corresponds to a variant of CMK in which the traversals in Line 6, is done
in a random order instead of according to the degree. A large part of the structure
of the two matrices consists of little “arrow” submatrices, similar to the ones seen in
Example 3.3. In the case of the regular CMK ordering, these arrows point upward,
as in Figure 3.4, a consequence of the level set labeling. These blocks are similar
the star matrices of Figure 3.4. As a result, Gaussian elimination will essentially fill
in the square blocks which they span. As was indicated in Example 3.3, a remedy
is to reorder the nodes backward, as is done globally in the reverse Cuthill-McKee
strategy. For the reverse CMK ordering, the arrows are pointing downward, as in
Figure 3.5, and Gaussian elimination yields much less fill-in.
13

14

10

15

11

7

12

8

3

9

4

1

6

2

5

Figure 3.6: Graph and matrix pattern for example pf Figure 2.10 after CuthillMcKee ordering.

Example 3.4. The choice of the initial node in the CMK and RCMK orderings
may be important. Referring to the original ordering of Figure 2.10, the previous
illustration used i1 = 3. However, it is clearly a poor choice if matrices with small
bandwidth or profile are desired. If i1 = 1 is selected instead, then the reverse

3.3. PERMUTATIONS AND REORDERINGS

87

3

2

6

1

5

9

4

8

13

7

12

15

10

14

11

Figure 3.7: Reverse Cuthill-McKee ordering.
Cuthill-McKee algorithm produces the matrix in Figure 3.8, which is more suitable
for banded or skyline solvers.
Independent set orderings. The matrices that arise in the model finite element
problems seen in Figures 2.7, 2.10, and 3.2 are all characterized by an upper-left
block that is diagonal, i.e., they have the structure


D E
A=
,
(3.3)
F C
in which D is diagonal and C, E, and F are sparse matrices. The upper-diagonal
block corresponds to unknowns from the previous levels of refinement and its presence is due to the ordering of the equations in use. As new vertices are created in
the refined grid, they are given new numbers and the initial numbering of the vertices
is unchanged. Since the old connected vertices are “cut” by new ones, they are no
longer related by equations. Sets such as these are called independent sets. Independent sets are especially useful in parallel computing, for implementing both direct
and iterative methods.
Referring to the adjacency graph G = (V, E) of the matrix, and denoting by
(x, y) the edge from vertex x to vertex y, an independent set S is a subset of the
vertex set V such that
if x ∈ S,

then

{(x, y) ∈ E or (y, x) ∈ E} → y ∈
/ S.

To explain this in words: Elements of S are not allowed to be connected to
other elements of S either by incoming or outgoing edges. An independent set is

CHAPTER 3. SPARSE MATRICES

88
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

Figure 3.8: Reverse Cuthill-McKee starting with i1 = 1.
maximal if it cannot be augmented by elements in its complement to form a larger
independent set. Note that a maximal independent set is by no means the largest
possible independent set that can be found. In fact, finding the independent set of
maximum cardinal is N P -hard [183]. In the following, the term independent set
always refers to maximal independent set.
There are a number of simple and inexpensive heuristics for finding large maximal independent sets. A greedy heuristic traverses the nodes in a given order, and if
a node is not already marked, it selects the node as a new member of S. Then this
node is marked along with its nearest neighbors. Here, a nearest neighbor of a node
x means any node linked to x by an incoming or an outgoing edge.
A LGORITHM 3.4 Greedy Algorithm for ISO

1.
2.
3.
4.
5.
6.
7.

Set S = ∅.
For j = 1, 2, . . . , n Do:
If node j is not marked then
S = S ∪ {j}
Mark j and all its nearest neighbors
EndIf
EndDo

In the above algorithm, the nodes are traversed in the natural order 1, 2, . . . , n,
but they can also be traversed in any permutation {i1 , . . . , in } of {1, 2, . . . , n}. Since
the size of the reduced system is n − |S|, it is reasonable to try to maximize the
size of S in order to obtain a small reduced system. It is possible to give a rough

3.3. PERMUTATIONS AND REORDERINGS

89

idea of the size of S. Assume that the maximum degree of each node does not
exceed ν. Whenever the above algorithm accepts a node as a new member of S, it
potentially puts all its nearest neighbors, i.e., at most ν nodes, in the complement of
S. Therefore, if s is the size of S, the size of its complement, n − s, is such that
n − s ≤ νs, and as a result,
n
.
s≥
1+ν
This lower bound can be improved slightly by replacing ν with the maximum degree
νS of all the vertices that constitute S. This results in the inequality
n
s≥
,
1 + νS
which suggests that it may be a good idea to first visit the nodes with smaller degrees.
In fact, this observation leads to a general heuristic regarding a good order of traversal. The algorithm can be viewed as follows: Each time a node is visited, remove it
and its nearest neighbors from the graph, and then visit a node from the remaining
graph. Continue in the same manner until all nodes are exhausted. Every node that is
visited is a member of S and its nearest neighbors are members of S̄. As result, if νi
is the degree of the node visited at step i, adjusted for all the edge deletions resulting
from the previous visitation steps, then the number ni of nodes that are left at step i
satisfies the relation
ni = ni−1 − νi − 1.
The process adds a new element to the set S at each step and stops when ni = 0.
In order to maximize |S|, the number of steps in the procedure must be maximized.
The difficulty in the analysis arises from the fact that the degrees are updated at each
step i because of the removal of the edges associated with the removed nodes. If the
process is to be lengthened, a rule of thumb would be to visit the nodes that have the
smallest degrees first.
A LGORITHM 3.5 Increasing Degree Traversal for ISO

1.
2.
3.
4.
5.
6.
7.

Set S = ∅. Find an ordering i1 , . . . , in of the nodes by increasing degree.
For j = 1, 2, . . . n, Do:
If node ij is not marked then
S = S ∪ {ij }
Mark ij and all its nearest neighbors
EndIf
EndDo

A refinement to the above algorithm would be to update the degrees of all nodes
involved in a removal, and dynamically select the one with the smallest degree as the
next node to be visited. This can be implemented efficiently using a min-heap data
structure. A different heuristic is to attempt to maximize the number of elements in S
by a form of local optimization which determines the order of traversal dynamically.
In the following, removing a vertex from a graph means deleting the vertex and all
edges incident to/from this vertex.

90

CHAPTER 3. SPARSE MATRICES

Example 3.5. The algorithms described in this section were tested on the same
example used before, namely, the finite element mesh problem of Figure 2.10. Here,
all strategies used yield the initial independent set in the matrix itself, which corresponds to the nodes of all the previous levels of refinement. This may well be optimal
in this case, i.e., a larger independent set may not exist.
Multicolor orderings. Graph coloring is a familiar problem in computer science
which refers to the process of labeling (coloring) the nodes of a graph in such a way
that no two adjacent nodes have the same label (color). The goal of graph coloring is to obtain a colored graph which uses the smallest possible number of colors.
However, optimality in the context of numerical linear algebra is a secondary issue
and simple heuristics do provide adequate colorings. Basic methods for obtaining a
multicoloring of an arbitrary grid are quite simple. They rely on greedy techniques,
a simple version of which is as follows.
A LGORITHM 3.6 Greedy Multicoloring Algorithm

1.
2.
3.
4.

For i = 1, . . . , n Do: set Color(i) = 0.
For i = 1, 2, . . . , n Do:
Set Color(i) = min {k > 0 | k 6= Color(j), ∀ j ∈ Adj(i))}
EndDo

Line 3 assigns the smallest allowable color number to node i. Allowable means a
positive number that is different from the colors of the neighbors of node i. The
procedure is illustrated in Figure 3.9. The node being colored in the figure is indicated by an arrow. It will be assigned color number 3, the smallest positive integer
different from 1, 2, 4, 5.
In the above algorithm, the order 1, 2, . . . , n has been arbitrarily selected for
traversing the nodes and coloring them. Instead, the nodes can be traversed in any
order {i1 , i2 , . . . , in }. If a graph is bipartite, i.e., if it can be colored with two
colors, then the algorithm will find the optimal two-color (Red-Black) ordering for
Breadth-First traversals. In addition, if a graph is bipartite, it is easy to show that
the algorithm will find two colors for any traversal which, at a given step, visits an
unmarked node that is adjacent to at least one visited node. In general, the number
of colors needed does not exceed the maximum degree of each node +1. These
properties are the subject of Exercises 11 and 10.
Example 3.6. Figure 3.10 illustrates the algorithm for the same example used earlier, i.e., the finite element mesh problem of Figure 2.10. The dashed lines separate
the different color sets found. Four colors are found in this example.
Once the colors have been found, the matrix can be permuted to have a block
structure in which the diagonal blocks are diagonal. Alternatively, the color sets
(j)
(j)
Sj = [i1 , . . ., inj ] and the permutation array in the algorithms can be used.

3.3. PERMUTATIONS AND REORDERINGS

91

1
0
3←

0

2
4

5

Figure 3.9: The greedy multicoloring algorithm.
6

15

12

4

9

5

11

14

8

2

10

3

13

7

1

Figure 3.10: Graph and matrix corresponding to mesh of Figure 2.10 after multicolor
ordering.

3.3.4

Irreducibility

Remember that a path in a graph is a sequence of vertices v1 , v2 , . . . , vk , which are
such that (vi , vi+1 ) is an edge for i = 1, . . . , k − 1. Also, a graph is said to be
connected if there is a path between any pair of two vertices in V . A connected component in a graph is a maximal subset of vertices which all can be connected to one
another by paths in the graph. Now consider matrices whose graphs may be directed.
A matrix is reducible if its graph is not connected, and irreducible otherwise. When
a matrix is reducible, then it can be permuted by means of symmetric permutations
into a block upper triangular matrix of the form


A11 A12 A13 . . .

A22 A23 . . . 

,
.. 
..

.
. 
App

CHAPTER 3. SPARSE MATRICES

92

where each partition corresponds to a connected component. It is clear that linear
systems with the above matrix can be solved through a sequence of subsystems with
the matrices Aii , i = p, p − 1, . . . , 1.

3.4

Storage Schemes

In order to take advantage of the large number of zero elements, special schemes are
required to store sparse matrices. The main goal is to represent only the nonzero
elements, and to be able to perform the common matrix operations. In the following,
N z denotes the total number of nonzero elements.
The simplest storage scheme for sparse matrices is the so-called coordinate format. The data structure consists of three arrays: (1) a real array containing all the real
(or complex) values of the nonzero elements of A in any order; (2) an integer array
containing their row indices; and (3) a second integer array containing their column
indices. All three arrays are of length N z, the number of nonzero elements.
Example 3.7. The matrix


1.
 3.

A=
 6.
 0.
0.

0. 0.
4. 0.
0. 7.
0. 10.
0. 0.


0.
0. 

9. 

0. 
12.

2.
5.
8.
11.
0.

will be represented (for example) by
AA

12. 9. 7. 5. 1. 2. 11. 3. 6. 4. 8. 10.

JR

5

3

3

2

1

1

4

2

3

2

3

4

JC

5

5

3

4

1

4

4

1

1

2

4

3

In the above example, the elements are listed in an arbitrary order. In fact, they
are usually listed by row or columns. If the elements were listed by row, the array JC
which contains redundant information might be replaced by an array which points
to the beginning of each row instead. This would involve nonnegligible savings in
storage. The new data structure has three arrays with the following functions:
• A real array AA contains the real values aij stored row by row, from row 1 to
n. The length of AA is N z.
• An integer array JA contains the column indices of the elements aij as stored
in the array AA. The length of JA is Nz.
• An integer array IA contains the pointers to the beginning of each row in the
arrays AA and JA. Thus, the content of IA(i) is the position in arrays AA
and JA where the i-th row starts. The length of IA is n + 1 with IA(n + 1)

3.4. STORAGE SCHEMES

93

containing the number IA(1) + N z, i.e., the address in A and JA of the
beginning of a fictitious row number n + 1.
Thus, the above matrix may be stored as follows:
AA

1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12.

JA

1

4

1

IA

1

3

6 10 12 13

2

4

1

3

4

5

3

4

5

This format is probably the most popular for storing general sparse matrices.
It is called the Compressed Sparse Row (CSR) format. This scheme is preferred
over the coordinate scheme because it is often more useful for performing typical
computations. On the other hand, the coordinate scheme is advantageous for its
simplicity and its flexibility. It is often used as an “entry” format in sparse matrix
software packages.
There are a number of variations for the Compressed Sparse Row format. The
most obvious variation is storing the columns instead of the rows. The corresponding
scheme is known as the Compressed Sparse Column (CSC) scheme.
Another common variation exploits the fact that the diagonal elements of many
matrices are all usually nonzero and/or that they are accessed more often than the rest
of the elements. As a result, they can be stored separately. The Modified Sparse Row
(MSR) format has only two arrays: a real array AA and an integer array JA. The first
n positions in AA contain the diagonal elements of the matrix in order. The unused
position n + 1 of the array AA may sometimes carry some information concerning
the matrix.
Starting at position n + 2, the nonzero entries of AA, excluding its diagonal
elements, are stored by row. For each element AA(k), the integer JA(k) represents
its column index on the matrix. The n + 1 first positions of JA contain the pointer
to the beginning of each row in AA and JA. Thus, for the above example, the two
arrays will be as follows:
AA

1. 4. 7. 11. 12. *

JA

7

2. 3. 5. 6. 8. 9. 10.

8 10 13 14 14 4

1

4

1

4

5

3

The star denotes an unused location. Notice that JA(n) = JA(n + 1) = 14, indicating that the last row is a zero row, once the diagonal element has been removed.
Diagonally structured matrices are matrices whose nonzero elements are located
along a small number of diagonals. These diagonals can be stored in a rectangular
array DIAG(1:n,1:Nd), where Nd is the number of diagonals. The offsets of each
of the diagonals with respect to the main diagonal must be known. These will be
stored in an array IOFF(1:Nd). Thus, the element ai,i+ioff(j) of the original matrix
is located in position (i, j) of the array DIAG, i.e.,
DIAG(i, j) ← ai,i+ioff(j) .

CHAPTER 3. SPARSE MATRICES

94

The order in which the diagonals are stored in the columns of DIAG is generally
unimportant, though if several more operations are performed with the main diagonal, storing it in the first column may be slightly advantageous. Note also that all the
diagonals except the main diagonal have fewer than n elements, so there are positions
in DIAG that will not be used.
Example 3.8. For example, the following matrix which has three diagonals


1. 0. 2. 0.
0.
 3. 4. 0. 5.
0. 



A =  0. 6. 7. 0.
8. 

 0. 0. 9. 10. 0. 
0. 0. 0. 11. 12.

will be represented by the two arrays

DIAG =

*
3.
6.
9.
11

1.
4.
7.
10.
12.

2.
5.
8.
*
*

IOFF = -1 0 2 .

A more general scheme which is popular on vector machines is the so-called
Ellpack-Itpack format. The assumption in this scheme is that there are at most N d
nonzero elements per row, where Nd is small. Then two rectangular arrays of dimension n × Nd each are required (one real and one integer). The first, COEF, is similar
to DIAG and contains the nonzero elements of A. The nonzero elements of each row
of the matrix can be stored in a row of the array COEF(1:n,1:Nd), completing the
row by zeros as necessary. Together with COEF, an integer array JCOEF(1:n,1:Nd)
must be stored which contains the column positions of each entry in COEF.
Example 3.9. Thus, for the matrix of the previous example, the Ellpack-Itpack
storage scheme is

COEF =

1.
3.
6.
9.
11

2.
4.
7.
10.
12.

0.
5.
8.
0.
0.

JCOEF =

1
1
2
3
4

3
2
3
4
5

1
4
5 .
4
5

A certain column number must be chosen for each of the zero elements that must
be added to pad the shorter rows of A, i.e., rows 1, 4, and 5. In this example, those
integers are selected to be equal to the row numbers, as can be seen in the JCOEF
array. This is somewhat arbitrary, and in fact, any integer between 1 and n would be

3.5. BASIC SPARSE MATRIX OPERATIONS

95

acceptable. However, there may be good reasons for not inserting the same integers
too often, e.g. a constant number, for performance considerations.

3.5

Basic Sparse Matrix Operations

The matrix-by-vector product is an important operation which is required in most of
the iterative solution algorithms for solving sparse linear systems. This section shows
how these can be implemented for a small subset of the storage schemes considered
earlier.
The following FORTRAN 90 segment shows the main loop of the matrix-byvector operation for matrices stored in the Compressed Sparse Row stored format.
DO I=1, N
K1 = IA(I)
K2 = IA(I+1)-1
Y(I) = DOTPRODUCT(A(K1:K2),X(JA(K1:K2)))
ENDDO
Notice that each iteration of the loop computes a different component of the
resulting vector. This is advantageous because each of these components can be
computed independently. If the matrix is stored by columns, then the following code
could be used instead:
DO J=1, N
K1 = IA(J)
K2 = IA(J+1)-1
Y(JA(K1:K2)) = Y(JA(K1:K2))+X(J)*A(K1:K2)
ENDDO
In each iteration of the loop, a multiple of the j-th column is added to the result,
which is assumed to have been initially set to zero. Notice now that the outer loop
is no longer parallelizable. An alternative to improve parallelization is to try to split
the vector operation in each inner loop. The inner loop has few operations, in general, so this is unlikely to be a sound approach. This comparison demonstrates that
data structures may have to change to improve performance when dealing with high
performance computers.
Now consider the matrix-by-vector product in diagonal storage.
DO J=1, NDIAG
JOFF = IOFF(J)
DO I=1, N
Y(I) = Y(I) +DIAG(I,J)*X(JOFF+I)
ENDDO
ENDDO

96

CHAPTER 3. SPARSE MATRICES

Here, each of the diagonals is multiplied by the vector x and the result added to
the vector y. It is again assumed that the vector y has been filled with zeros at the
start of the loop. From the point of view of parallelization and/or vectorization, the
above code is probably the better to use. On the other hand, it is not general enough.
Solving a lower or upper triangular system is another important “kernel” in
sparse matrix computations. The following segment of code shows a simple routine for solving a unit lower triangular system Lx = y for the CSR storage format.
X(1) = Y(1)
DO I = 2, N
K1 = IAL(I)
K2 = IAL(I+1)-1
X(I)=Y(I)-DOTPRODUCT(AL(K1:K2),X(JAL(K1:K2)))
ENDDO
At each step, the inner product of the current solution x with the i-th row is computed
and subtracted from y(i). This gives the value of x(i). The dotproduct function
computes the dot product of two arbitrary vectors u(k1:k2) and v(k1:k2). The
vector AL(K1:K2) is the i-th row of the matrix L in sparse format and X(JAL(K1:K2))
is the vector of the components of X gathered into a short vector which is consistent
with the column indices of the elements in the row AL(K1:K2).

3.6

Sparse Direct Solution Methods

Most direct methods for sparse linear systems perform an LU factorization of the
original matrix and try to reduce cost by minimizing fill-ins, i.e., nonzero elements
introduced during the elimination process in positions which were initially zeros.
The data structures employed are rather complicated. The early codes relied heavily
on linked lists which are convenient for inserting new nonzero elements. Linkedlist data structures were dropped in favor of other more dynamic schemes that leave
some initial elbow room in each row for the insertions, and then adjust the structure
as more fill-ins are introduced.
A typical sparse direct solution solver for positive definite matrices consists of
four phases. First, preordering is applied to reduce fill-in. Two popular methods
are used: minimum degree ordering and nested-dissection ordering. Second, a symbolic factorization is performed. This means that the factorization is processed only
symbolically, i.e., without numerical values. Third, the numerical factorization, in
which the actual factors L and U are formed, is processed. Finally, the forward and
backward triangular sweeps are executed for each different right-hand side. In a code
where numerical pivoting is necessary, the symbolic phase cannot be separated from
the numerical factorization.

3.6. SPARSE DIRECT SOLUTION METHODS

3.6.1

97

Minimum degree ordering

The minimum degree (MD) algorithm is perhaps the most popular strategy for minimizeing fill-in in sparse Gaussian elimination, specifically for SPD matrices. At a
given step of Gaussian elimination, this strategy selects the node with the smallest
degree as the next pivot row. This will tend to reduce fill-in. To be exact, it will
minimize (locally) an upper bound for the number of fill-ins that will be introduced
at the corrresponding step of Gaussian Elimination.
In contrast with the Cuthill McKee ordering, minimum degree ordering does not
have, nor does it attempt to have, a banded structure. While the algorithm is excellent
for sparse direct solvers, it has been observed that it does not perform as the RCM
ordering when used in conjunction with preconditioning (Chapter 10).
The Multiple Minimum Degree algorithm is a variation due to Liu [204, 143]
which exploits independent sets of pivots at each step. Degrees of nodes adjacent
to any vertex in the independent set are updated only after all vertices in the set are
processed.

3.6.2

Nested Dissection ordering

Nested dissection is used primarily to reduce fill-in in sparse direct solvers for Symmetric Positive Definite matrices. The technique is easily described with the help
of recursivity and by exploiting the concept of ‘separators’. A set S of vertices in a
graph is called a separator if the removal of S results in the graph being split in two
disjoint subgraphs. For example, each of the intermediate levels in the BFS algorithm
is in fact a separator. The nested dissection algorithm can be succinctly described by
the following algorithm
A LGORITHM 3.7 ND(G, nmin)

1.
2.
3.
4.
5.
6.
7.
8.
9.

If |V | ≤ nmin
label nodes of V
Else
Find a separator S for V
Label the nodes of S
Split V into GL , GR by removing S
ND(GL , nmin)
ND(GR , nmin)
End

The labeling of the nodes in Lines 2 and 5, usually proceeds in sequence, so for
example, in Line 5, the nodes of S are labeled in a certain order, starting from the
last labeled node so far in the procedure. The main step of the ND procedure is to
separate the graph in three parts, two of which have no coupling between each other.
The third set has couplings with vertices from both of the first sets and is referred to
as a sepator. The key idea is to separate the graph in this way and then repeat the

CHAPTER 3. SPARSE MATRICES

98

process recursively in each subgraph. The nodes of the separator are numbered last.
An illustration is shown in 3.11.

1
6

7

2
5

3

4

Figure 3.11: Nested dissection ordering and corresponding reordered matrix

3.7

Test Problems

For comparison purposes it is important to use a common set of test matrices that
represent a wide spectrum of applications. There are two distinct ways of providing
such data sets. The first approach is to collect sparse matrices in a well-specified
standard format from various applications. This approach is used in the HarwellBoeing collection of test matrices. The second approach is to generate these matrices
with a few sample programs such as those provided in the SPARSKIT library [245].
The coming chapters will use examples from these two sources. In particular, five
test problems will be emphasized for their varying degrees of difficulty.
The SPARSKIT package can generate matrices arising from the discretization of
the two- or three-dimensional Partial Differential Equations






∂u
∂
∂u
∂
∂u
∂
a
−
b
−
c
−
∂x
∂x
∂y
∂y
∂z
∂z
∂ (du) ∂ (eu) ∂ (f u)
+
+
+
+ gu = h
∂x
∂y
∂z
on rectangular regions with general mixed-type boundary conditions. In the test
problems, the regions are the square Ω = (0, 1)2 , or the cube Ω = (0, 1)3 ; the
Dirichlet condition u = 0 is always used on the boundary. Only the discretized matrix is of importance, since the right-hand side will be created artificially. Therefore,
the right-hand side, h, is not relevant.

3.7. TEST PROBLEMS

99

✻

a(x, y) = b(x, y) = 1
3
4

a(x, y) =
b(x, y) =
103
1
4

✲
1
4

3
4

Figure 3.12: Physical domain and coefficients for Problem 2.
Problem 1: F2DA. In the first test problem which will be labeled F2DA, the
domain is two-dimensional, with
a(x, y) = b(x, y) = 1.0
and
d(x, y) = γ(x + y),

e(x, y) = γ(x − y),

f (x, y) = g(x, y) = 0.0,

(3.4)

where the constant γ is equal to 10. If the number of points in each direction is 34,
then there are nx = ny = 32 interior points in each direction and a matrix of size
n = nx × ny = 322 = 1024 is obtained. In this test example, as well as the other
ones described below, the right-hand side is generated as
b = Ae,
in which e = (1, 1, . . . , 1)T . The initial guess is always taken to be a vector of
pseudo-random values.
Problem 2: F2DB. The second test problem is similar to the previous one but
involves discontinuous coefficient functions a and b. Here, nx = ny = 32 and the
functions d, e, f, g are also defined by (3.4). However, the functions a and b now
both take the value 1,000 inside the subsquare of width 12 centered at ( 21 , 12 ), and one
elsewhere in the domain, i.e.,
 3
10 if 14 < x, y < 43
.
a(x, y) = b(x, y) =
1
otherwise
The domain and coefficients for this problem are shown is Figure 3.12.

CHAPTER 3. SPARSE MATRICES

100

Problem 3: F3D. The third test problem is three-dimensional with nx = ny =
nz = 16 internal mesh points in each direction leading to a problem of size n =
4096. In this case, we take
a(x, y, z) = b(x, y, z) = c(x, y, z) = 1
d(x, y, z) = γexy ,

e(x, y, z) = γe−xy ,

and
f (x, y, z) = g(x, y, z) = 0.0.
The constant γ is taken to be equal to 10.0 as before.
The Harwell-Boeing collection is a large data set consisting of test matrices
which have been contributed by researchers and engineers from many different disciplines. These have often been used for test purposes in the literature [108]. The
collection provides a data structure which constitutes an excellent medium for exchanging matrices. The matrices are stored as ASCII files with a very specific format consisting of a four- or five-line header. Then, the data containing the matrix
is stored in CSC format together with any right-hand sides, initial guesses, or exact
solutions when available. The SPARSKIT library also provides routines for reading
and generating matrices in this format.
Only one matrix from the collection was selected for testing the algorithms described in the coming chapters. The matrices in the last two test examples are both
irregularly structured.
Problem 4: ORS The matrix selected from the Harwell-Boeing collection is
ORSIRR1. This matrix arises from a reservoir engineering problem. Its size is
n = 1030 and it has a total of N z =6,858 nonzero elements. The original problem is based on a 21 × 21 × 5 irregular grid. In this case and the next one, the
matrices are preprocessed by scaling their rows and columns.
Problem 5: FID This test matrix is extracted from the well known fluid flow
simulation package FIDAP [120]. It is actually the test example number 36 from this
package and features a two-dimensional Chemical Vapor Deposition in a Horizontal
Reactor. The matrix has a size of n = 3079 and has N z = 53843 nonzero elements.
It has a symmetric pattern and few diagonally dominant rows or columns. The rows
and columns are prescaled in the same way as in the previous example. Figure 3.13
shows the patterns of the matrices ORS and FID.

P ROBLEMS
P-3.1 Consider the mesh of a discretized PDE. In which situations is the graph representing
this mesh the same as the adjacency graph of the matrix? Give examples from both Finite
Difference and Finite Element discretizations.

3.7. TEST PROBLEMS

101

Figure 3.13: Patterns of the matrices ORS (left) and FID (right).
P-3.2 Let A and B be two sparse (square) matrices of the same dimension. How can the
graph of C = A + B be characterized with respect to the graphs of A and B?
P-3.3 Consider the matrix defined as
Pπ = Iπ,∗ .
Show directly (without using Proposition 3.2 or interchange matrices) that the following three
relations hold

P-3.4 Consider the two matrices

⋆ ⋆ 0 ⋆
0 ⋆ 0 0

0 ⋆ ⋆ 0
A=
0 ⋆ 0 0

0 0 0 0
0 0 0 0

Aπ,∗
I∗,π

= Iπ,∗ A
= PπT

APπT

= A∗,π .

0
0
0
⋆
⋆
0


0
⋆

0

0

0
⋆



⋆
⋆

0
B=
⋆

0
0

where a ⋆ represents an arbitrary nonzero element.

0
0
⋆
⋆
⋆
0

0
⋆
0
0
0
⋆

0
0
0
0
⋆
0

0
⋆
0
0
⋆
0


0
0

0

0

0
⋆

a. Show the adjacency graphs of the matrices A, B, AB, and BA. (Assume that there
are no numerical cancellations in computing the products AB and BA). Since there
are zero diagonal elements, represent explicitly the cycles corresponding to the (i, i)
edges when they are present.
b. Consider the matrix C = AB. Give an interpretation of an edge in the graph of C in
terms of edges in the graph of A and B. Verify this answer using the above matrices.
c. Consider the particular case in which B = A. Give an interpretation of an edge in the
graph of C in terms of paths of length two in the graph of A. The paths must take into
account the cycles corresponding to nonzero diagonal elements of A.

CHAPTER 3. SPARSE MATRICES

102

d. Now consider the case where B = A2 . Give an interpretation of an edge in the graph
of C = A3 in terms of paths of length three in the graph of A. Generalize the result to
arbitrary powers of A.
P-3.5 Consider two matrices A and B of dimension n × n, whose diagonal elements are all
nonzeros. Let EX denote the set of edges in the adjacency graph of a matrix X (i.e., the set
of pairs (i, j) such Xij 6= 0), then show that
EAB ⊃ EA ∪ EB .
Give extreme examples when |EAB | = n2 while EA ∪ EB is of order n. What practical
implications does this have on ways to store products of sparse matrices (Is it better so store
the product AB or the pairs A, B separately? Consider both the computational cost for
performing matrix-vector products and the cost of memory)
P-3.6 Consider a 6 × 6 matrix which has the pattern

⋆ ⋆
⋆
⋆ ⋆ ⋆

⋆ ⋆

A=
⋆ ⋆


⋆
⋆ ⋆
⋆
⋆
a. Show the adjacency graph of A.



⋆


.


⋆
⋆

b. Consider the permutation π = {1, 3, 4, 2, 5, 6}. Show the adjacency graph and new
pattern for the matrix obtained from a symmetric permutation of A based on the permutation array π.
P-3.7 You are given an 8 matrix which has the following pattern:


x x
x
x x
x x x



x x x
x




x x x




x x x




x x
x x x




x
x x x
x
x x
a. Show the adjacency graph of A ;

b. Find the Cuthill Mc Kee ordering for the matrix (break ties by giving priority to the
node with lowest index). Show the graph of the matrix permuted according to the
Cuthill-Mc Kee ordering.
c. What is the Reverse Cuthill Mc Kee ordering for this case? Show the matrix reordered
according to the reverse Cuthill Mc Kee ordering.
d. Find a multicoloring of the graph using the greedy multicolor algorithm. What is the
minimum number of colors required for multicoloring the graph?
e. Consider the variation of the Cuthill Mc-Kee ordering in which the first level L0 consists of several vertices instead on only one vertex. Find the Cuthill Mc Kee ordering
with this variant with the starting level L0 = {1, 8}.

3.7. TEST PROBLEMS
P-3.8 Consider a matrix which has the pattern

⋆ ⋆
⋆ ⋆ ⋆

⋆ ⋆ ⋆


⋆ ⋆

A=
⋆
⋆

⋆


⋆
⋆
⋆

103

⋆

⋆
⋆





⋆
.


⋆


⋆ ⋆
⋆ ⋆
⋆

⋆
⋆ ⋆
⋆ ⋆
⋆



a. Show the adjacency graph of A. (Place the 8 vertices on a circle.)

b. Consider the permutation π = {1, 3, 5, 7, 2, 4, 6, 8}. Show the adjacency graph and
new pattern for the matrix obtained from a symmetric permutation of A based on the
permutation array π.
c. Show the adjacency graph and new pattern for the matrix obtained from a reverse
Cuthill-McKee ordering of A starting with the node 1. (Assume the vertices adjacent
to a given vertex are always listed in increasing order in the data structure that describes
the graph.)
d. Find a multicolor ordering for A (give the vertex labels color 1, followed by those for
color 2, etc.).
P-3.9 Given a five-point finite difference graph, show that the greedy algorithm will always
find a coloring of the graph with two colors.
P-3.10 Prove that the total number of colors found by the greedy multicoloring algorithm
does not exceed νmax + 1, where νmax is the maximum degree of all the vertices of a graph
(not counting the cycles (i, i) associated with diagonal elements).
P-3.11 Consider a graph that is bipartite, i.e., 2-colorable. Assume that the vertices of the
graph are colored by a variant of Algorithm (3.6), in which the nodes are traversed in a certain
order i1 , i2 , . . . , in .
a. Is it true that for any permutation i1 , . . . , in the number of colors found will be two?
b. Consider now a permutation satisfying the following property: for each j at least one
of the nodes i1 , i2 , . . . , ij−1 is adjacent to ij . Show that the algorithm will find a
2-coloring of the graph.
c. Among the following traversals indicate which ones satisfy the property of the previous
question: (1) Breadth-First Search, (2) random traversal, (3) traversal defined by ij =
any node adjacent to ij−1 .
P-3.12 Given a matrix that is irreducible and with a symmetric pattern, show that its structural inverse is dense. Structural inverse means the pattern of the inverse, regardless of the
values, or otherwise stated, is the union of all patterns of the inverses for all possible values. [Hint: Use Cayley Hamilton’s theorem and a well known result on powers of adjacency
matrices mentioned at the end of Section 3.2.1.]
P-3.13 The most economical storage scheme in terms of memory usage is the following
variation on the coordinate format: Store all nonzero values aij in a real array AA[1 : N z]
and the corresponding “linear array address” (i−1)∗n+j in an integer array JA[1 : N z]. The
order in which these corresponding entries are stored is unimportant as long as they are both
in the same position in their respective arrays. What are the advantages and disadvantages of

104

CHAPTER 3. SPARSE MATRICES

this data structure? Write a short routine for performing a matrix-by-vector product in this
format.
P-3.14 Write a FORTRAN-90 or C code segment to perform the matrix-by-vector product
for matrices stored in Ellpack-Itpack format.
P-3.15 Write a small subroutine to perform the following operations on a sparse matrix in
coordinate format, diagonal format, and CSR format:
a. Count the number of nonzero elements in the main diagonal;
b. Extract the diagonal whose offset is k;
c. Add a nonzero element in position (i, j) of the matrix (this position may initially contain a zero or a nonzero element);
d. Add a given diagonal to the matrix. What is the most convenient storage scheme for
each of these operations?
P-3.16 Linked lists is another popular scheme often used for storing sparse matrices. These
allow to link together k data items (e.g., elements of a given row) in a large linear array. A
starting position is given in the array which contains the first element of the set. Then, a link
to the next element in the array is provided from a LINK array.
a. Show how to implement this scheme. A linked list is to be used for each row.
b. What are the main advantages and disadvantages of linked lists?
c. Write an algorithm to perform a matrix-by-vector product in this format.
N OTES AND R EFERENCES . Two good references on sparse matrix computations are the book by
George and Liu [144] and the more recent volume by Duff, Erisman, and Reid [107]. These are geared
toward direct solution methods and the first specializes in symmetric positive definite problems. Also
of interest are [221] and [227] and the early survey by Duff [106].
Sparse matrix techniques have traditionally been associated with direct solution methods. This
has changed in the last decade because of the increased need to solve three-dimensional problems. The
SPARSKIT library, a package for sparse matrix computations [245] is available from the author at:
http://www.cs.umn.edu/ saad/software .
Another available software package which emphasizes object-oriented design with the goal of hiding
complex data structures from users is PETSc [24].
The idea of the greedy multicoloring algorithm is known in Finite Element techniques (to color
elements); see, e.g., Benantar and Flaherty [31]. Wu [319] presents the greedy algorithm for multicoloring vertices and uses it for SOR type iterations, see also [248]. The effect of multicoloring has been
extensively studied by Adams [2, 3] and Poole and Ortega [228]. Interesting results regarding multicoloring in the context of finite elements based on quad-tree structures have been obtained by Benantar
and Flaherty [31] who show, in particular, that with this structure a maximum of six colors is required.

Chapter 4

BASIC ITERATIVE METHODS

The first iterative methods used for solving large linear systems were based on relaxation of the
coordinates. Beginning with a given approximate solution, these methods modify the components of the approximation, one or a few at a time and in a certain order, until convergence is
reached. Each of these modifications, called relaxation steps, is aimed at annihilating one or a
few components of the residual vector. Now, these techniques are rarely used separately. However, when combined with the more efficient methods described in later chapters, they can be
quite successful. Moreover, there are a few application areas where variations of these methods
are still quite popular.

4.1

Jacobi, Gauss-Seidel, and SOR

This chapter begins by reviewing the basic iterative methods for solving linear systems. Given an n × n real matrix A and a real n-vector b, the problem considered is:
Find x belonging to Rn such that
Ax = b

(4.1)

Equation (4.1) is a linear system, A is the coefficient matrix, b is the right-hand
side vector, and x is the vector of unknowns. Most of the methods covered in
this chapter involve passing from one iterate to the next by modifying one or a few
components of an approximate vector solution at a time. This is natural since there
are simple criteria when modifying a component in order to improve an iterate. One
example is to annihilate some component(s) of the residual vector b − Ax. The
convergence of these methods is rarely guaranteed for all matrices, but a large body of
theory exists for the case where the coefficient matrix arises from the finite difference
discretization of Elliptic Partial Differential Equations.
We begin with the decomposition
A = D − E − F,

105

(4.2)

CHAPTER 4. BASIC ITERATIVE METHODS

106

in which D is the diagonal of A, −E its strict lower part, and −F its strict upper
part, as illustrated in Figure 4.1. It is always assumed that the diagonal entries of A
are all nonzero.

−F
D
−E

Figure 4.1: Initial partitioning of matrix A.
The Jacobi iteration determines the i-th component of the next approximation
(k)
so as to annihilate the i-th component of the residual vector. In the following, ξi
denotes the i-th component of the iterate xk and βi the i-th component of the righthand side b. Thus, writing
(b − Axk+1 )i = 0,
(4.3)
in which (y)i represents the i-th component of the vector y, yields
(k+1)

aii ξi
or
(k+1)

ξi

=



=−

n
X

(k)

aij ξj

+ βi ,

j=1
j6=i

n
X



1 
(k) 
aij ξj 
βi −
aii
j=1

i = 1, . . . , n.

(4.4)

j6=i

This is a component-wise form of the Jacobi iteration. All components of the next
iterate can be grouped into the vector xk+1 . The above notation can be used to rewrite
the Jacobi iteration (4.4) in vector form as
xk+1 = D −1 (E + F )xk + D −1 b.

(4.5)

Similarly, the Gauss-Seidel iteration corrects the i-th component of the current
approximate solution, in the order i = 1, 2, . . . , n, again to annihilate the i-th component of the residual. However, this time the approximate solution is updated immediately after the new component is determined. The newly computed components

4.1. JACOBI, GAUSS-SEIDEL, AND SOR

107

(k)

ξi , i = 1, 2, . . . , n can be changed within a working vector which is redefined at
each relaxation step. Thus, since the order is i = 1, 2, . . ., the result at the i-th step is
βi −

i−1
X

(k+1)

aij ξj

j=1

(k+1)

− aii ξi

−

n
X

(k)

aij ξj

= 0,

which leads to the iteration,


n
i−1
X
X
1 
(k+1)
(k)
(k+1)
ξi
=
aij ξj + βi  , i = 1, . . . , n.
aij ξj
−
−
aii
j=1

(4.6)

j=i+1

(4.7)

j=i+1

The defining equation (4.6) can be written as

b + Exk+1 − Dxk+1 + F xk = 0,
which leads immediately to the vector form of the Gauss-Seidel iteration
xk+1 = (D − E)−1 F xk + (D − E)−1 b.

(4.8)

Computing the new approximation in (4.5) requires multiplying by the inverse
of the diagonal matrix D. In (4.8) a triangular system must be solved with D − E,
the lower triangular part of A. Thus, the new approximation in a Gauss-Seidel step
can be determined either by solving a triangular system with the matrix D − E or
from the relation (4.7).
A backward Gauss-Seidel iteration can also be defined as
(D − F )xk+1 = Exk + b,

(4.9)

which is equivalent to making the coordinate corrections in the order n, n − 1, . . . , 1.
A Symmetric Gauss-Seidel Iteration consists of a forward sweep followed by a backward sweep.
The Jacobi and the Gauss-Seidel iterations are both of the form
M xk+1 = N xk + b = (M − A)xk + b,

(4.10)

A=M −N

(4.11)

in which
is a splitting of A, with M = D for Jacobi, M = D − E for forward Gauss-Seidel,
and M = D − F for backward Gauss-Seidel. An iterative method of the form
(4.10) can be defined for any splitting of the form (4.11) where M is nonsingular.
Overrelaxation is based on the splitting
ωA = (D − ωE) − (ωF + (1 − ω)D),
and the corresponding Successive Over Relaxation (SOR) method is given by the
recursion
(D − ωE)xk+1 = [ωF + (1 − ω)D]xk + ωb.
(4.12)

CHAPTER 4. BASIC ITERATIVE METHODS

108

The above iteration corresponds to the relaxation sequence
(k+1)

ξi

(k)

= ωξiGS + (1 − ω)ξi , i = 1, 2, . . . , n,

in which ξiGS is defined by the expression in the right-hand side of (4.7). A backward
SOR sweep can be defined analogously to the backward Gauss-Seidel sweep (4.9).
A Symmetric SOR (SSOR) step consists of the SOR step (4.12) followed by a
backward SOR step,
(D − ωE)xk+1/2 = [ωF + (1 − ω)D]xk + ωb

(D − ωF )xk+1 = [ωE + (1 − ω)D]xk+1/2 + ωb

This gives the recurrence
xk+1 = Gω xk + fω ,
where
Gω = (D − ωF )−1 (ωE + (1 − ω)D) ×

(D − ωE)−1 (ωF + (1 − ω)D),
−1

fω = ω(D − ωF )

(4.13)
−1

I + [ωE + (1 − ω)D](D − ωE)

Observing that



b.

(4.14)

[ωE + (1 − ω)D](D − ωE)−1 = [−(D − ωE) + (2 − ω)D](D − ωE)−1
= −I + (2 − ω)D(D − ωE)−1 ,

fω can be rewritten as
fω = ω(2 − ω) (D − ωF )−1 D(D − ωE)−1 b.

4.1.1

Block Relaxation Schemes

Block relaxation schemes are generalizations of the “point” relaxation schemes described above. They update a whole set of components at each time, typically a
subvector of the solution vector, instead of only one component. The matrix A and
the right-hand side and solution vectors are partitioned as follows:


 
 
A11 A12 A13 · · · A1p
ξ1
β1
 A21 A22 A23 · · · A2p 
 ξ2 
 β2 


 
 
A31 A32 A33 · · · A3p  , x =  ξ3  , b =  β3  ,
A=
(4.15)
 .
 . 
 . 
..
..
.. 
..
 ..





.
.
.
.
.
.
.
.
ξp
βp
Ap1 Ap2 · · · · · · App

in which the partitionings of b and x into subvectors βi and ξi are identical and
compatible with the partitioning of A. Thus, for any vector x partitioned as in (4.15),
(Ax)i =

p
X
j=1

Aij ξj ,

4.1. JACOBI, GAUSS-SEIDEL, AND SOR

109

in which (y)i denotes the i-th component of the vector i according to the above
partitioning. The diagonal blocks in A are square and assumed nonsingular.
Now define, similarly to the scalar case, the splitting
A=D−E−F
with



O
 A21
E = −
 ...

Ap1

A22


D=




O
..
.
Ap2



..

.
···



A11

O


,


..


,


.

App

O

F = −


A12
O

(4.16)

···
···
..
.


A1p
A2p 
.
.. 
. 
O

With these definitions, it is easy to generalize the previous three iterative procedures
defined earlier, namely, Jacobi, Gauss-Seidel, and SOR. For example, the block Ja(k)
cobi iteration is now defined as a technique in which the new subvectors ξi are all
replaced according to
(k+1)

Aii ξi
or,

(k+1)

ξi

= ((E + F )xk )i + βi

−1
= A−1
ii ((E + F )xk )i + Aii βi ,

i = 1, . . . , p,

which leads to the same equation as before,
xk+1 = D −1 (E + F )xk + D −1 b,
except that the meanings of D, E, and F have changed to their block analogues.
With finite difference approximations of PDEs, it is standard to block the variables and the matrix by partitioning along whole lines of the mesh. For example, for
the two-dimensional mesh illustrated in Figure 2.5, this partitioning is



u11
 u12 



ξ1 = 
 u13  ,
 u14 
u15




u21
 u22 



ξ2 = 
 u23  ,
 u24 
u25




u31
 u32 



ξ3 = 
 u33  .
 u34 
u35

This corresponds to the mesh 2.5 of Chapter 2, whose associated matrix pattern is
shown in Figure 2.6. A relaxation can also be defined along the vertical instead
of the horizontal lines. Techniques of this type are often known as line relaxation
techniques.

CHAPTER 4. BASIC ITERATIVE METHODS

110

In addition, a block can also correspond to the unknowns associated with a few
consecutive lines in the plane. One such blocking is illustrated in Figure 4.2 for a
6 × 6 grid. The corresponding matrix with its block structure is shown in Figure 4.3.
An important difference between this partitioning and the one corresponding to the
single-line partitioning is that now the matrices Aii are block-tridiagonal instead of
tridiagonal. As a result, solving linear systems with Aii may be much more expensive. On the other hand, the number of iterations required to achieve convergence
often decreases rapidly as the block-size increases.
31

32

33

34

35

36

25

26

27

28

29

30

19

20

21

22

23

24

13

14

15

16

17

18

7

8

9

10

11

12

1

2

3

4

5

6

Figure 4.2: Partitioning of a 6 × 6 square mesh into three subdomains.

Figure 4.3: Matrix associated with the mesh of Figure 4.2.
Finally, block techniques can be defined in more general terms. First, by using
blocks that allow us to update arbitrary groups of components, and second, by allowing the blocks to overlap. Since this is a form of the domain-decomposition method
which will be seen later, we define the approach carefully. So far, our partition has

4.1. JACOBI, GAUSS-SEIDEL, AND SOR

111

been based on an actual set-partition of the variable set S = {1, 2, . . . , n} into subsets S1 , S2 , . . . , Sp , with the condition that two distinct subsets are disjoint. In set
theory, this is called a partition of S. More generally, a set-decomposition of S
removes the constraint of disjointness. In other words it is required that the union of
the subsets Si ’s be equal to S:
[
Si ⊆ S,
Si = S.
i=1,···,p

In the following, ni denotes the size of Si and the subset Si is of the form,
Si = {mi (1), mi (2), . . . mi (ni )}.
A general block Jacobi iteration can be defined as follows. Let Vi be the n × ni
matrix
Vi = [emi (1) , emi (2) , . . . emi (ni ) ]
and
Wi = [ηmi (1) emi (1) , ηmi (2) emi (2) , . . . , ηmi (ni ) emi (ni ) ],
where each ej is the j-th column of the n × n identity matrix, and ηmi (j) represents
a weight factor chosen so that
WiT Vi = I.
When there is no overlap, i.e., when the Si ’s form a partition of the whole set
{1, 2, . . . , n}, then define ηmi (j) = 1.
Let Aij be the ni × nj matrix
Aij = WiT AVj
and define similarly the partitioned vectors
ξi = WiT x,

βi = WiT b.

Note that Vi WiT is a projector from Rn to the subspace Ki spanned by the columns
mi (1), . . . , mi (ni ). In addition, we have the relation
x=

s
X

Vi ξi .

i=1

The ni -dimensional vector WiT x represents the projection Vi WiT x of x with respect
to the basis spanned by the columns of Vi . The action of Vi performs the reverse operation. That means Vi y is an extension operation from a vector y in Ki (represented
in the basis consisting of the columns of Vi ) into a vector Vi y in Rn . The operator
WiT is termed a restriction operator and Vi is an prolongation operator.
Each component of the Jacobi iteration can be obtained by imposing the condition that the projection of the residual in the span of Si be zero, i.e.,



X
WiT b − A Vi WiT xk+1 +
Vj WjT xk  = 0.
j6=i

CHAPTER 4. BASIC ITERATIVE METHODS

112

Remember that ξj = WjT x, which can be rewritten as
(k+1)

ξi

(k)

= ξi

T
+ A−1
ii Wi (b − Axk ).

(4.17)

This leads to the following algorithm:
A LGORITHM 4.1 General Block Jacobi Iteration

1.
2.
3.
4.
5.
6.

For k = 0, 1, . . . , until convergence Do:
For i = 1, 2, . . . , p Do:
Solve Aii δi = WiT (b − Axk )
Set xk+1 := xk + Vi δi
EndDo
EndDo

As was the case with the scalar algorithms, there is only a slight difference between the Jacobi and Gauss-Seidel iterations. Gauss-Seidel immediately updates the
component to be corrected at step i, and uses the updated approximate solution to
compute the residual vector needed to correct the next component. However, the Jacobi iteration uses the same previous approximation xk for this purpose. Therefore,
the block Gauss-Seidel iteration can be defined algorithmically as follows:
A LGORITHM 4.2 General Block Gauss-Seidel Iteration

1.
2.
3.
4.
5.
6.

Until convergence Do:
For i = 1, 2, . . . , p Do:
Solve Aii δi = WiT (b − Ax)
Set x := x + Vi δi
EndDo
EndDo

From the point of view of storage, Gauss-Seidel is more economical because the new
approximation can be overwritten over the same vector. Also, it typically converges
faster. On the other hand, the Jacobi iteration has some appeal on parallel computers
since the second Do loop, corresponding to the p different blocks, can be executed in
parallel. Although the point Jacobi algorithm by itself is rarely a successful technique
for real-life problems, its block Jacobi variant, when using large enough overlapping
blocks, can be quite attractive especially in a parallel computing environment.

4.1.2

Iteration Matrices and Preconditioning

The Jacobi and Gauss-Seidel iterations are of the form
xk+1 = Gxk + f,

(4.18)

in which
GJA (A) = I − D −1 A,

(4.19)
−1

GGS (A) = I − (D − E)

A,

(4.20)

4.1. JACOBI, GAUSS-SEIDEL, AND SOR

113

for the Jacobi and Gauss-Seidel iterations, respectively. Moreover, given the matrix
splitting
A = M − N,
(4.21)
where A is associated with the linear system (4.1), a linear fixed-point iteration can
be defined by the recurrence
xk+1 = M −1 N xk + M −1 b,

(4.22)

which has the form (4.18) with
G = M −1 N = M −1 (M − A) = I − M −1 A,

f = M −1 b.

(4.23)

For example, for the Jacobi iteration, M = D, N = D − A, while for the GaussSeidel iteration, M = D − E, N = M − A = F .
The iteration xk+1 = Gxk + f can be viewed as a technique for solving the
system
(I − G)x = f.
Since G has the form G = I − M −1 A, this system can be rewritten as
M −1 Ax = M −1 b.
The above system which has the same solution as the original system is called a preconditioned system and M is the preconditioning matrix or preconditioner. In other
words, a relaxation scheme is equivalent to a fixed-point iteration on a preconditioned system.
For example, for the Jacobi, Gauss-Seidel, SOR, and SSOR iterations, these
preconditioning matrices are, respectively,
MJA = D,
MGS
MSOR
MSSOR

= D − E,
1
(D − ωE),
=
ω
1
=
(D − ωE)D −1 (D − ωF ).
ω(2 − ω)

(4.24)
(4.25)
(4.26)
(4.27)

Thus, the Jacobi preconditioner is simply the diagonal of A, while the Gauss-Seidel
preconditioner is the lower triangular part of A. The constant coefficients in front of
the matrices MSOR and MSSOR only have the effect of scaling the equations of the
preconditioned system uniformly. Therefore, they are unimportant in the preconditioning context.
Note that the “preconditioned” system may be a full system. Indeed, there is
no reason why M −1 should be a sparse matrix (even though M may be sparse),
since the inverse of a sparse matrix is not necessarily sparse. This limits the number
of techniques that can be applied to solve the preconditioned system. Most of the
iterative techniques used only require matrix-by-vector products. In this case, to

CHAPTER 4. BASIC ITERATIVE METHODS

114

compute w = M −1 Av for a given vector v, first compute r = Av and then solve the
system M w = r:
r = Av,
w = M −1 r.
In some cases, it may be advantageous to exploit the splitting A = M − N and
compute w = M −1 Av as w = (I − M −1 N )v by the procedure
r

=

N v,

w

=

M −1 r,

w := v − w.
The matrix N may be sparser than A and the matrix-by-vector product N v may
be less expensive than the product Av. A number of similar but somewhat more
complex ideas have been exploited in the context of preconditioned iterative methods.
A few of these will be examined in Chapter 9.

4.2

Convergence

All the methods seen in the previous section define a sequence of iterates of the form
xk+1 = Gxk + f,

(4.28)

in which G is a certain iteration matrix. The questions addressed in this section are:
(a) if the iteration converges, then is the limit indeed a solution of the original system?
(b) under which conditions does the iteration converge? (c) when the iteration does
converge, how fast is it?
If the above iteration converges, its limit x satisfies
x = Gx + f.

(4.29)

In the case where the above iteration arises from the splitting A = M − N , it is easy
to see that the solution x to the above system is identical to that of the original system
Ax = b. Indeed, in this case the sequence (4.28) has the form
xk+1 = M −1 N xk + M −1 b
and its limit satisfies
M x = N x + b,
or Ax = b. This answers question (a). Next, we focus on the other two questions.

4.2. CONVERGENCE

4.2.1

115

General Convergence Result

If I − G is nonsingular then there is a solution x∗ to the equation (4.29). Subtracting
(4.29) from (4.28) yields
xk+1 − x∗ = G(xk − x∗ ) = · · · = Gk+1 (x0 − x∗ ).

(4.30)

Standard results seen in Chapter 1 imply that if the spectral radius of the iteration
matrix G is less than unity, then xk − x∗ converges to zero and the iteration (4.28)
converges toward the solution defined by (4.29). Conversely, the relation
xk+1 − xk = G(xk − xk−1 ) = · · · = Gk (f − (I − G)x0 ).
shows that if the iteration converges for any x0 and f then Gk v converges to zero for
any vector v. As a result, ρ(G) must be less than unity and the following theorem is
proved:
Theorem 4.1 Let G be a square matrix such that ρ(G) < 1. Then I − G is nonsingular and the iteration (4.28) converges for any f and x0 . Conversely, if the iteration
(4.28) converges for for any f and x0 , then ρ(G) < 1.
Since it is expensive to compute the spectral radius of a matrix, sufficient conditions
that guarantee convergence can be useful in practice. One such sufficient condition
could be obtained by utilizing the inequality, ρ(G) ≤ kGk, for any matrix norm.
Corollary 4.2 Let G be a square matrix such that kGk < 1 for some matrix norm
k.k. Then I − G is nonsingular and the iteration (4.28) converges for any initial
vector x0 .
Apart from knowing that the sequence (4.28) converges, it is also desirable to
know how fast it converges. The error dk = xk − x∗ at step k satisfies
dk = Gk d0 .
The matrix G can be expressed in the Jordan canonical form as G = XJX −1 .
Assume for simplicity that there is only one eigenvalue of G of largest modulus and
call it λ. Then
 k
J
k
X −1 d0 .
dk = λ X
λ

A careful look at the powers of the matrix J/λ shows that all its blocks, except the
block associated with the eigenvalue λ, converge to zero as k tends to infinity. Let
this Jordan block be of size p and of the form
Jλ = λI + E,

where E is nilpotent of index p, i.e., E p = 0. Then, for k ≥ p,
Jλk = (λI + E)k = λk (I + λ−1 E)k = λk

p−1
X
i=0

  !
k
λ−i
Ei .
i

116

CHAPTER 4. BASIC ITERATIVE METHODS

If k is large enough, then for any λ the dominant term in the above sum is the last
term, i.e.,


k
k−p+1
k
Jλ ≈ λ
E p−1 .
p−1

Thus, the norm of dk = Gk d0 has the asymptotical form


k
k−p+1
kdk k ≈ C × |λ
|
,
p−1

where C is some constant. The convergence factor of a sequence is the limit


kdk k 1/k
ρ = lim
.
k→∞ kd0 k
It follows from the above analysis that ρ = ρ(G). The convergence rate τ is the
(natural) logarithm of the inverse of the convergence factor
τ = − ln ρ.
The above definition depends on the initial vector x0 , so it may be termed a
specific convergence factor. A general convergence factor can also be defined by


kdk k 1/k
.
φ = lim maxn
k→∞ x0 ∈R kd0 k
This factor satisfies
1/k
kGk d0 k
φ = lim
max
k→∞
d0 ∈Rn kd0 k

1/k
= lim kGk k
= ρ(G).


k→∞

Thus, the global asymptotic convergence factor is equal to the spectral radius of
the iteration matrix G. The general convergence rate differs from the specific rate
only when the initial error does not have any components in the invariant subspace
associated with the dominant eigenvalue. Since it is hard to know this information in
advance, the general convergence factor is more useful in practice.
Example 4.1. Consider the simple example of Richardson’s Iteration,
xk+1 = xk + α (b − Axk ) ,

(4.31)

where α is a nonnegative scalar. This iteration can be rewritten as
xk+1 = (I − αA)xk + αb.

(4.32)

Thus, the iteration matrix is Gα = I − αA and the convergence factor is ρ(I − αA).
Assume that the eigenvalues λi , i = 1, . . . , n, are all real and such that,
λmin ≤ λi ≤ λmax .

4.2. CONVERGENCE

117

Then, the eigenvalues µi of Gα are such that
1 − αλmax ≤ µi ≤ 1 − αλmin .
In particular, if λmin < 0 and λmax > 0, at least one eigenvalue is > 1, and so
ρ(Gα ) > 1 for any α. In this case the method will always diverge for some initial
guess. Let us assume that all eigenvalues are positive, i.e., λmin > 0. Then, the
following conditions must be satisfied in order for the method to converge:
1 − αλmin < 1,

1 − αλmax > −1.
The first condition implies that α > 0, while the second requires that α ≤ 2/λmax .
In other words, the method converges for any scalar α which satisfies
0<α<

2
.
λmax

The next question is: What is the best value αopt for the parameter α, i.e., the value
of α which minimizes ρ(Gα )? The spectral radius of Gα is
ρ(Gα ) = max{|1 − αλmin |, |1 − αλmax |}.
This function of α is depicted in Figure 4.4. As the curve shows, the best possible α
is reached at the point where the curve |1 − λmax α| with positive slope crosses the
curve |1 − λmin α| with negative slope, i.e., when
−1 + λmax α = 1 − λmin α.
|1 − λmax α|

1

1

λmax αopt

1

|1 − λmin α|

α

λmin

Figure 4.4: The curve ρ(Gα ) as a function of α.
This gives
αopt =

2
.
λmin + λmax

(4.33)

CHAPTER 4. BASIC ITERATIVE METHODS

118

Replacing this in one of the two curves gives the corresponding optimal spectral
radius
λmax − λmin
ρopt =
.
λmax + λmin
This expression shows the difficulty with the presence of small and large eigenvalues.
The convergence rate can be extremely small for realistic problems. In addition, to
achieve good convergence, eigenvalue estimates are required in order to obtain the
optimal or a near-optimal α, and this may cause difficulties. Finally, since λmax can
be very large, the curve ρ(Gα ) can be extremely sensitive near the optimal value
of α. These observations are common to many iterative methods that depend on an
acceleration parameter.

4.2.2

Regular Splittings

Definition 4.3 Let A, M, N be three given matrices satisfying A = M − N . The
pair of matrices M, N is a regular splitting of A, if M is nonsingular and M −1 and
N are nonnegative.
With a regular splitting, we associate the iteration
xk+1 = M −1 N xk + M −1 b.

(4.34)

The question asked is: Under which conditions does such an iteration converge? The
following result, which generalizes Theorem 1.29, gives the answer.
Theorem 4.4 Let M, N be a regular splitting of a matrix A. Then ρ(M −1 N ) < 1 if
and only if A is nonsingular and A−1 is nonnegative.
Proof. Define G = M −1 N . From the fact that ρ(G) < 1, and the relation
A = M (I − G)

(4.35)

it follows that A is nonsingular. The assumptions of Theorem 1.29 are satisfied for
the matrix G since G = M −1 N is nonnegative and ρ(G) < 1. Therefore, (I − G)−1
is nonnegative as is A−1 = (I − G)−1 M −1 .
To prove the sufficient condition, assume that A is nonsingular and that its inverse
is nonnegative. Since A and M are nonsingular, the relation (4.35) shows again that
I − G is nonsingular and in addition,
−1
N
A−1 N = M (I − M −1 N )
= (I − M −1 N )−1 M −1 N
= (I − G)−1 G.

(4.36)

Clearly, G = M −1 N is nonnegative by the assumptions, and as a result of the
Perron-Frobenius theorem, there is a nonnegative eigenvector x associated with ρ(G)
which is an eigenvalue, such that
Gx = ρ(G)x.

4.2. CONVERGENCE

119

From this and by virtue of (4.36), it follows that
A−1 N x =

ρ(G)
x.
1 − ρ(G)

Since x and A−1 N are nonnegative, this shows that
ρ(G)
≥0
1 − ρ(G)

and this can be true only when 0 ≤ ρ(G) ≤ 1. Since I − G is nonsingular, then
ρ(G) 6= 1, which implies that ρ(G) < 1.
This theorem establishes that the iteration (4.34) always converges, if M, N is a
regular splitting and A is an M-matrix.

4.2.3

Diagonally Dominant Matrices

We begin with a few standard definitions.
Definition 4.5 A matrix A is
• (weakly) diagonally dominant if
|ajj | ≥

i=n
X
i=1
i6=j

|aij |,

j = 1, . . . , n.

|aij |,

j = 1, . . . , n.

• strictly diagonally dominant if
|ajj | >

i=n
X
i=1
i6=j

• irreducibly diagonally dominant if A is irreducible, and
|ajj | ≥

i=n
X
i=1
i6=j

|aij |,

j = 1, . . . , n.

with strict inequality for at least one j.
Often the term diagonally dominant is used instead of weakly diagonally dominant.
Diagonal dominance is related to an important result in Numerical Linear Algebra known as Gershgorin’s theorem. This theorem allows rough locations for all the
eigenvalues of A to be determined. In some situations, it is desirable to determine
these locations in the complex plane by directly exploiting some knowledge of the
entries of the matrix A. The simplest such result is the bound
|λi | ≤ kAk
for any matrix norm. Gershgorin’s theorem provides a more precise localization
result.

CHAPTER 4. BASIC ITERATIVE METHODS

120

Theorem 4.6 (Gershgorin) Any eigenvalue λ of a matrix A is located in one of the
closed discs of the complex plane centered at aii and having the radius
ρi =

j=n
X
j=1
j6=i

|aij |.

In other words,
∀ λ ∈ σ(A),

∃ i such that

|λ − aii | ≤

j=n
X
j=1
j6=i

|aij |.

(4.37)

Proof. Let x be an eigenvector associated with an eigenvalue λ, and let m be the
index of the component of largest modulus in x. Scale x so that |ξm | = 1, and
|ξi | ≤ 1, for i 6= m. Since x is an eigenvector, then
(λ − amm )ξm = −
which gives
|λ − amm | ≤

n
X
j=1
j6=m

n
X

amj ξj ,

j=1
j6=m

|amj ||ξj | ≤

n
X
j=1
j6=m

|amj | = ρm .

(4.38)

This completes the proof.
Since the result also holds for the transpose of A, a version of the theorem can also
be formulated based on column sums instead of row sums.
The n discs defined in the theorem are called Gershgorin discs. The theorem
states that the union of these n discs contains the spectrum of A. It can also be
shown that if there are m Gershgorin discs whose union S is disjoint from all other
discs, then S contains exactly m eigenvalues (counted with their multiplicities). For
example, when one disc is disjoint from the others, then it must contain exactly one
eigenvalue.
An additional refinement which has important consequences concerns the particular case when A is irreducible.
Theorem 4.7 Let A be an irreducible matrix, and assume that an eigenvalue λ of
A lies on the boundary of the union of the n Gershgorin discs. Then λ lies on the
boundary of all Gershgorin discs.
Proof. As in the proof of Gershgorin’s theorem, let x be an eigenvector associated
with λ, with |ξm | = 1, and |ξi | ≤ 1, for i 6= m. Start from equation (4.38) in the
proof of Gershgorin’s theorem which states that the point λ belongs to the m-th disc.
In addition, λ belongs to the boundary of the union of all the discs. As a result, it

4.2. CONVERGENCE

121

cannot be an interior point to the disc D(λ, ρm ). This implies that |λ − amm | = ρm .
Therefore, the inequalities in (4.38) both become equalities:
|λ − amm | =

n
X
j=1
j6=m

|amj ||ξj | =

n
X
j=1
j6=m

|amj | = ρm .

(4.39)

Let j be any integer 1 ≤ j ≤ n. Since A is irreducible, its graph is connected and,
therefore, there exists a path from node m to node j in the adjacency graph. Let this
path be
m, m1 , m2 , . . . , mk = j.
By definition of an edge in the adjacency graph, am,m1 6= 0. Because of the equality
in (4.39), it is necessary that |ξj | = 1 for any nonzero ξj . Therefore, |ξm1 | must be
equal to one. Now repeating the argument with m replaced by m1 shows that the
following equality holds:
|λ − am1 ,m1 | =

n
X

j=1
j6=m1

|am1 ,j ||ξj | =

n
X

j=1
j6=m1

|am1 ,j | = ρm1 .

(4.40)

The argument can be continued showing each time that
|λ − ami ,mi | = ρmi ,

(4.41)

and this is valid for i = 1, . . . , k. In the end, it will be proved that λ belongs to the
boundary of the j-th disc for an arbitrary j.
An immediate corollary of the Gershgorin theorem and the above theorem follows.
Corollary 4.8 If a matrix A is strictly diagonally dominant or irreducibly diagonally
dominant, then it is nonsingular.
Proof. If a matrix is strictly diagonally dominant, then the union of the Gershgorin
disks excludes the origin, so λ = 0 cannot be an eigenvalue. Assume now that it is
only irreducibly diagonal dominant. Then if it is singular, the zero eigenvalue lies on
the boundary of the union of the Gershgorin disks. In this situation, according to the
previous theorem, this eigenvalue should lie on the boundary of all the disks. This
would mean that
n
X
|ajj | =
|aij | for j = 1, . . . , n,
i=1
i6=j

which contradicts the assumption of irreducible diagonal dominance.
The following theorem can now be stated.
Theorem 4.9 If A is a strictly diagonally dominant or an irreducibly diagonally
dominant matrix, then the associated Jacobi and Gauss-Seidel iterations converge
for any x0 .

CHAPTER 4. BASIC ITERATIVE METHODS

122

Proof. We first prove the results for strictly diagonally dominant matrices. Let λ be
the dominant eigenvalue of the iteration matrix MJ = D −1 (E + F ) for Jacobi and
MG = (D − E)−1 F for Gauss-Seidel. As in the proof of Gershgorin’s theorem, let
x be an eigenvector associated with λ, with |ξm | = 1, and |ξi | ≤ 1, for i 6= 1. Start
from equation (4.38) in the proof of Gershgorin’s theorem which states that for MJ ,
|λ| ≤

n
X
|amj |
j=1
j6=m

|amm |

|ξj | ≤

n
X
|amj |
j=1
j6=m

|amm |

< 1.

This proves the result for Jacobi’s method.
For the Gauss-Seidel iteration, write the m-th row of the equation F x = λ(D −
E)x in the form


X
X
amj ξj  ,
amj ξj = λ amm ξm +
j>m

j<m

which yields the inequality
P
|λ| ≤

j<m |amj ||ξj |

|amm | −

P

j>m |amj ||ξj |

≤

P

j<m |amj |

|amm | −

P

j>m |amj |

.

The last term in the above equation has the form σ2 /(d − σ1 ) with d, σ1 , σ2 all
nonnegative and d − σ1 − σ2 > 0. Therefore,
|λ| ≤

σ2
< 1.
σ2 + (d − σ2 − σ1 )

In the case when the matrix is only irreducibly diagonally dominant, the above
proofs only show that ρ(M −1 N ) ≤ 1, where M −1 N is the iteration matrix for either
Jacobi or Gauss-Seidel. A proof by contradiction will be used to show that in fact
ρ(M −1 N ) < 1. Assume that λ is an eigenvalue of M −1 N with |λ| = 1. Then the
matrix M −1 N − λI would be singular and, as a result, A′ = N − λM would also be
singular. Since |λ| = 1, it is clear that A′ is also an irreducibly diagonally dominant
matrix. This would contradict Corollary 4.8.

4.2.4

Symmetric Positive Definite Matrices

It is possible to show that when A is Symmetric Positive Definite, then SOR will
converge for any ω in the open interval (0, 2) and for any initial guess x0 . In fact, the
reverse is also true under certain assumptions.
Theorem 4.10 If A is symmetric with positive diagonal elements and for 0<ω < 2,
SOR converges for any x0 if and only if A is positive definite.

4.2. CONVERGENCE

4.2.5

123

Property A and Consistent Orderings

A number of properties which are related to the graph of a finite difference matrix are
now defined. The first of these properties is called Property A. A matrix has Property
A if its graph is bipartite. This means that the graph is two-colorable in the sense
defined in Chapter 3: Its vertices can be partitioned in two sets in such a way that
no two vertices in the same set are connected by an edge. Note that, as usual, the
self-connecting edges which correspond to the diagonal elements are ignored.
Definition 4.11 A matrix has Property A if the vertices of its adjacency graph can
be partitioned in two sets S1 and S2 , so that any edge in the graph links a vertex of
S1 to a vertex of S2 .
In other words, nodes from the first set are connected only to nodes from the second
set and vice versa. This definition is illustrated in Figure 4.5.
S1

S2

Figure 4.5: Graph illustration of Property A.
An alternative definition is that a matrix has Property A if it can be permuted into
a matrix with the following structure:


D1 −F
′
A =
,
(4.42)
−E D2
where D1 and D2 are diagonal matrices. This structure can be obtained by first
labeling all the unknowns in S1 from 1 to n1 , in which n1 = |S1 | and the rest
from n1 + 1 to n. Note that the Jacobi iteration matrix will have the same structure
except that the D1 , D2 blocks will be replaced by zero blocks. These Jacobi iteration
matrices satisfy an important property stated in the following proposition.
Proposition 4.12 Let B be a matrix with the following structure:


O B12
B=
,
B21 O

(4.43)

and let L and U be the lower and upper triangular parts of B, respectively. Then

CHAPTER 4. BASIC ITERATIVE METHODS

124

1. If µ is an eigenvalue of B, then so is −µ.
2. The eigenvalues of the matrix
B(α) = αL +

1
U
α

defined for α 6= 0 are independent of α.

Proof. The first property is shown
by simply observing that if xv is an eigenvector

x
associated with µ, then −v
is an eigenvector of B associated with the eigenvalue
−µ.
Consider the second property. For any α, the matrix B(α) is similar to B, i.e.,
B(α) = XBX −1 with X defined by


1 O
X=
.
O α
This proves the desired result
A definition which generalizes this important property is consistently ordered matrices. Varga [293] calls a consistently ordered matrix one for which the eigenvalues
of B(α) are independent of α. Another definition given by Young [322] considers
a specific class of matrices which generalize this property. We will use this definition here. Unlike Property A, the consistent ordering property depends on the initial
ordering of the unknowns.
Definition 4.13 A matrix is said to be consistently ordered if the vertices of its adjacency graph can be partitioned in p sets S1 , S2 , . . ., Sp with the property that any
two adjacent vertices i and j in the graph belong to two consecutive partitions Sk
and Sk′ , with k′ = k − 1, if j < i, and k′ = k + 1, if j > i.
It is easy to show that consistently ordered matrices satisfy property A: the first color
is made up of all the partitions Si with odd i and the second with the partitions Si
with even i.
Example 4.2. Block tridiagonal matrices of the form

D1 T12
 T21 D2 T23

..

.
T32 D3
T =

.
.
..
..

T
Tp,p−1









p−1,p
Dp

whose diagonal blocks Di are diagonal matrices are called T -matrices. Clearly, such
matrices are consistently ordered. Note that matrices of the form (4.42) are a particular case with p = 2.

4.2. CONVERGENCE

125

Consider now a general, consistently ordered matrix. By definition, there is permutation π of {1, 2, . . . , n} which is the union of p disjoint subsets
[
[
(4.44)
π = π1 π2 . . . πp

with the property that if aij 6= 0, j 6= i and i belongs to πk , then j belongs to πk±1
depending on whether i < j or i > j. This permutation π can be used to permute
A symmetrically. If P is the permutation matrix associated with the permutation π,
then clearly
A′ = P T AP
is a T -matrix.
Not every matrix that can be symmetrically permuted into a T -matrix is consistently ordered. The important property here is that the partition {πi } preserves
the order of the indices i, j of nonzero elements. In terms of the adjacency graph,
there is a partition of the graph with the property that an oriented edge i, j from
i to j always points to a set with a larger index if j > i, or a smaller index otherwise. In particular, a very important consequence is that edges corresponding to
the lower triangular part will remain so in the permuted matrix. The same is true
for the upper triangular part. Indeed, if a nonzero element in the permuted matrix
is a′i′ ,j ′ = aπ−1 (i),π−1 (j) 6= 0 with i′ > j ′ , then by definition of the permutation
π(i′ ) > π(j ′ ), or i = π(π −1 (i)) > j = π(π −1 (j)). Because of the order preservation, it is necessary that i > j. A similar observation holds for the upper triangular
part. Therefore, this results in the following proposition.
Proposition 4.14 If a matrix A is consistently ordered, then there exists a permutation matrix P such that P T AP is a T -matrix and
(P T AP )L = P T AL P,

(P T AP )U = P T AU P

(4.45)

in which XL represents the (strict) lower part of X and XU the (strict) upper part of
X.
With the above property it can be shown that for consistently ordered matrices
the eigenvalues of B(α) as defined in Proposition 4.12 are also invariant with respect
to α.
Proposition 4.15 Let B be the Jacobi iteration matrix associated with a consistently
ordered matrix A, and let L and U be the lower and upper triangular parts of B,
respectively. Then the eigenvalues of the matrix
B(α) = αL +
defined for α 6= 0 do not depend on α.

1
U
α

126

CHAPTER 4. BASIC ITERATIVE METHODS

Proof. First transform B(α) into a T -matrix using the permutation π in (4.44) provided by the previous proposition
P T B(α)P = αP T LP +

1 T
P U P.
α

From the previous proposition, the lower part of P T BP is precisely L′ = P T LP .
Similarly, the upper part is U ′ = P T U P , the lower and upper parts of the associated
T -matrix. Therefore, we only need to show that the property is true for a T -matrix.
In this case, for any α, the matrix B(α) is similar to B. This means that B(α) =
XBX −1 with X being equal to


1


αI


2
,
α I
X=


..


.
p−1
α I
where the partitioning is associated with the subsets π1 , . . . , πp respectively.

Note that T -matrices and matrices with the structure (4.42) are two particular
cases of matrices which fulfill the assumptions of the above proposition. There are a
number of well known properties related to Property A and consistent orderings. For
example, it is possible to show that,
• Property A is invariant under symmetric permutations.
• A matrix has Property A if and only if there is a permutation matrix P such
that A′ = P −1 AP is consistently ordered.
Consistently ordered matrices satisfy an important property which relates the
eigenvalues of the corresponding SOR iteration matrices to those of the Jacobi iteration matrices. The main theorem regarding the theory for SOR is a consequence of
the following result proved by Young [322]. Remember that
MSOR = (D − ωE)−1 (ωF + (1 − ω)D)


= (I − ωD −1 E)−1 ωD −1 F + (1 − ω)I .

Theorem 4.16 Let A be a consistently ordered matrix such that aii 6= 0 for i =
1, . . . , n, and let ω 6= 0. Then if λ is a nonzero eigenvalue of the SOR iteration
matrix MSOR , any scalar µ such that
(λ + ω − 1)2 = λω 2 µ2

(4.46)

is an eigenvalue of the Jacobi iteration matrix B. Conversely, if µ is an eigenvalue
of the Jacobi matrix B and if a scalar λ satisfies (4.46), then λ is an eigenvalue of
MSOR .

4.3. ALTERNATING DIRECTION METHODS

127

Proof. Denote D −1 E by L and D −1 F by U , so that
MSOR = (I − ωL)−1 (ωU + (1 − ω)I)
and the Jacobi iteration matrix is merely L + U . Writing that λ is an eigenvalue
yields

det λI − (I − ωL)−1 (ωU + (1 − ω)I) = 0

which is equivalent to

det (λ(I − ωL) − (ωU + (1 − ω)I)) = 0
or
det ((λ + ω − 1)I − ω(λL + U )) = 0.

Since ω 6= 0, this can be rewritten as


λ+ω−1
I − (λL + U ) = 0,
det
ω

which means that (λ + ω − 1)/ω is an eigenvalue of λL + U . Since A is consistently
ordered, the eigenvalues of λL + U which are equal to λ1/2 (λ1/2 L + λ−1/2 U ) are
the same as those of λ1/2 (L + U ), where L + U is the Jacobi iteration matrix. The
proof follows immediately.
This theorem allows us to compute an optimal value for ω, which can be shown
to be equal to
2
p
.
(4.47)
ωopt =
1 + 1 − ρ(B)2
A typical SOR procedure starts with some ω, for example, ω = 1, then proceeds with
a number of SOR steps with this ω. The convergence rate for the resulting iterates is
estimated providing an estimate for ρ(B) using Theorem 4.16. A better ω is then obtained from the formula (4.47), and the iteration restarted. Further refinements of the
optimal ω are calculated and retrofitted in this manner as the algorithm progresses.

4.3

Alternating Direction Methods

The Alternating Direction Implicit (ADI) method was introduced in the mid-1950s
by Peaceman and Rachford [226] specifically for solving equations arising from finite difference discretizations of elliptic and parabolic Partial Differential Equations.
Consider a partial differential equation of elliptic type




∂
∂u(x, y)
∂
∂u(x, y)
a(x, y)
+
b(x, y)
= f (x, y)
(4.48)
∂x
∂x
∂y
∂y
on a rectangular domain with Dirichlet boundary conditions. The equations are discretized with centered finite differences using n + 2 points in the x direction and
m + 2 points in the y direction, This results in the system of equations
Hu + V u = b,

(4.49)

CHAPTER 4. BASIC ITERATIVE METHODS

128

in which the matrices H and V represent the three-point central difference approximations to the operators




∂
∂
∂
∂
a(x, y)
and
b(x, y)
,
∂x
∂x
∂y
∂y
respectively. In what follows, the same notation is used to represent the discretized
version of the unknown function u.
The ADI algorithm consists of iterating by solving (4.49) in the x and y directions alternatively as follows.
A LGORITHM 4.3 Peaceman-Rachford (PR) ADI

1.
2.
3.
4.

For k = 0., 1, . . . , until convergence Do:
Solve: (H + ρk I)uk+ 1 = (ρk I − V )uk + b
2
Solve: (V + ρk I)uk+1 = (ρk I − H)uk+ 1 + b
2
EndDo

Here, ρk , k = 1, 2, . . ., is a sequence of positive acceleration parameters.
The specific case where ρk is chosen to be a constant ρ deserves particular attention. In this case, we can formulate the above iteration in the usual form of (4.28)
with
G = (V + ρI)−1 (H − ρI)(H + ρI)−1 (V − ρI),


f = (V + ρI)−1 I − (H − ρI)(H + ρI)−1 b

(4.50)
(4.51)

or, when ρ > 0, in the form (4.22) with
M=

1
(H + ρI)(V + ρI),
2ρ

N=

1
(H − ρI)(V − ρI).
2ρ

(4.52)

Note that (4.51) can be rewritten in a simpler form; see Exercise 5.
The ADI algorithm is often formulated for solving the time-dependent Partial
Differential Equation




∂u
∂
∂u
∂
∂u
=
a(x, y)
+
b(x, y)
(4.53)
∂t
∂x
∂x
∂y
∂y
on the domain (x, y, t) ∈ Ω × [0, T ] ≡ (0, 1) × (0, 1) × [0, T ]. The initial and
boundary conditions are:
u(x, y, 0) = x0 (x, y), ∀(x, y) ∈ Ω,

u(x̄, ȳ, t) = g(x̄, ȳ, t), ∀(x̄, ȳ) ∈ ∂Ω, t > 0,

(4.54)
(4.55)

where ∂Ω is the boundary of the unit square Ω. The equations are discretized with
respect to the space variables x and y as before, resulting in a system of Ordinary
Differential Equations:
du
= Hu + V u,
(4.56)
dt

4.3. ALTERNATING DIRECTION METHODS

129

in which the matrices H and V have been defined earlier. The Alternating Direction
Implicit algorithm advances the relation (4.56) forward in time alternately in the x
and y directions as follows:
1
1
(I − ∆t H)uk+ 1 = (I + ∆t V )uk ,
2
2
2
1
1
(I − ∆t V )uk+1 = (I + ∆t H)uk+ 1 .
2
2
2
The acceleration parameters ρk of Algorithm 4.3 are replaced by a natural time-step.
Horizontal ordering

Vertical ordering

19

20

21

22

23

24

4

8

12

16

20

24

13

14

15

16

17

18

3

7

11

15

19

23

7

8

9

10

11

12

2

6

10

14

18

22

1

2

3

4

5

6

1

5

9

13

17

21

Figure 4.6: The horizontal and vertical orderings for the unknowns in ADI.
Assuming that the mesh-points are ordered by lines in the x-direction, then the
first step of Algorithm 4.3 constitutes a set of m independent tridiagonal linear systems of size n each. However, the second step constitutes a large tridiagonal system
whose three diagonals are offset by −m, 0, and m, respectively. This second system
can also be rewritten as a set of n independent tridiagonal systems of size m each by
reordering the grid points by lines, this time in the y direction. The natural (horizontal) and vertical orderings are illustrated in Figure 4.6. Whenever moving from one
half step of ADI to the next, we must implicitly work with the transpose of the matrix
representing the solution on the n × m grid points. This data operation may be an
expensive task on parallel machines and often it is cited as one of the drawbacks of
Alternating Direction Methods in this case.
ADI methods were extensively studied in the 1950s and 1960s for the particular
case of positive definite systems. For such systems, H and V have real eigenvalues
and the following is a summary of the main results in this situation. First, when H
and V are Symmetric Positive Definite, then the stationary iteration (ρk = ρ > 0, for
all k) converges. For the model problem, the asymptotic rate of convergence of the
stationary ADI iteration using the optimal ρ is the same as that of SSOR using the
optimal ω. However, each ADI step is more expensive than one SSOR step. One of
the more important results in the ADI theory is that the rate of convergence of ADI
can be increased appreciably by using a cyclic sequence of parameters, ρk . A theory
for selecting the best sequence of ρk ’s is well understood in the case when H and
V commute [38]. For the model problem, the parameters can be selected so that the
time complexity is reduced to O(n2 log n), for details see [226].

CHAPTER 4. BASIC ITERATIVE METHODS

130
P ROBLEMS

P-4.1 Consider an n × n tridiagonal matrix of the form

α −1
 −1 α −1

−1 α −1

Tα = 
−1 α −1


−1 α
−1

where α is a real parameter.


−1
α




,



(4.57)

a. Verify that the eigenvalues of Tα are given by
λj = α − 2 cos (jθ)

j = 1, . . . , n,

where

π
n+1
and that an eigenvector associated with each λj is
θ=

T

qj = [sin(jθ), sin(2jθ), . . . , sin(njθ)] .
Under what condition on α does this matrix become positive definite?
b. Now take α = 2. How does this matrix relate to the matrices seen in Chapter 2 for
one-dimensional problems?
(i) Will the Jacobi iteration converge for this matrix? If so, what will its convergence factor be?
(ii) Will the Gauss-Seidel iteration converge for this matrix? If so, what will its
convergence factor be?
(iii) For which values of ω will the SOR iteration converge?
P-4.2 Prove that the iteration matrix Gω of SSOR, as defined by (4.13), can be expressed as
Gω = I − ω(2 − ω)(D − ωF )−1 D(D − ωE)−1 A.
Deduce the expression (4.27) for the preconditioning matrix associated with the SSOR iteration.
P-4.3 Let A be a matrix with a positive diagonal D.
a. Obtain an expression equivalent to that of (4.13) for Gω but which involves the matrices
SE ≡ D−1/2 ED−1/2 and SF ≡ D−1/2 F D−1/2 .

b. Show that

D1/2 Gω D−1/2 = (I − ωSF )−1 (I − ωSE )−1 (ωSE + (1 − ω)I)(ωSF + (1 − ω)I)
c. Now assume that in addition to having a positive diagonal, A is symmetric. Prove that
the eigenvalues of the SSOR iteration matrix Gω are real and nonnegative.

4.3. ALTERNATING DIRECTION METHODS
P-4.4 Let



D1
 −E2


A=



−F2
D2
−E3

−F3
D3
..
.

131

..

.

..

.
−Em






,

−Fm 
Dm

where the Di blocks are nonsingular matrices which are not necessarily diagonal.
a. What are the block Jacobi and block Gauss-Seidel iteration matrices?
b. Show a result similar to that in Proposition 4.15 for the Jacobi iteration matrix.
c. Show also that for ω = 1 (1) the block Gauss-Seidel and block Jacobi iterations either
both converge or both diverge, and (2) when they both converge, then the block GaussSeidel iteration is (asymptotically) twice as fast as the block Jacobi iteration.
P-4.5 According to formula (4.23), the f vector in iteration (4.22) should be equal to M −1 b,
where b is the right-hand side and M is given in (4.52). Yet, formula (4.51) gives a different
expression for f . Reconcile the two results, i.e., show that the expression (4.51) can also be
rewritten as
f = 2ρ(V + ρI)−1 (H + ρI)−1 b.
P-4.6 Show that a matrix has Property A if and only if there is a permutation matrix P such
that A′ = P −1 AP is consistently ordered.
P-4.7 Consider a matrix A which is consistently ordered. Show that the asymptotic convergence rate for Gauss-Seidel is double that of the Jacobi iteration.
P-4.8 A matrix of the form

is called a three-cyclic matrix.



0
B= 0
H

E
0
0


0
F
0

a. What are the eigenvalues of B? (Express them in terms of eigenvalues of a certain
matrix which depends on E, F , and H.)
b. Assume that a matrix A has the form A = D + B, where D is a nonsingular diagonal
matrix, and B is three-cyclic. How can the eigenvalues of the Jacobi iteration matrix
be related to those of the Gauss-Seidel iteration matrix? How does the asymptotic
convergence rate of the Gauss-Seidel iteration compare with that of the Jacobi iteration
matrix in this case?
c. Answer the same questions as in (b) for the case when SOR replaces the Gauss-Seidel
iteration.
d. Generalize the above results to p-cyclic matrices, i.e., matrices of the form


0 E1


0 E2


.
.

.
B=
.
0


0 Ep−1 
Ep
0

132

CHAPTER 4. BASIC ITERATIVE METHODS

N OTES AND R EFERENCES . Two good references for the material covered in this chapter are Varga
[293] and and Young [322]. Although relaxation-type methods were very popular up to the 1960s,
they are now mostly used as preconditioners, a topic which will be seen in detail in Chapters 9 and
10. One of the main difficulties with these methods is finding an optimal relaxation factor for general
matrices. Theorem 4.7 is due to Ostrowski. For details on the use of Gershgorin’s theorem in eigenvalue
problems, see [246]. The original idea of the ADI method is described in [226] and those results on the
optimal parameters for ADI can be found in [38]. A comprehensive text on this class of techniques can
be found in [300].

Chapter 5

PROJECTION METHODS

Most of the existing practical iterative techniques for solving large linear systems of equations
utilize a projection process in one way or another. A projection process represents a canonical
way for extracting an approximation to the solution of a linear system from a subspace. This
chapter describes these techniques in a very general framework and presents some theory. The
one-dimensional case is covered in detail at the end of the chapter, as it provides a good preview
of the more complex projection processes to be seen in later chapters.

5.1

Basic Definitions and Algorithms

Consider the linear system
Ax = b,

(5.1)

where A is an n × n real matrix. In this chapter, the same symbol A is often used to
denote the matrix and the linear mapping in Rn that it represents. The idea of projection techniques is to extract an approximate solution to the above problem from a
subspace of Rn . If K is this subspace of candidate approximants, or search subspace,
and if m is its dimension, then, in general, m constraints must be imposed to be able
to extract such an approximation. A typical way of describing these constraints is
to impose m (independent) orthogonality conditions. Specifically, the residual vector b − Ax is constrained to be orthogonal to m linearly independent vectors. This
defines another subspace L of dimension m which will be called the subspace of
constraints or left subspace for reasons that will be explained below. This simple
framework is common to many different mathematical methods and is known as the
Petrov-Galerkin conditions.
There are two broad classes of projection methods: orthogonal and oblique. In
an orthogonal projection technique, the subspace L is the same as K. In an oblique
projection method, L is different from K and may be totally unrelated to it. This
distinction is rather important and gives rise to different types of algorithms.
133

CHAPTER 5. PROJECTION METHODS

134

5.1.1

General Projection Methods

Let A be an n × n real matrix and K and L be two m-dimensional subspaces of Rn.
A projection technique onto the subspace K and orthogonal to L is a process which
finds an approximate solution x̃ to (5.1) by imposing the conditions that x̃ belong to
K and that the new residual vector be orthogonal to L,
Find x̃ ∈ K,

such that

b − Ax̃ ⊥ L.

(5.2)

If we wish to exploit the knowledge of an initial guess x0 to the solution, then the
approximation must be sought in the affine space x0 + K instead of the homogeneous
vector space K. This requires a slight modification to the above formulation. The
approximate problem should be redefined as
Find

x̃ ∈ x0 + K,

such that

b − Ax̃ ⊥ L.

(5.3)

Note that if x̃ is written in the form x̃ = x0 + δ, and the initial residual vector r0 is
defined as
r0 = b − Ax0 ,
(5.4)
then the above equation becomes b − A(x0 + δ) ⊥ L or
r0 − Aδ ⊥ L.
In other words, the approximate solution can be defined as
x̃ = x0 + δ,
(r0 − Aδ, w) = 0,

δ ∈ K,

(5.5)

∀w ∈ L.

(5.6)

The orthogonality condition (5.6) imposed on the new residual rnew = r0 − Aδ is
illustrated in Figure 5.1.
Aδ
rnew

✻

✲r0
✒

L
O

Figure 5.1: Interpretation of the orthogonality condition.
This is a basic projection step, in its most general form. Most standard techniques use a succession of such projections. Typically, a new projection step uses a
new pair of subspace K and L and an initial guess x0 equal to the most recent approximation obtained from the previous projection step. Projection methods form a

5.1. BASIC DEFINITIONS AND ALGORITHMS

135

unifying framework for many of the well known methods in scientific computing. In
fact, virtually all of the basic iterative techniques seen in the previous chapter can be
considered projection techniques. Whenever an approximation is defined via m degrees of freedom (subspace K) and m constraints (Subspace L), a projection process
results.
Example 5.1. In the simplest case, an elementary Gauss-Seidel step as defined by
(4.6) is nothing but a projection step with K = L = span{ei }. These projection
steps are cycled for i = 1, . . . , n until convergence. See Exercise 1 for an alternative
way of selecting the sequence of ei ’s.
Orthogonal projection methods correspond to the particular case when the two
subspaces L and K are identical. The distinction is particularly important in the
Hermitian case since we are guaranteed that the projected problem will be Hermitian
in this situation, as will be seen shortly. In addition, a number of helpful theoretical
results are true for the orthogonal case. When L = K, the Petrov-Galerkin conditions
are often called the Galerkin conditions.

5.1.2

Matrix Representation

Let V = [v1 , . . . , vm ], an n × m matrix whose column-vectors form a basis of K
and, similarly, W = [w1 , . . . , wm ], an n × m matrix whose column-vectors form a
basis of L. If the approximate solution is written as
x̃ = x0 + V y,
then the orthogonality condition leads immediately to the following system of equations for the vector y:
W T AV y = W T r0 .
If the assumption is made that the m×m matrix W T AV is nonsingular, the following
expression for the approximate solution x̃ results,
x̃ = x0 + V (W T AV )−1 W T r0 .

(5.7)

In many algorithms, the matrix W T AV does not have to be formed since it is available as a by-product of the algorithm. A prototype projection technique is represented by the following algorithm.
A LGORITHM 5.1 Prototype Projection Method

1.
2.
3.
4.
5.
6.
7.

Until convergence, Do:
Select a pair of subspaces K and L
Choose bases V = [v1 , . . . , vm ] and W = [w1 , . . . , wm ] for K and L
r := b − Ax
y := (W T AV )−1 W T r
x := x + V y
EndDo

136

CHAPTER 5. PROJECTION METHODS

The approximate solution is defined only when the matrix W T AV is nonsingular, a property that is not guaranteed to be true even when A is nonsingular.
Example 5.2. As an example, consider the matrix


O I
A=
,
I I
where I is the m × m identity matrix and O is the m × m zero matrix, and let V =
W = [e1 , e2 , . . . , em ]. Although A is nonsingular, the matrix W T AV is precisely
the O block in the upper-left corner of A and is therefore singular.
It can be easily verified that W T AV is nonsingular if and only if no vector of
the subspace AK is orthogonal to the subspace L. We have encountered a similar
condition when defining projector operators in Chapter 1. There are two important
particular cases where the nonsingularity of W T AV is guaranteed. These are discussed in the following proposition.
Proposition 5.1 Let A, L, and K satisfy either one of the two following conditions,
i. A is positive definite and L = K, or
ii. A is nonsingular and L = AK.
Then the matrix B = W T AV is nonsingular for any bases V and W of K and L,
respectively.
Proof. Consider first the case (i). Let V be any basis of K and W be any basis of L.
In fact, since L and K are the same, W can always be expressed as W = V G, where
G is a nonsingular m × m matrix. Then
B = W T AV = GT V T AV.
Since A is positive definite, so is V T AV , see Chapter 1, and this shows that B is
nonsingular.
Consider now case (ii). Let V be any basis of K and W be any basis of L. Since
L = AK, W can be expressed in this case as W = AV G, where G is a nonsingular
m × m matrix. Then
B = W T AV = GT (AV )T AV.
(5.8)
Since A is nonsingular, the n×m matrix AV is of full rank and as a result, (AV )T AV
is nonsingular. This, along with (5.8), shows that B is nonsingular.
Now consider the particular case where A is symmetric (real) and an orthogonal
projection technique is used. In this situation, the same basis can be used for L and
K, which are identical subspaces, and the projected matrix, which is B = V T AV , is
symmetric. In addition, if the matrix A is Symmetric Positive Definite, then so is B.

5.2. GENERAL THEORY

5.2

137

General Theory

This section gives some general theoretical results without being specific about the
subspaces K and L which are used. The goal is to learn about the quality of the
approximation obtained from a general projection process. Two main tools are used
for this. The first is to exploit optimality properties of projection methods. These
properties are induced from those properties of projectors seen in Section 1.12.4 of
Chapter 1. The second tool consists of interpreting the projected problem with the
help of projection operators in an attempt to extract residual bounds.

5.2.1

Two Optimality Results

In this section, two important optimality results will be established that are satisfied
by the approximate solutions in some cases. Consider first the case when A is SPD.
Proposition 5.2 Assume that A is Symmetric Positive Definite and L = K. Then a
vector x̃ is the result of an (orthogonal) projection method onto K with the starting
vector x0 if and only if it minimizes the A-norm of the error over x0 + K, i.e., if and
only if
E(x̃) = min E(x),
x∈x0 +K

where
E(x) ≡ (A(x∗ − x), x∗ − x)1/2 .
Proof. As was seen in Section 1.12.4, for x̃ to be the minimizer of E(x), it is necessary and sufficient that x∗ − x̃ be A-orthogonal to all the subspace K. This yields
(A(x∗ − x̃), v) = 0,

∀v

∈ K,

(b − Ax̃, v) = 0,

∀v

∈ K,

or, equivalently,
which is the Galerkin condition defining an orthogonal projection process for the
approximation x̃.
We now take up the case when L is defined by L = AK.
Proposition 5.3 Let A be an arbitrary square matrix and assume that L = AK.
Then a vector x̃ is the result of an (oblique) projection method onto K orthogonally
to L with the starting vector x0 if and only if it minimizes the 2-norm of the residual
vector b − Ax over x ∈ x0 + K, i.e., if and only if
R(x̃) = min R(x),
x∈x0 +K

where R(x) ≡ kb − Axk2 .

138

CHAPTER 5. PROJECTION METHODS

Proof. As was seen in Section 1.12.4, for x̃ to be the minimizer of R(x), it is necessary and sufficient that b − Ax̃ be orthogonal to all vectors of the form v = Ay,
where y belongs to K, i.e.,
(b − Ax̃, v) = 0,

∀v

∈ AK,

which is precisely the Petrov-Galerkin condition that defines the approximate solution x̃.
It is worthwhile to point out that A need not be nonsingular in the above proposition.
When A is singular there may be infinitely many vectors x̃ satisfying the optimality
condition.

5.2.2

Interpretation in Terms of Projectors

We now return to the two important particular cases singled out in the previous section, namely, the cases L = K and L = AK. In these cases, the result of the
projection process can be interpreted easily in terms of actions of orthogonal projectors on the initial residual or initial error. Consider the second case first, as it is
slightly simpler. Let r0 be the initial residual r0 = b − Ax0 , and r̃ = b − Ax̃ the
residual obtained after the projection process with L = AK. Then,
r̃ = b − A(x0 + δ) = r0 − Aδ.

(5.9)

In addition, δ is obtained by enforcing the condition that r0 − Aδ be orthogonal to
AK. Therefore, the vector Aδ is the orthogonal projection of the vector r0 onto the
subspace AK. This is illustrated in Figure 5.2. Hence, the following proposition can
be stated.
Proposition 5.4 Let x̃ be the approximate solution obtained from a projection process onto K orthogonally to L = AK, and let r̃ = b − Ax̃ be the associated residual.
Then,
r̃ = (I − P )r0 ,
(5.10)
where P denotes the orthogonal projector onto the subspace AK.
A result of the proposition is that the 2-norm of the residual vector obtained after
one projection step will not exceed the initial 2-norm of the residual, i.e.,
kr̃k2 ≤ kr0 k2 ,
a result which has been established already. This class of methods may be termed
residual projection methods.
Now consider the case where L = K and A is Symmetric Positive Definite. Let
d0 = x∗ − x0 be the initial error, where x∗ denotes the exact solution to the system
and, similarly, let d˜ = x∗ − x̃ where x̃ = x0 + δ is the approximate solution resulting
from the projection step. Then (5.9) yields the relation
Ad˜ = r̃ = A(d0 − δ),

5.2. GENERAL THEORY

139
r0

AK
✻
✯
❥

Aδ = P r0

O

Figure 5.2: Interpretation of the projection process for the case when L = AK.
where δ is now obtained by constraining the residual vector r0 − Aδ to be orthogonal
to K:
(r0 − Aδ, w) = 0, ∀ w ∈ K.
The above condition is equivalent to
(A(d0 − δ), w) = 0,

∀ w ∈ K.

Since A is SPD, it defines an inner product (see Section 1.11) which is usually denoted by (., .)A and the above condition becomes
(d0 − δ, w)A = 0,

∀ w ∈ K.

The above condition is now easy to interpret: The vector δ is the A-orthogonal projection of the initial error d0 onto the subspace K.
Proposition 5.5 Let x̃ be the approximate solution obtained from an orthogonal projection process onto K and let d˜ = x∗ − x̃ be the associated error vector. Then,
d˜ = (I − PA )d0 ,
where PA denotes the projector onto the subspace K, which is orthogonal with respect to the A-inner product.
A result of the proposition is that the A-norm of the error vector obtained after one
projection step does not exceed the initial A-norm of the error, i.e.,
˜ A ≤ kd0 kA ,
kdk
which is expected because it is known that the A-norm of the error is minimized in
x0 + K. This class of methods may be termed error projection methods.

CHAPTER 5. PROJECTION METHODS

140

5.2.3

General Error Bound

If no vector of the subspace K comes close to the exact solution x, then it is impossible to find a good approximation x̃ to x from K. Therefore, the approximation
obtained by any projection process based on K will be poor. On the other hand, if
there is some vector in K which is a small distance ǫ away from x, then the question
is: How good can the approximate solution be? The purpose of this section is to try
to answer this question.

PK x ∈ K, x − PK x ⊥ K

x⊥L
x ∈ K, x − QL
QL
K
K

x

L

QL x
K

✠

❄PK x

K

Figure 5.3: Orthogonal and oblique projectors.
be the (oblique)
Let PK be the orthogonal projector onto the subpace K and let QL
K
projector onto K and orthogonally to L. These projectors are defined by
PK x ∈ K, x − PK x ⊥ K,

x ⊥ L,
x ∈ K, x − QL
QL
K
K
and are illustrated in Figure 5.3. The symbol Am is used to denote the operator
Am = QL
APK ,
K
and it is assumed, without loss of generality, that x0 = 0. Then according to the
property (1.62), the approximate problem defined in (5.5 – 5.6) can be reformulated
as follows: find x̃ ∈ K such that
QL
(b − Ax̃) = 0,
K
or, equivalently,
Am x̃ = QL
b,
K

x̃ ∈ K.

5.2. GENERAL THEORY

141

Thus, an n-dimensional linear system is approximated by an m-dimensional one.
The following proposition examines what happens in the particular case when the
subspace K is invariant under A. This is a rare occurrence in practice, but the result
helps in understanding the breakdown behavior of the methods to be considered in
later chapters.
Proposition 5.6 Assume that K is invariant under A, x0 = 0, and b belongs to K.
Then the approximate solution obtained from any (oblique or orthogonal) projection
method onto K is exact.
Proof. An approximate solution x̃ is defined by
QL
(b − Ax̃) = 0,
K
b = b.
where x̃ is a nonzero vector in K. The right-hand side b is in K, so we have QL
K
Similarly, x̃ belongs to K which is invariant under A, and therefore, QL
Ax̃
=
Ax̃.
K
Then the above equation becomes
b − Ax̃ = 0,
showing that x̃ is an exact solution.
The result can be extended trivially to the case where x0 6= 0. The required assumption in this case is that the initial residual r0 = b − Ax0 belongs to the invariant
subspace K.
An important quantity for the convergence properties of projection methods is
the distance k(I − PK )x∗ k2 of the exact solution x∗ from the subspace K. This
quantity plays a key role in the analysis of projection methods. Note that the solution
x∗ cannot be well approximated from K, if k(I − PK )x∗ k2 is not small because
kx̃ − x∗ k2 ≥ k(I − PK )x∗ k2 .
The fundamental quantity k(I − PK )x∗ k2 /kx∗ k2 is the sine of the acute angle between the solution x∗ and the subspace K. The following theorem establishes an
upper bound for the residual norm of the exact solution with respect to the approximate operator Am .
A(I − PK )k2 and assume that b is a member of K and
Theorem 5.7 Let γ = kQL
K
x0 = 0. Then the exact solution x∗ of the original problem is such that
kb − Am x∗ k2 ≤ γk(I − PK )x∗ k2 .
Proof. Since b ∈ K, then
(b − APK x∗ )
b − Am x∗ = QL
K

(Ax∗ − APK x∗ )
= QL
K

A(x∗ − PK x∗ )
= QL
K
A(I − PK )x∗ .
= QL
K

(5.11)

CHAPTER 5. PROJECTION METHODS

142

Noting that I − PK is a projector, it follows that
A(I − PK )(I − PK )x∗ k2
kb − Am x∗ k2 = kQL
K

≤ kQL
A(I − PK )k2 k(I − PK )x∗ k2 ,
K

which completes the proof.
It is useful to consider a matrix interpretation of the theorem. We consider only
the particular case of orthogonal projection methods (L = K). Assume that V is
unitary, i.e., that the basis {v1 , . . . , vm } is orthonormal, and that W = V . Observe
that b = V V T b. Equation (5.11) can be represented in the basis V as
kb − V (V T AV )V T x∗ k2 ≤ γk(I − PK )x∗ k2 .
However,
kb − V (V T AV )V T x∗ k2 = kV (V T b − (V T AV )V T x∗ k2
= kV T b − (V T AV )V T x∗ k2 .

Thus, the projection of the exact solution has a residual norm with respect to the
matrix B = V T AV , which is of the order of k(I − PK )x∗ k2 .

5.3

One-Dimensional Projection Processes

This section examines simple examples provided by one-dimensional projection processes. In what follows, the vector r denotes the residual vector r = b − Ax for the
current approximation x. To avoid subscripts, arrow notation is used to denote vector
updates. Thus, “x ← x + αr” means “compute x + αr and overwrite the result on
the current x.” (This is known as a SAXPY operation.)
One-dimensional projection processes are defined when
K = span{v}

and

L = span{w},

where v and w are two vectors. In this case, the new approximation takes the form
x ← x + αv and the Petrov-Galerkin condition r − Aδ ⊥ w yields
α=

(r, w)
.
(Av, w)

(5.12)

Following are three popular choices to be considered.

5.3.1

Steepest Descent

The steepest descent algorithm is defined for the case where the matrix A is Symmetric Positive Definite. It consists of taking at each step v = r and w = r. This
yields the following iterative procedure:
r ← b − Ax,
α ← (r, r)/(Ar, r)
x ← x + αr.

5.3. ONE-DIMENSIONAL PROJECTION PROCESSES

143

However, the above procedure requires two matrix-by-vector products and this can be
reduced to only one by rearranging the computation slightly. The variation consists
of computing r differently as is shown next.
A LGORITHM 5.2 Steepest Descent Algorithm

1.
2.
3.
4.
5.
6.
7.

Compute r = b − Ax and p = Ar
Until convergence, Do:
α ← (r, r)/(p, r)
x ← x + αr
r ← r − αp
compute p := Ar
EndDo
Each step of the above iteration minimizes
f (x) = kx − x∗ k2A = (A(x − x∗ ), (x − x∗ )),

over all vectors of the form x + αd, where d is the negative of the gradient direction −∇f . The negative of the gradient direction is locally the direction that yields
the fastest rate of decrease for f . Next, we prove that convergence is guaranteed
when A is SPD. The result is a consequence of the following lemma known as the
Kantorovich inequality.
Lemma 5.8 (Kantorovich inequality) Let B be any Symmetric Positive Definite real
matrix and λmax , λmin its largest and smallest eigenvalues. Then,
(λmax + λmin )2
(Bx, x)(B −1 x, x)
≤
,
(x, x)2
4 λmax λmin

∀x 6= 0.

(5.13)

Proof. Clearly, it is equivalent to show that the result is true for any unit vector x.
Since B is symmetric, it is unitarily similar to a diagonal matrix, B = QT DQ, and
(Bx, x)(B −1 x, x) = (QT DQx, x)(QT D −1 Qx, x) = (DQx, Qx)(D −1 Qx, Qx).
Setting y = Qx = (y1 , . . . , yn )T , and βi = yi2 , note that
λ ≡ (Dy, y) =

n
X

βi λi

i=1

is a convex combination of the eigenvalues λi , i = 1, . . . , n. The following relation
holds,
(Bx, x)(B −1 x, x) = λψ(y)

with

ψ(y) = (D −1 y, y) =

n
X
i=1

βi

1
.
λi

CHAPTER 5. PROJECTION METHODS

144

Noting that the function f (λ) = 1/λ is convex, ψ(y) is bounded from above by the
linear curve that joins the points (λ1 , 1/λ1 ) and (λn , 1/λn ), i.e.,
ψ(y) ≤

1
1
λ
+
−
.
λ1 λn λ1 λn

Therefore,
(Bx, x)(B

−1

x, x) = λψ(y) ≤ λ



1
1
λ
+
−
λ1 λn λ1 λn



.

The maximum of the right-hand side is reached for λ = 12 (λ1 + λn ) yielding,

λ1 λ2

λ

λi

λn

Figure 5.4: The point (λ, ψ(y)) is a convex combination of points located on the
curve 1/λ. It is located in the convex set limited by the curve 1/λ and the line
1/λ1 + 1/λn − λ/(λ1 λn ).
(Bx, x)(B −1 x, x) = λψ(y) ≤

(λ1 + λn )2
4λ1 λn

which gives the desired result.
This lemma helps to establish the following result regarding the convergence rate
of the method.
Theorem 5.9 Let A be a Symmetric Positive Definite matrix. Then, the A-norms of
the error vectors dk = x∗ − xk generated by Algorithm 5.2 satisfy the relation
kdk+1 kA ≤

λmax − λmin
kdk kA ,
λmax + λmin

and Algorithm 5.2 converges for any initial guess x0 .

(5.14)

5.3. ONE-DIMENSIONAL PROJECTION PROCESSES

145

Proof. Start by expanding the square of the A-norm of dk+1 = dk − αk rk as
kdk+1 k2A = (dk+1 , dk − αk rk )A = (dk+1 , dk )A − αk (dk+1 , rk )A = (dk+1 , rk )
The last equality is due to the orthogonality between rk and rk+1 . Thus,
kdk+1 k2A = (dk − αrk , rk )

= (A−1 rk , rk ) − αk (rk , rk )


(rk , rk )
(rk , rk )
2
×
.
= kdk kA 1 −
(rk , Ark )
(rk , A−1 rk )

The result follows by applying the Kantorovich inequality (5.13).

5.3.2

Minimal Residual (MR) Iteration

We now assume that A is not necessarily symmetric but only positive definite, i.e.,
its symmetric part A + AT is Symmetric Positive Definite. Taking at each step v = r
and w = Ar, gives the following procedure.
r ← b − Ax,
α ← (Ar, r)/(Ar, Ar)
x ← x + αr.
This procedure can be slightly rearranged again to reduce the number of matrixvector products required to only one per step as was done for the steepest descent
algorithm. This results in in the following algorithm.
A LGORITHM 5.3 Minimal Residual Iteration

1.
2.
3.
4.
5.
6.
7.

Compute r = b − Ax and p = Ar
Until convergence, Do:
α ← (p, r)/(p, p)
x ← x + αr
r ← r − αp
compute p := Ar
EndDo

Here, each step minimizes f (x) = kb − Axk22 in the direction r. The iteration converges under the condition that A is positive definite as is stated in the next theorem.
Theorem 5.10 Let A be a real positive definite matrix, and let
µ = λmin (A + AT )/2,

σ = kAk2 .

Then the residual vectors generated by Algorithm 5.3 satisfy the relation
1/2

µ2
krk k2
krk+1 k2 ≤ 1 − 2
σ
and Algorithm (5.3) converges for any initial guess x0 .

(5.15)

CHAPTER 5. PROJECTION METHODS

146

Proof. We proceed similarly to the steepest descent method, starting with the relation
krk+1 k22 = (rk − αk Ark , rk − αk Ark )

(5.16)

= (rk − αk Ark , rk ) − αk (rk − αk Ark , Ark ).

(5.17)

By construction, the new residual vector rk −αk Ark must be orthogonal to the search
direction Ark , and, as a result, the second term in the right-hand side of the above
equation vanishes and we obtain
krk+1 k22 = (rk − αk Ark , rk )

= (rk , rk ) − αk (Ark , rk )


(Ark , rk ) (Ark , rk )
2
= krk k2 1 −
(rk , rk ) (Ark , Ark )


(Ark , rk )2 krk k22
2
= krk k2 1 −
.
(rk , rk )2 kArk k22

(5.18)

From Theorem 1.34, it can be stated that
(Ax, x)
≥ µ > 0,
(x, x)

(5.19)

where µ = λmin (A + AT )/2. The desired result follows immediately by using the
inequality kArk k2 ≤ kAk2 krk k2 .
There are alternative ways of obtaining inequalities that prove convergence. For
example, starting from (5.18), (5.19) can be used again for the term (Ark , rk )/(rk , rk )
and similarly, we can write

 −1
(Ax, x)
(Ax, A−1 (Ax))
A + A−T
=
≥ λmin
> 0,
(Ax, Ax)
(Ax, Ax)
2
since A−1 is also positive definite. This would yield the inequality

krk+1 k22 ≤ 1 − µ(A)µ(A−1 ) krk k22 ,

in which µ(B) = λmin (B + B T )/2.
Another interesting observation is that if we define
cos ∠k =

(Ark , rk )
,
kArk k2 krk k2

then (5.18) can be rewritten as
krk+1 k22



(Ark , rk ) (Ark , rk )
=
1−
(Ark , Ark ) (rk , rk )

2
= krk k2 1 − cos2 ∠k
krk k22

= krk k22 sin2 ∠k .



(5.20)

5.4. ADDITIVE AND MULTIPLICATIVE PROCESSES

147

At each step the reduction in the residual norm is equal to the sine of the acute angle
between r and Ar. The convergence factor is therefore bounded by
ρ=

max

x ∈ Rn , x6=0

sin ∠(x, Ax),

in which ∠(x, Ax) is the acute angle between x and Ax. The maximum angle
∠(x, Ax) is guaranteed to be less than π/2 when A is positive definite as the above
results show.

5.3.3

Residual Norm Steepest Descent

In the residual norm steepest descent algorithm, the assumption that A is positive
definite is relaxed. In fact, the only requirement is that A is a (square) nonsingular
matrix. At each step the algorithm uses v = AT r and w = Av, giving the following
sequence of operations:
r ← b − Ax, v = AT r,
(5.21)
α ← kvk22 /kAvk22 ,
x ← x + αv.

However, an algorithm based on the above sequence of operations would require
three matrix-by-vector products, which is three times as many as the other algorithms
seen in this section. The number of matrix-by-vector operations can be reduced to
two per step by computing the residual differently. This variant is as follows.
A LGORITHM 5.4 Residual Norm Steepest Descent

1.
2.
3.
4.
5.
6.
7.

Compute r := b − Ax
Until convergence, Do:
v := AT r
Compute Av and α := kvk22 /kAvk22
x := x + αv
r := r − αAv
EndDo

Here, each step minimizes f (x) = kb − Axk22 in the direction −∇f . As it
turns out, this is equivalent to the steepest descent algorithm of Section 5.3.1 applied
to the normal equations AT Ax = AT b. Since AT A is positive definite when A is
nonsingular, then, according to Theorem 5.9, the method will converge whenever A
is nonsingular.

5.4

Additive and Multiplicative Processes

We begin by considering again the block relaxation techniques seen in the previous
chapter. To define these techniques, a set-decomposition of S = {1, 2, . . . , n} is

CHAPTER 5. PROJECTION METHODS

148

considered as the definition of p subsets S1 , . . . , Sp of S with
[
Si ⊆ S,
Si = S.
i=1,···,p

Denote by ni the size of Si and define the subset Si as
Si = {mi (1), mi (2), . . . , mi (ni )}.
Let Vi be the n × ni matrix
Vi = [emi (1) , emi (2) , . . . , emi (ni ) ],
where each ej is the j-th column of the n × n identity matrix.
If the block Jacobi and block Gauss-Seidel algorithms, Algorithms 4.1 and 4.2,
are examined carefully, it can be observed that each individual step in the main loop
(lines 2 to 5) represents an orthogonal projection process over Ki = span{Vi }. Indeed, the equation (4.17) is exactly (5.7) with W = V = Vi . This individual projection step modifies only the components corresponding to the subspace Ki . However,
the general block Jacobi iteration combines these modifications, implicitly adding
them together, to obtain the next iterate xk+1 . Borrowing from the terminology of
domain decomposition techniques, this will be called an additive projection procedure. Generally, an additive projection procedure can be defined for any sequence
of subspaces Ki , not just subspaces spanned by the columns of the identity matrix.
The only requirement is that the subspaces Ki should be distinct, although they are
allowed to overlap.
Let a sequence of p orthogonal systems Vi be given, with the condition that
span{Vi } 6= span{Vj } for i 6= j, and define
Ai = ViT AVi .
The additive projection procedure can be written as
T
yi = A−1
i Vi (b − Axk ),
p
X
Vi y i ,
xk+1 = xk +
i=1

which leads to the following algorithm.
A LGORITHM 5.5 Additive Projection Procedure

1.
2.
3.
4.
5.
6.

For k = 0, 1, . . . , until convergence, Do:
For i = 1, 2, . . . , p Do:
Solve Ai yi = ViT (b − Axk )
EndDo
P
Set xk+1 = xk + pi=1 Vi yi
EndDo

i = 1, . . . , p ,
(5.22)

5.4. ADDITIVE AND MULTIPLICATIVE PROCESSES

149

Defining rk = b − Axk , the residual vector at step k, then clearly
rk+1 = b − Axk+1
= b − Axk −
=

"

I−

p
X

p
X

AVi ViT AVi

i=1

−1

−1 T
Vi
AVi ViT AVi



i=1

#

ViT rk
rk .

Observe that each of the p operators
Pi = AVi ViT AVi

−1

ViT

represents the projector onto the subspace spanned by AVi , and orthogonal to Vi .
Often, the additive processes are used in conjunction with an acceleration parameter
ω, thus (5.22) is replaced by
T
yi = A−1
i Vi (b − Axk ),
p
X
Vi y i .
xk+1 = xk + ω

i = 1, . . . , p ,

i=1

Even more generally, a different parameter ωi can be used for each projection, i.e.,
T
yi = A−1
i Vi (b − Axk ),
p
X
ω i Vi y i .
xk+1 = xk +

i = 1, . . . , p,

i=1

The residual norm in this situation is given by
rk+1 =

I−

p
X

ωi Pi

i=1

!

rk ,

(5.23)

considering the single ω parameter as a particular case. Exercise 15 gives an example
of the choice of ωi which has the effect of producing a sequence with decreasing
residual norms.
We now return to the generic case, where ωi = 1, ∀i. A least-squares option can
be defined by taking for each of the subproblems Li = AKi . In this situation, Pi
becomes an orthogonal projector onto AKi , since
−1
(AVi )T .
Pi = AVi (AVi )T AVi
It is interesting to note that the residual vector obtained after one outer loop is related
to the previous residual by
!
p
X
Pi rk ,
rk+1 = I −
i=1

CHAPTER 5. PROJECTION METHODS

150

where the Pi ’s are now orthogonal projectors. In particular, in the ideal situation
when the AVi ’s are orthogonal to each other, and the total rank of the Pi ’s is n, then
the exact solution would be obtained in one outer step, since in this situation
I−

p
X

Pi = 0.

i=1

Thus, the maximum reduction in the residual norm is achieved when the Vi ’s are
A-orthogonal to one another.
Similar to the Jacobi and Gauss-Seidel iterations, what distinguishes the additive
and multiplicative iterations is that the latter updates the component to be corrected
at step i immediately. Then this updated approximate solution is used to compute the
residual vector needed to correct the next component. The Jacobi iteration uses the
same previous approximation xk to update all the components of the solution. Thus,
the analogue of the block Gauss-Seidel iteration can be defined as follows.
A LGORITHM 5.6 Multiplicative Projection Procedure

1.
2.
3.
4.
5.
6.

Until convergence, Do:
For i = 1, 2, . . . , p Do:
Solve Ai y = ViT (b − Ax)
Set x := x + Vi y
EndDo
EndDo

5.4. ADDITIVE AND MULTIPLICATIVE PROCESSES

151

P ROBLEMS
P-5.1 Consider the linear system Ax = b, where A is a Symmetric Positive Definite matrix.
a. Consider the sequence of one-dimensional projection processes with K = L = span{ei },
where the sequence of indices i is selected in any fashion. Let xnew be a new iterate after one projection step from x and let r = b − Ax, d = A−1 b − x, and
dnew = A−1 b − xnew . Show that
(Adnew , dnew ) = (Ad, d) − (r, ei )2 /aii .
Does this equality, as is, establish convergence of the algorithm?
b. Assume now that i is selected at each projection step to be the index of a component
of largest absolute value in the current residual vector r = b − Ax. Show that

1/2
1
kdnew kA ≤ 1 −
kdkA ,
nκ(A)
in which κ(A) is the spectral condition number of A. [Hint: Use the inequality |eTi r| ≥
n−1/2 krk2 .] Does this prove that the algorithm converges?
P-5.2 Consider the linear system Ax = b, where A is a Symmetric Positive Definite matrix.
Consider a projection step with K = L = span{v} where v is some nonzero vector. Let
xnew be the new iterate after one projection step from x and let d = A−1 b − x, and dnew =
A−1 b − xnew .
a. Show that

(Adnew , dnew ) = (Ad, d) − (r, v)2 /(Av, v).
Does this equality establish convergence of the algorithm?
b. In Gastinel’s method, the vector v is selected in such a way that (v, r) = krk1 , e.g., by
defining the components of v to be vi = sign(eTi r), where r = b − Ax is the current
residual vector. Show that
1/2

1
kdkA ,
kdnew kA ≤ 1 −
nκ(A)
in which κ(A) is the spectral condition number of A. Does this prove that the algorithm
converges?
c. Compare the cost of one step of this method with that of cyclic Gauss-Seidel (see Example 5.1) and that of “optimal” Gauss-Seidel where at each step K = L = span{ei }
and i is a component of largest magnitude in the current residual vector.
P-5.3 In Section 5.3.3, it was shown that taking a one-dimensional projection technique
with K = span {AT r} and L = span{AAT r} is mathematically equivalent to using the
usual steepest descent algorithm applied to the normal equations AT Ax = AT b. Show that
an orthogonal projection method for AT Ax = AT b using a subspace K is mathematically
equivalent to applying a projection method onto K, orthogonally to L = AK for solving the
system Ax = b.
P-5.4 Consider the matrix



1
A = 6
0


−6 0
2 3.
3 2

CHAPTER 5. PROJECTION METHODS

152

a. Find a rectangle or square in the complex plane which contains all the eigenvalues of
A, without computing the eigenvalues.
b. Is the Minimal Residual iteration guaranteed to converge for a linear system with the
matrix A?
P-5.5 Consider the linear system

D1
−E

−F
−D2



x1
x2



=



b1
b2



in which D1 and D2 are both nonsingular matrices of size m each.
a. Define an orthogonal projection method using the set of vectors e1 , . . . , em , i.e., L =
K = span{e1 , . . . , em }. Write down the corresponding projection step (x1 is modified
into x̃1 ). Similarly, write the projection step for the second half of the vectors, i.e.,
when L = K = span{em+1 , . . . , en }.
b. Consider an iteration procedure which consists of performing the two successive halfsteps described above until convergence. Show that this iteration is equivalent to a
(standard) Gauss-Seidel iteration applied to the original system.
c. Now consider a similar idea in which K is taken to be the same as before for each
half-step and L = AK. Write down the iteration procedure based on this approach.
Name another technique to which it is mathematically equivalent.
P-5.6 Consider the linear system Ax = b, where A is a Symmetric Positive Definite matrix.
We define a projection method which uses a two-dimensional space at each step. At a given
step, take L = K = span{r, Ar}, where r = b − Ax is the current residual.

a. For a basis of K use the vector r and the vector p obtained by orthogonalizing Ar
against r with respect to the A-inner product. Give the formula for computing p (no
need to normalize the resulting vector).
b. Write the algorithm for performing the projection method described above.
c. Will the algorithm converge for any initial guess x0 ? Justify the answer. [Hint: Exploit
the convergence results for one-dimensional projection techniques.]

P-5.7 Consider projection methods which update at each step the current solution with linear combinations from two directions: the current residual r and Ar.
a. Consider an orthogonal projection method, i.e., at each step L = K = span{r, Ar}.
Assuming that A is Symmetric Positive Definite, establish convergence of the algorithm.
b. Consider a least-squares projection method in which at each step K = span{r, Ar} and
L = AK. Assuming that A is positive definite (not necessarily symmetric), establish
convergence of the algorithm.
[Hint: The convergence results for any of the one-dimensional projection techniques can be
exploited.]
P-5.8 Assume that the (one-dimensional) Minimal Residual iteration of Section 5.3.2 is
applied to a symmetric positive matrix A. Will the method converge? What will the result
(5.15) become in this case? Both (5.15) and (5.14) suggest a linear convergence with an
estimate for the linear convergence rate given by the formulas. How do these estimated rates
compare for matrices with large condition spectral condition numbers?
P-5.9 The “least-squares” Gauss-Seidel relaxation method defines a relaxation step as xnew =
x + δ ei (same as Gauss-Seidel), but chooses δ to minimize the residual norm of xnew .

5.4. ADDITIVE AND MULTIPLICATIVE PROCESSES

153

a. Write down the resulting algorithm.
b. Show that this iteration is mathematically equivalent to a Gauss-Seidel iteration applied
to the normal equations AT Ax = AT b.
P-5.10 Derive three types of one-dimensional projection algorithms in the same manner as
was done in Section 5.3, by replacing every occurrence of the residual vector r by a vector
ei , a column of the identity matrix.
P-5.11 Derive three types of one-dimensional projection algorithms in the same manner as
was done in Section 5.3, by replacing every occurrence of the residual vector r by a vector
Aei , a column of the matrix A. What would be an “optimal” choice for i at each projection
step? Show that the method is globally convergent in this case.
P-5.12 A minimal residual iteration as defined in Section 5.3.2 can also be defined for an
arbitrary search direction d, not necessarily related to r in any way. In this case, we still
define e = Ad.
a. Write down the corresponding algorithm.
b. Under which condition are all iterates defined?
c. Under which condition on d does the new iterate make no progress, i.e., krk+1 k2 =
krk k2 ?

d. Write a general sufficient condition which must be satisfied by d at each step in order
to guarantee convergence.
P-5.13 Consider the following real-valued functions of the vector variable x, where A and
b are the coefficient matrix and right-hand system of a given linear system Ax = b and
x∗ = A−1 b.
a(x)

=

f (x)
g(x)

=
=

h(x)

=

kx∗ − xk22 ,

kb − Axk22 ,
kAT b − AT Axk22 ,
2(b, x) − (Ax, x).

a. Calculate the gradients of all four functions above.
b. How is the gradient of g related to that of f ?
c. How is the gradient of f related to that of h when A is symmetric?
d. How does the function h relate to the A-norm of the error x∗ − x when A is Symmetric
Positive Definite?
P-5.14 The block Gauss-Seidel iteration can be expressed as a method of successive projections. The subspace K used for each projection is of the form
K = span{ei , ei+1 , . . . , ei+p }.
What is L? Not too commonly used an alternative is to take L = AK, which amounts to
solving a least-squares problem instead of a linear system. Develop algorithms for this case.
What are the advantages and disadvantages of the two approaches (ignoring convergence
rates)?
P-5.15 Let the scalars ωi in the additive projection procedure satisfy the constraint
p
X
i=1

ωi = 1.

(5.24)

CHAPTER 5. PROJECTION METHODS

154

It is not assumed that each ωi is positive but only that |ωi | ≤ 1 for all i. The residual vector
is given by the Formula (5.23) or, equivalently,
rk+1 =

p
X
i=1

ωi (I − Pi )rk .

a. Show that in the least-squares case, we have krk+1 k2 ≤ krk k2 for any choice of ωi ’s
which satisfy the constraint (5.24).
b. We wish to choose a set of ωi ’s such that the 2-norm of the residual vector rk+1 is
minimal. Determine this set of ωi ’s, assuming that the vectors (I − Pi )rk are all
linearly independent.
c. The “optimal” ωi ’s provided in the previous question require the solution of a p × p
Symmetric Positive Definite linear system. Let zi ≡ Vi yi be the “search directions”
provided by each of the individual projection steps. To avoid this difficulty, a simpler
strategy is used which consists of performing p successive minimal residual iterations
along these search directions, as is described below.
r := rk
For i = 1, . . . , p Do:
ωi := (r, Azi )/(Azi , Azi )
x := x + ωi zi
r := r − ωi Azi
EndDo
Show that krk+1 k2 ≤ krk k2 . Give a sufficient condition to ensure global convergence.
P-5.16 Consider the iteration: xk+1 = xk + αk dk , where dk is a vector called the direction
of search, and αk is a scalar. It is assumed throughout that dk is a nonzero vector. Consider
a method which determines xk+1 so that the residual krk+1 k2 is the smallest possible.
a. Determine αk so that krk+1 k2 is minimal.

b. Show that the residual vector rk+1 obtained in this manner is orthogonal to Adk .
c. Show that the residual vectors satisfy the relation:
krk+1 k2 ≤ krk k2 sin ∠(rk , Adk ).
d. Assume that at each step k, we have (rk , Adk ) 6= 0. Will the method always converge?
e. Now assume that A is positive definite and select at each step dk ≡ rk . Prove that the
method will converge for any initial guess x0 .

P-5.17 Consider the iteration: xk+1 = xk + αk dk , where dk is a vector called the direction
of search, and αk is a scalar. It is assumed throughout that dk is a vector which is selected
in the form dk = AT fk where fk is some nonzero vector. Let x∗ = A−1 b be the exact
solution. Now consider a method which at each step k determines xk+1 so that the error
norm kx∗ − xk+1 k2 is the smallest possible.

a. Determine αk so that kx∗ − xk+1 k2 is minimal and show that the error vector ek+1 =
x∗ − xk+1 is orthogonal to dk . The expression of αk should not contain unknown
quantities (e.g., x∗ or ek ).

b. Show that kek+1 k2 ≤ kek k2 sin ∠(ek , dk ).

c. Establish the convergence of the algorithm for any x0 , when fk ≡ rk for all k.

5.4. ADDITIVE AND MULTIPLICATIVE PROCESSES

155

N OTES AND R EFERENCES . Initially, the term projection methods was used mainly to describe one-dimensional techniques such as those presented in Section 5.3. An excellent account of what has been
done in the late 1950s and early 1960s can be found in Householder’s book [173] as well as Gastinel
[140]. For more general, including nonlinear, projection processes, a good reference is Kranoselskii
and co-authors [192].
Projection techniques are present in different forms in many other areas of scientific computing
and can be formulated in abstract Hilbert functional spaces. The terms Galerkin and Petrov-Galerkin
techniques are used commonly in finite element methods to describe projection methods on finite element spaces. The principles are identical to those seen in this chapter.

156

CHAPTER 5. PROJECTION METHODS

Chapter 6

KRYLOV SUBSPACE METHODS PART I

The next two chapters explore a few methods which are considered currently to be among the
most important iterative techniques available for solving large linear systems. These techniques
are based on projection processes, both orthogonal and oblique, onto Krylov subspaces, which
are subspaces spanned by vectors of the form p(A)v where p is a polynomial. In short, these
techniques approximate A−1 b by p(A)b, where p is a “good” polynomial. This chapter covers
methods derived from, or related to, the Arnoldi orthogonalization. The next chapter covers
methods based on Lanczos biorthogonalization.

6.1

Introduction

Recall from the previous chapter that a general projection method for solving the
linear system
Ax = b,
(6.1)
extracts an approximate solution xm from an affine subspace x0 + Km of dimension
m by imposing the Petrov-Galerkin condition
b − Axm ⊥ Lm ,
where Lm is another subspace of dimension m. Here, x0 represents an arbitrary
initial guess to the solution. A Krylov subspace method is a method for which the
subspace Km is the Krylov subspace
Km (A, r0 ) = span{r0 , Ar0 , A2 r0 , . . . , Am−1 r0 } ,
where r0 = b − Ax0 . When there is no ambiguity, Km (A, r0 ) will be denoted by
Km . The different versions of Krylov subspace methods arise from different choices
of the subspace Lm and from the ways in which the system is preconditioned, a topic
that will be covered in detail in later chapters.
Viewed from the angle of approximation theory, it is clear that the approximations obtained from a Krylov subspace method are of the form
A−1 b ≈ xm = x0 + qm−1 (A)r0 ,
157

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

158

in which qm−1 is a certain polynomial of degree m − 1. In the simplest case where
x0 = 0, then
A−1 b ≈ qm−1 (A)b .

In other words, A−1 b is approximated by qm−1 (A)b.
Although all the techniques provide the same type of polynomial approximations, the choice of Lm , i.e., the constraints used to build these approximations, will
have an important effect on the iterative technique. Two broad choices for Lm give
rise to the best-known techniques. The first is simply Lm = Km and the minimumresidual variation Lm = AKm . A few of the numerous methods in this category will
be described in this chapter. The second class of methods is based on defining Lm
to be a Krylov subspace method associated with AT , namely, Lm = Km (AT , r0 ).
Methods of this class will be covered in the next chapter. There are also block extensions of each of these methods termed block Krylov subspace methods, which will
be discussed only briefly. Note that a projection method may have several different implementations, giving rise to different algorithms which are all mathematically
equivalent.

6.2

Krylov Subspaces

In this section we consider projection methods on Krylov subspaces, i.e., subspaces
of the form
Km (A, v) ≡ span {v, Av, A2 v, . . . , Am−1 v}
(6.2)

which will be denoted simply by Km if there is no ambiguity. The dimension of
the subspace of approximants increases by one at each step of the approximation
process. A few elementary properties of Krylov subspaces can be established. A
first property is that Km is the subspace of all vectors in Rn which can be written
as x = p(A)v, where p is a polynomial of degree not exceeding m − 1. Recall that
the minimal polynomial of a vector v is the nonzero monic polynomial p of lowest
degree such that p(A)v = 0. The degree of the minimal polynomial of v with respect
to A is often called the grade of v with respect to A, or simply the grade of v if there
is no ambiguity. A consequence of the Cayley-Hamilton theorem is that the grade of
v does not exceed n. The following proposition is easy to prove.
Proposition 6.1 Let µ be the grade of v. Then Kµ is invariant under A and Km =
Kµ for all m ≥ µ.
It was mentioned above that the dimension of Km is nondecreasing. In fact, the
following proposition determines the dimension of Km in general.
Proposition 6.2 The Krylov subspace Km is of dimension m if and only if the grade
µ of v with respect to A is not less than m, i.e.,
dim(Km ) = m

↔

grade(v) ≥ m.

(6.3)

Therefore,
dim(Km ) = min {m, grade(v)}.

(6.4)

6.2. KRYLOV SUBSPACES

159

Proof. The vectors v, Av, . . . , Am−1 v form a basis of Km if and only if for any
set of m scalars
P αi , i = i0, . . . , m − 1, where at least one αi is nonzero, the linear
combination m−1
i=0 αi A v is nonzero. This is equivalent to the condition that the
only polynomial of degree ≤ m − 1 for which p(A)v = 0 is the zero polynomial.
The equality (6.4) is a consequence of the previous proposition.
Given a certain subspace X, recall that A|X denotes the restriction of A to X. If
Q is a projector onto X, the section of the operator A in X is the operator from X
onto itself defined by QA|X . The following proposition characterizes the product of
polynomials of A by v in terms of the section of A in Km .
Proposition 6.3 Let Qm be any projector onto Km and let Am be the section of A
to Km , that is, Am = Qm A|Km . Then for any polynomial q of degree not exceeding
m − 1,
q(A)v = q(Am )v ,
and for any polynomial of degree ≤ m,
Qm q(A)v = q(Am )v .
Proof. First we prove that q(A)v = q(Am )v for any polynomial q of degree ≤ m−1.
It is sufficient to show the property for the monic polynomials qi (t) ≡ ti , i =
0, . . . , m − 1. The proof is by induction. The property is true for the polynomial
q0 (t) ≡ 1. Assume that it is true for qi (t) ≡ ti :
qi (A)v = qi (Am )v .
Multiplying the above equation by A on both sides yields
qi+1 (A)v = Aqi (Am )v .
If i + 1 ≤ m − 1 the vector on the left-hand side belongs to Km , and therefore if the
above equation is multiplied on both sides by Qm , then
qi+1 (A)v = Qm Aqi (Am )v.
Looking at the right-hand side we observe that qi (Am )v belongs to Km . Hence,
qi+1 (A)v = Qm A|Km qi (Am )v = qi+1 (Am )v,
which proves that the property is true for i + 1, provided i + 1 ≤ m − 1. For the case
i + 1 = m, it only remains to show that Qm qm (A)v = qm (Am )v, which follows
from qm−1 (A)v = qm−1 (Am )v by simply multiplying both sides by Qm A.

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

160

6.3

Arnoldi’s Method

Arnoldi’s method [9] is an orthogonal projection method onto Km for general nonHermitian matrices. The procedure was first introduced in 1951 as a means of reducing a dense matrix into Hessenberg form with a unitary transformation. In his paper,
Arnoldi hinted that the eigenvalues of the Hessenberg matrix obtained from a number
of steps smaller than n could provide accurate approximations to some eigenvalues
of the original matrix. It was later discovered that this strategy leads to an efficient
technique for approximating eigenvalues of large sparse matrices and the technique
was then extended to the solution of large sparse linear systems of equations. The
method will first be described theoretically, i.e., assuming exact arithmetic, then implementation details will be addressed.

6.3.1

The Basic Algorithm

Arnoldi’s procedure is an algorithm for building an orthogonal basis of the Krylov
subspace Km . In exact arithmetic, one variant of the algorithm is as follows:
A LGORITHM 6.1 Arnoldi

1.
2.
3.
4.
5.
6.
7.
8.

Choose a vector v1 , such that kv1 k2 = 1
For j = 1, 2, . . . , m Do:
Compute hij = (Avj , vi ) for i = 1, 2, . . . , j
P
Compute wj := Avj − ji=1 hij vi
hj+1,j = kwj k2
If hj+1,j = 0 then Stop
vj+1 = wj /hj+1,j
EndDo

At each step, the algorithm multiplies the previous Arnoldi vector vj by A and
then orthonormalizes the resulting vector wj against all previous vi ’s by a standard
Gram-Schmidt procedure. It will stop if the vector wj computed in line 4 vanishes.
This case will be examined shortly. Now a few simple properties of the algorithm
are proved.
Proposition 6.4 Assume that Algorithm 6.1 does not stop before the m-th step. Then
the vectors v1 , v2 , . . . , vm form an orthonormal basis of the Krylov subspace
Km = span{v1 , Av1 , . . . , Am−1 v1 }.
Proof. The vectors vj , j = 1, 2, . . . , m, are orthonormal by construction. That they
span Km follows from the fact that each vector vj is of the form qj−1 (A)v1 where
qj−1 is a polynomial of degree j −1. This can be shown by induction on j as follows.
The result is clearly true for j = 1, since v1 = q0 (A)v1 with q0 (t) ≡ 1. Assume that
the result is true for all integers ≤ j and consider vj+1 . We have
hj+1,j vj+1 = Avj −

j
X
i=1

hij vi = Aqj−1 (A)v1 −

j
X
i=1

hij qi−1 (A)v1

(6.5)

6.3. ARNOLDI’S METHOD

161

which shows that vj+1 can be expressed as qj (A)v1 where qj is of degree j and
completes the proof.
Proposition 6.5 Denote by Vm , the n × m matrix with column vectors v1 , . . ., vm ,
by H̄m , the (m + 1) × m Hessenberg matrix whose nonzero entries hij are defined
by Algorithm 6.1, and by Hm the matrix obtained from H̄m by deleting its last row.
Then the following relations hold:
AVm = Vm Hm + wm eTm

(6.6)

= Vm+1 H̄m ,

(6.7)

= Hm .

(6.8)

VmT AVm

Proof. The relation (6.7) follows from the following equality which is readily derived
from lines 4, 5, and 7 of Algorithm 6.1,
Avj =

j+1
X

hij vi ,

j = 1, 2, . . . , m.

(6.9)

i=1

Relation (6.6) is a matrix reformulation of (6.9). Relation (6.8) follows by multiplying both sides of (6.6) by VmT and making use of the orthonormality of {v1 , . . . , vm }.
The result of the proposition is illustrated in Figure 6.1.
Hm

A

Vm

=

Vm

+ wm eTm

Figure 6.1: The action of A on Vm gives Vm Hm plus a rank-one matrix.
As was noted earlier, the algorithm may break down in case the norm of wj
vanishes at a certain step j. In this case, the vector vj+1 cannot be computed and the
algorithm stops. Still to be determined are the conditions under which this situation
occurs.
Proposition 6.6 Arnoldi’s algorithm breaks down at step j (i.e., hj+1,j = 0 in Line
5 of Algorithm 6.1), if and only if the minimal polynomial of v1 is of degree j. Moreover, in this case the subspace Kj is invariant under A.

162

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Proof. If the degree of the minimal polynomial is j, then wj must be equal to zero.
Indeed, otherwise vj+1 can be defined and as a result Kj+1 would be of dimension
j + 1. Then Proposition 6.2 would imply that µ ≥ j + 1, which is a contradiction. To
prove the converse, assume that wj = 0. Then the degree µ of the minimal polynomial of v1 is such that µ ≤ j. Moreover, it is impossible that µ < j. Otherwise, by
the first part of this proof, the vector wµ would be zero and the algorithm would have
stopped at the earlier step number µ. The rest of the result follows from Proposition
6.1.
A corollary of the proposition is that a projection method onto the subspace Kj
will be exact when a breakdown occurs at step j. This result follows from Proposition
5.6 seen in Chapter 5. It is for this reason that such breakdowns are often called lucky
breakdowns.

6.3.2

Practical Implementations

In the previous description of the Arnoldi process, exact arithmetic was assumed,
mainly for simplicity. In practice, much can be gained by using the Modified GramSchmidt or the Householder algorithm instead of the standard Gram-Schmidt algorithm. With the Modified Gram-Schmidt alternative the algorithm takes the following
form:
A LGORITHM 6.2 Arnoldi-Modified Gram-Schmidt

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Choose a vector v1 of norm 1
For j = 1, 2, . . . , m Do:
Compute wj := Avj
For i = 1, . . . , j Do:
hij = (wj , vi )
wj := wj − hij vi
EndDo
hj+1,j = kwj k2 . If hj+1,j = 0 Stop
vj+1 = wj /hj+1,j
EndDo

In exact arithmetic, this algorithm and Algorithm 6.1 are mathematically equivalent.
In the presence of round-off the above formulation is much more reliable. However,
there are cases where cancellations are so severe in the orthogonalization steps that
even the Modified Gram-Schmidt option is inadequate. In this case, two further
improvements can be utilized.
The first improvement resorts to double orthogonalization. Whenever the final
vector wj obtained at the end of the main loop in the above algorithm has been
computed, a test is performed to compare its norm with the norm of the initial wj
(which is kAvj k2 ). If the reduction falls below a certain threshold, indicating severe
cancellation might have occurred, a second orthogonalization is made. It is known

6.3. ARNOLDI’S METHOD

163

from a result by Kahan that additional orthogonalizations are superfluous (see, for
example, Parlett [224]).
The second improvement is to use a different technique altogether. From the
numerical point of view, one of the most reliable orthogonalization techniques is the
Householder algorithm. Recall from Chapter 1 that the Householder orthogonalization uses reflection matrices of the form Pk = I − 2wk wkT to transform a matrix X
into upper triangular form. In the Arnoldi algorithm, the column vectors of the matrix X to be orthonormalized are not available ahead of time. Instead, the next vector
is obtained as Avj , where vj is the current basis vector. In the Householder algorithm an orthogonal column vi is obtained as P1 P2 . . . Pi ei where P1 , . . . , Pi are the
previous Householder matrices. This vector is then multiplied by A and the previous
Householder transforms are applied to it. Then, the next Householder transform is
determined from the resulting vector. This procedure is described in the following
algorithm, which was originally proposed by Walker [303].
A LGORITHM 6.3 Householder Arnoldi

1.
2.
3.
4.
5.
6.
7.
8.
9.

Select a nonzero vector v ; Set z1 = v
For j = 1, . . . , m, m + 1 Do:
Compute the Householder unit vector wj such that
(wj )i = 0, i = 1, . . . , j − 1 and
(Pj zj )i = 0, i = j + 1, . . . , n, where Pj = I − 2wj wjT
hj−1 = Pj zj
vj = P1 P2 . . . Pj ej
If j ≤ m compute zj+1 := Pj Pj−1 . . . P1 Avj
EndDo

For details regarding the determination of the Householder vector wj in the third
to fifth lines and on its use in the sixth to eight lines, see Chapter 1. Recall that
the matrices Pj need not be formed explicitly. To obtain hj−1 from zj in line 6,
zero out all the components from position j + 1 through n of the n-vector zj and
change its j-th component, leaving all others unchanged. Thus, the n × m matrix
[h0 , h1 , . . . , hm ] will have the same structure as the matrix Xm of equation (1.27)
in Chapter 1. By comparison with the Householder algorithm seen in Chapter 1,
we can infer that the above process computes the QR factorization of the matrix
v, Av1 , Av2 , Av3 , . . . , Avm . Define
Qj = Pj Pj−1 . . . P1 .

(6.10)

The definition of zj+1 in line 8 of the algorithm yields the relation,
Qj Avj = zj+1 .
After the next Householder transformation Pj+1 is applied in line 6, hj satisfies the
relation,
hj = Pj+1 zj+1 = Pj+1 Qj Avj = Qj+1 Avj .
(6.11)

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

164

Now observe that since the components j + 2, . . . , n of hj are zero, then Pi hj = hj
for any i ≥ j + 2. Hence,
hj = Pm Pm−1 . . . Pj+2 hj = Qm Avj ,

j = 1, . . . , m.

This leads to the factorization,
Qm [v, Av1 , Av2 , . . . , Avm ] = [h0 , h1 , . . . , hm ]

(6.12)

where the matrix [h0 , . . . , hm ] is n × (m + 1) and is upper triangular and Qm is
unitary.
It is important to relate the vectors vi and hi defined in this algorithm with vectors
of the standard Arnoldi process. Let H̄m be the (m + 1) × m matrix obtained from
the first m + 1 rows of the n × m matrix [h1 , . . . , hm ]. Since Qj+1 is unitary we
T
have Q−1
j+1 = Qj+1 and hence, from the relation (6.11)
Avj = QTj+1

j+1
X

hij ei =

i=1

j+1
X

hij QTj+1 ei

i=1

where each ei is the i-th column of the n × n identity matrix. Since Pk ei = ei for
i < k, it is not difficult to see that
(6.13)
QTj+1 ei = P1 . . . Pj+1 ei = vi , for i ≤ j + 1.
P
This yields the relation Avj = j+1
i=1 hij vi , for j = 1, . . . , m, which can be written
in matrix form as
AVm = Vm+1 H̄m .
This is identical with the relation (6.7) obtained with the Gram-Schmidt or Modified
Gram-Schmidt implementation. The vi ’s form an orthonormal basis of the Krylov
subspace Km and are identical with the vi ’s defined by the Arnoldi process, apart
from a possible sign difference.
Although the Householder algorithm is numerically more viable than the GramSchmidt or Modified Gram-Schmidt versions, it is also more expensive. The cost of
each of the outer loops, corresponding to the j control variable, is dominated by lines
7 and 8. These apply the reflection matrices Pi for i = 1, . . . , j to a vector, perform
the matrix-vector product Avj , and then apply the matrices Pi for i = j, j − 1, . . . , 1
to a vector. The application of each Pi to a vector is performed as
(I − 2wi wiT )v = v − σwi

with

σ = 2wiT v.

This is essentially the result of a dot-product of length n − i + 1 followed by a vector
update of the same length, requiring a total of about 4(n − i + 1) operations for
each application of Pi . Neglecting the last step, the number of operations due to the
Householder transformations alone approximately totals

j
m 
m X
X
X
j(j − 1)
4
jn −
≈ 4m2 n − m3 .
8(n − i + 1) = 8
2
3
j=1 i=1

j=1

6.4. ARNOLDI’S METHOD FOR LINEAR SYSTEMS (FOM)

165

The table below shows the costs of different orthogonalization procedures. GS stands
for Gram-Schmidt, MGS for Modified Gram-Schmidt, MGSR for Modified GramSchmidt with reorthogonalization, and HO for Householder.
GS

MGS

MGSR

HO

Flops

2m2 n

2m2 n

4m2 n

Storage

(m + 1)n

(m + 1)n

(m + 1)n

4m2 n − 43 m3

(m + 1)n − 21 m2

The number of operations shown for MGSR corresponds to the worst case scenario
when a second orthogonalization is performed each time. In practice, the number
of operations is usually closer to that of the standard MGS. Regarding storage, the
vectors vi , i = 1, . . . , m need not be saved. In the algorithms for solving linear
systems, these vectors are needed at the end of the process. This issue will be covered
with the Householder implementations of these algorithms. For now, assume that
only the wi ’s are saved. The small gain in memory usage in the Householder version
can be explained by the diminishing lengths of the vectors required at each step of
the Householder transformation. However, this difference is negligible relative to the
whole storage requirement of the algorithm, because m ≪ n, typically.
The Householder orthogonalization may be a reasonable choice when developing
general purpose, reliable software packages where robustness is a critical criterion.
This is especially true for solving eigenvalue problems since the cost of orthogonalization is then amortized over several eigenvalue/eigenvector calculations. When
solving linear systems, the Modified Gram-Schmidt orthogonalization, with a reorthogonalization strategy based on a measure of the level of cancellation, is more
than adequate in most cases.

6.4

Arnoldi’s Method for Linear Systems (FOM)

Given an initial guess x0 to the original linear system Ax = b, we now consider an
orthogonal projection method as defined in the previous chapter, which takes L =
K = Km (A, r0 ), with
Km (A, r0 ) = span{r0 , Ar0 , A2 r0 , . . . , Am−1 r0 },

(6.14)

in which r0 = b − Ax0 . This method seeks an approximate solution xm from the
affine subspace x0 + Km of dimension m by imposing the Galerkin condition
b − Axm ⊥ Km .
If v1 = r0 /kr0 k2 in Arnoldi’s method, and we set β = kr0 k2 , then
VmT AVm = Hm
by (6.8) and
VmT r0 = VmT (βv1 ) = βe1 .

(6.15)

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

166

As a result, the approximate solution using the above m-dimensional subspaces is
given by
x m = x 0 + Vm y m ,
ym =

−1
Hm
(βe1 ).

(6.16)
(6.17)

A method based on this approach and called the Full Orthogonalization Method
(FOM) is described next. Modified Gram-Schmidt is used in the Arnoldi procedure.
A LGORITHM 6.4 Full Orthogonalization Method (FOM)

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.

Compute r0 = b − Ax0 , β := kr0 k2 , and v1 := r0 /β
Define the m × m matrix Hm = {hij }i,j=1,...,m ; Set Hm = 0
For j = 1, 2, . . . , m Do:
Compute wj := Avj
For i = 1, . . . , j Do:
hij = (wj , vi )
wj := wj − hij vi
EndDo
Compute hj+1,j = kwj k2 . If hj+1,j = 0 set m := j and Goto 12
Compute vj+1 = wj /hj+1,j .
EndDo
−1 (βe ) and x = x + V y
Compute ym = Hm
1
m
0
m m

The above algorithm depends on a parameter m which is the dimension of the
Krylov subspace. In practice it is desirable to select m in a dynamic fashion. This
would be possible if the residual norm of the solution xm is available inexpensively
(without having to compute xm itself). Then the algorithm can be stopped at the
appropriate step using this information. The following proposition gives a result in
this direction.
Proposition 6.7 The residual vector of the approximate solution xm computed by
the FOM Algorithm is such that
b − Axm = −hm+1,m eTm ym vm+1
and, therefore,
kb − Axm k2 = hm+1,m |eTm ym |.

(6.18)

Proof. We have the relations,
b − Axm = b − A(x0 + Vm ym )
= r0 − AVm ym

= βv1 − Vm Hm ym − hm+1,m eTm ym vm+1 .
By the definition of ym , Hm ym = βe1 , and so βv1 − Vm Hm ym = 0 from which the
result follows.

6.4. ARNOLDI’S METHOD FOR LINEAR SYSTEMS (FOM)

167

A rough estimate of the cost of each step of the algorithm is determined as follows. If N z(A) is the number of nonzero elements of A, then m steps of the Arnoldi
procedure will require m matrix-vector products at the cost of 2m × N z(A). Each
of the Gram-Schmidt steps costs approximately 4 × j × n operations, which brings
the total over the m steps to approximately 2m2 n. Thus, on the average, a step of
FOM costs approximately
2N z(A) + 2mn.
Regarding storage, m vectors of length n are required to save the basis Vm . Additional vectors must be used to keep the current solution and right-hand side, and a
scratch vector for the matrix-vector product. In addition, the Hessenberg matrix Hm
must be saved. The total is therefore roughly
(m + 3)n +

m2
.
2

In most situations m is small relative to n, so this cost is dominated by the first term.

6.4.1

Variation 1: Restarted FOM

Consider now the algorithm from a practical viewpoint. As m increases, the computational cost increases at least as O(m2 n) because of the Gram-Schmidt orthogonalization. The memory cost increases as O(mn). For large n this limits the largest
value of m that can be used. There are two remedies. The first is to restart the
algorithm periodically and the second is to “truncate” the orthogonalization in the
Arnoldi algorithm. In this section we consider the first of these two options, which
is described below.
A LGORITHM 6.5 Restarted FOM (FOM(m))

1.
2.
3.
4.
5.

Compute r0 = b − Ax0 , β = kr0 k2 , and v1 = r0 /β .
Generate the Arnoldi basis and the matrix Hm using the Arnoldi algorithm
starting with v1 .
−1 βe and x = x + V y . If satisfied then Stop.
Compute ym = Hm
1
m
0
m m
Set x0 := xm and go to 1.

There are many possible variations to this basic scheme. One that is generally
more economical in practice is based on the observation that sometimes a small m is
sufficient for convergence and sometimes the largest possible m is necessary. Hence,
the idea of averaging over different values of m. Start the algorithm with m = 1 and
increment m by one in line 5 until a certain mmax is reached, after which m is reset
to one, or kept the same. These variations will not be considered here.
Example 6.1. Table 6.1 shows the results of applying FOM(10) with no preconditioning to three of the test problems described in Section 3.7. The column labeled
Iters shows the total actual number of matrix-vector multiplications (matvecs) required to converge. The stopping criterion used is that the 2-norm of the residual be

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

168
Matrix

Iters

Kflops

Residual

Error

F2DA

109

4442

0.36E-03

0.67E-04

F3D

66

11664

0.87E-03

0.35E-03

ORS

300

13558

0.26E+00

0.71E-04

Table 6.1: A test run of FOM with no preconditioning.
reduced by a factor of 107 relative to the 2-norm of the initial residual. A maximum
of 300 matvecs are allowed. Kflops is the total number of floating point operations
performed, in thousands. Residual and Error represent the two-norm of the residual
and error vectors, respectively. Note that the method did not succeed in solving the
third problem.

6.4.2

Variation 2: IOM and DIOM

A second alternative to FOM is to truncate the Arnoldi recurrence. Specifically, an
integer k is selected and the following “incomplete” orthogonalization is performed.
A LGORITHM 6.6 Incomplete Orthogonalization Process

1.
2.
3.
4.
5.
6.
7.
8.

For j = 1, 2, . . . , m Do:
Compute wj := Avj
For i = max{1, j − k + 1}, . . . , j Do:
hi,j = (wj , vi )
wj := wj − hij vi
EndDo
Compute hj+1,j = kwj k2 and vj+1 = wj /hj+1,j
EndDo

The number of directions k against which to orthogonalize may be dictated by
memory limitations. The Incomplete Orthogonalization Method (IOM) consists of
performing the above incomplete orthogonalization procedure and computing an approximate solution using the same formulas (6.16) and (6.17).
A LGORITHM 6.7 IOM Algorithm

Run a modification of Algorithm 6.4 in which the Arnoldi process in lines
3 to 11 is replaced by the Incomplete Orthogonalization process and every
other computation remains unchanged.
It is now necessary to keep only the k previous vi vectors. The others are not
needed in the above process and may be discarded. However, the difficulty remains that when the solution is computed by formula (6.16), all the vectors vi for

6.4. ARNOLDI’S METHOD FOR LINEAR SYSTEMS (FOM)

169

i = 1, 2, . . . , m are required. One option is to recompute them at the end, but essentially this doubles the cost of the algorithm. Fortunately, a formula can be developed
whereby the current approximate solution xm can be updated from the previous approximation xm−1 and a small number of vectors that are also updated at each step.
This progressive formulation of the solution leads to an algorithm termed Direct IOM
(DIOM) which we now derive.
The Hessenberg matrix Hm obtained from the incomplete orthogonalization process has a band structure with a bandwidth of k + 1. For example, when k = 3 and
m = 5, it is of the form


h11 h12 h13
 h21 h22 h23 h24




Hm = 
h32 h33 h34 h35 
(6.19)
.

h43 h44 h45 
h54 h55
The Direct version of IOM is derived from exploiting the special structure of the
LU factorization, Hm = Lm Um , of the matrix Hm . Assuming no pivoting is used,
the matrix Lm is unit lower bidiagonal and Um is banded upper triangular, with k
diagonals. Thus, the above matrix has a factorization of the form

 

1
u11 u12 u13
 l21 1
 

u22 u23 u24

 

×
Hm = 
l32 1
u33 u34 u35 

 
.



l43 1
u44 u45 
l54 1
u55
The approximate solution is then given by

−1 −1
xm = x0 + Vm Um
Lm (βe1 ).

Defining
and

−1
Pm ≡ Vm Um

zm = L−1
m (βe1 ),
the approximate solution is given by
xm = x0 + Pm zm .

(6.20)

Because of the structure of Um , Pm can be updated easily. Indeed, equating the
last columns of the matrix relation Pm Um = Vm yields
m
X

uim pi = vm ,

i=m−k+1

which allows the vector pm to be computed from the previous pi ’s and vm :
"
#
m−1
X
1
vm −
uim pi .
pm =
umm
i=m−k+1

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

170

In addition, because of the structure of Lm , we have the relation


zm−1
zm =
ζm
in which
ζm = −lm,m−1 ζm−1 .
From (6.20),



zm−1
xm = x0 + [Pm−1 , pm ]
= x0 + Pm−1 zm−1 + ζm pm .
ζm
Noting that x0 + Pm−1 zm−1 = xm−1 , it follows that the approximation xm can be
updated at each step by the relation,
xm = xm−1 + ζm pm

(6.21)

where pm is defined above. This gives the following algorithm, called the Direct
Incomplete Orthogonalization Method (DIOM).
A LGORITHM 6.8 DIOM

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Choose x0 and compute r0 = b − Ax0 , β := kr0 k2 , v1 := r0 /β .
For m = 1, 2, . . . , until convergence Do:
Compute him , i = max{1, m − k + 1}, . . . , m and vm+1 as in
lines 2-7 of Algorithm (6.6).
Update the LU factorization of Hm , i.e., obtain the last column
of Um using the previous k pivots. If umm = 0 Stop.
ζm = { if m
β, else − lm,m−1
 ζm−1 }
 = 1 then
Pm−1
−1
pm = umm vm − i=m−k+1 uim pi ( for i ≤ 0 set uim pi ≡ 0)
xm = xm−1 + ζm pm
EndDo

The costs of the above algorithm as well as the IOM algorithm are the subject of
Exercise 6.
Observe that (6.6) is still valid and as a consequence, Proposition 6.7, which is
based on it, still holds. That is because the orthogonality properties were not used to
derive the two relations therein. A result of this is that Equation (6.18) still holds and
it is then easy to show that
kb − Axm k2 = hm+1,m |eTm ym | = hm+1,m

ζm
.
umm

DIOM can also be derived by imposing the properties that are satisfied by the residual
vector and the conjugate directions, i.e., the pi ’s. Note that the above algorithm is
based implicitly on Gaussian elimination without pivoting for the solution of the
Hessenberg system Hm ym = βe1 . This may cause a premature termination in line

6.5. GMRES

171

6. Fortunately, an implementation is available which relies on Gaussian elimination
with partial pivoting. The details of this variant can be found in [240].
Since the residual vector is a scalar multiple of vm+1 and since the vi ’s are no
longer orthogonal, IOM and DIOM are not orthogonal projection techniques. They
can, however, be viewed as oblique projection techniques onto Km and orthogonal
to an artificially constructed subspace.
Proposition 6.8 IOM and DIOM are mathematically equivalent to a projection process onto Km and orthogonally to
Lm = span{z1 , z2 , . . . , zm }
where
zi = vi − (vi , vm+1 )vm+1 ,

i = 1, . . . , m.

Proof. The proof is an immediate consequence of the fact that rm is a multiple of
vm+1 and by construction, vm+1 is orthogonal to all zi ’s defined in the proposition.
The following simple properties can be shown:
• The residual vectors ri , i = 1, . . . , m, are “locally” orthogonal,
(rj , ri ) = 0,

for

|i − j| ≤ k, i 6= j.

(6.22)

• The pj ’s are locally A-orthogonal to the Arnoldi vectors, i.e.,
(Apj , vi ) = 0 for

j − k + 1 < i < j.

(6.23)

• For the case k = ∞ (full orthogonalization) the pj ’s are semi-conjugate, i.e.,
(Apj , pi ) = 0 for

6.5

i < j.

(6.24)

GMRES

The Generalized Minimum Residual Method (GMRES) is a projection method based
on taking K = Km and L = AKm , in which Km is the m-th Krylov subspace with
v1 = r0 /kr0 k2 . As seen in Chapter 5, such a technique minimizes the residual norm
over all vectors in x0 + Km . The implementation of an algorithm based on this
approach is similar to that of the FOM algorithm. We first describe the basic idea
and then discuss practical details and a few variations.

172

6.5.1

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

The Basic GMRES Algorithm

There are two ways to derive the algorithm. The first way exploits the optimality
property and the relation (6.7). Any vector x in x0 + Km can be written as
x = x0 + Vm y,

(6.25)

J(y) = kb − Axk2 = kb − A (x0 + Vm y) k2 ,

(6.26)

where y is an m-vector. Defining

the relation (6.7) results in
b − Ax = b − A (x0 + Vm y)
= r0 − AVm y

= βv1 − Vm+1 H̄m y


= Vm+1 βe1 − H̄m y .

(6.27)

Since the column-vectors of Vm+1 are orthonormal, then

J(y) ≡ kb − A (x0 + Vm y) k2 = kβe1 − H̄m yk2 .

(6.28)

The GMRES approximation is the unique vector of x0 +Km which minimizes (6.26).
By (6.25) and (6.28), this approximation can be obtained quite simply as xm =
x0 + Vm ym where ym minimizes the function J(y) = kβe1 − H̄m yk2 , i.e.,
x m = x 0 + Vm y m ,

where

ym = argminy kβe1 − H̄m yk2 .

(6.29)
(6.30)

The minimizer ym is inexpensive to compute since it requires the solution of an
(m + 1) × m least-squares problem where m is typically small. This gives the
following algorithm.
A LGORITHM 6.9 GMRES

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.

Compute r0 = b − Ax0 , β := kr0 k2 , and v1 := r0 /β
For j = 1, 2, . . . , m Do:
Compute wj := Avj
For i = 1, . . . , j Do:
hij := (wj , vi )
wj := wj − hij vi
EndDo
hj+1,j = kwj k2 . If hj+1,j = 0 set m := j and go to 11
vj+1 = wj /hj+1,j
EndDo
Define the (m + 1) × m Hessenberg matrix H̄m = {hij }1≤i≤m+1,1≤j≤m .
Compute ym the minimizer of kβe1 − H̄m yk2 and xm = x0 + Vm ym .

The second way to derive the GMRES algorithm is to use the equations (5.7)
with Wm = AVm . This is the subject of Exercise 5.

6.5. GMRES

6.5.2

173

The Householder Version

The previous algorithm utilizes the Modified Gram-Schmidt orthogonalization in the
Arnoldi process. Section 6.3.2 described a Householder variant of the Arnoldi process which is numerically more robust than Gram-Schmidt. Here, we focus on a
modification of GMRES which retrofits the Householder orthogonalization. Section
6.3.2 explained how to get the vj and the columns of H̄m+1 at each step, from the
Householder-Arnoldi algorithm. Since Vm and H̄m are the only items needed to extract the approximate solution at the end of the GMRES process, the modification
seems rather straightforward. However, this is only true if the vi ’s are stored. In this
case, line 12 would remain the same and the modification to the algorithm would
be in lines 3-11 which are to be replaced by the Householder variant of the Arnoldi
process. It was mentioned in Section 6.3.2 that it is preferable not to store the vi ’s
because this would double the storage requirement. In this case, a formula must be
found to generate the approximate solution in line 12, using only the wi ’s, i.e., the
Pi ’s. Let
ym = (η1 , η2 , · · · , ηm )T ,
so that the solution is of the form xm = x0 + η1 v1 + · · · + ηm vm . Recall that in the
Householder variant of the Arnoldi process, each vj is defined by
vj = P1 P2 . . . Pj ej .
Using a Horner-like scheme, we obtain
xm = x0 + η1 P1 e1 + η2 P1 P2 e2 + . . . + ηm P1 P2 . . . Pm em
= x0 + P1 (η1 e1 + P2 (η2 e2 + . . . + Pm−1 (ηm−1 em−1 + Pm ηm em ))) .
Therefore, when Householder orthogonalization is used, then line 12 of the GMRES
algorithm should be replaced by a step of the form
z := 0

(6.31)

z := Pj (ηj ej + z) , j = m, m − 1, . . . , 1

(6.32)

xm

=

x0 + z.

(6.33)

The above step requires roughly as many operations as computing the last Arnoldi
vector vm . Therefore, its cost is negligible relative to the cost of the Arnoldi loop.

174

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

A LGORITHM 6.10 GMRES with Householder orthogonalization

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.

Compute r0 = b − Ax0 , z := r0 .
For j = 1, . . . , m, m + 1 Do:
Compute the Householder unit vector wj such that
(wj )i = 0, i = 1, . . . , j − 1 and
(Pj z)i = 0, i = j + 1, . . . , n where Pj = I − 2wj wjT ;
hj−1 := Pj z ; If j = 1 then let β := eT1 h0 .
v := P1 P2 . . . Pj ej .
If j ≤ m compute z := Pj Pj−1 . . . P1 Av ,
EndDo
Define H̄m = the (m + 1) × m upper part of the matrix [h1 , . . . , hm ].
Compute ym = Argminy kβe1 − H̄m yk2 . Let ym = (η1 , η2 , . . . , ηm )T .
z := 0
For j = m, m − 1, . . . , 1 Do:
z := Pj (ηj ej + z),
EndDo
Compute xm = x0 + z

Note that now only the set of wj vectors needs to be saved. The scalar β defined
in line 6 is equal to ±kr0 k2 . This is because P1 z = βe1 where β is defined by the
equations (1.26) seen in Chapter 1, which define the first Householder transformation. As was observed earlier the Householder factorization actually obtains the QR
factorization (6.12) with v = r0 . We can also formulate GMRES directly from this
factorization. Indeed, if x = x0 + Vm ym , then according to this factorization, the
corresponding residual norm is equal to
kh0 − η1 h1 − η2 h2 − . . . − ηm hm k2
whose minimizer is the same as the one defined by the algorithm.
The details of implementation of the solution of the least-squares problem as well
as the estimate of the residual norm are identical with those of the Gram-Schmidt
versions and are discussed next.

6.5.3

Practical Implementation Issues

A clear difficulty with Algorithm 6.9 is that it does not provide the approximate
solution xm explicitly at each step. As a result, it is not easy to determine when to
stop. One remedy is to compute the approximation solution xm at regular intervals
and check for convergence by a test on the residual, for example. However, there is a
more elegant solution which is related to the way in which the least-squares problem
(6.30) is solved.
A common technique to solve the least-squares problem min kβe1 −H̄m yk2 , is to
transform the Hessenberg matrix into upper triangular form by using plane rotations.

6.5. GMRES

175

Define the rotation matrices

1
..

.


1


ci
Ωi = 

−s
i






si
ci
1

..

.
1

with c2i + s2i













← row i
← row i + 1

(6.34)

= 1. If m steps of the GMRES iteration are performed then these
matrices have dimension (m + 1) × (m + 1).
Multiply the Hessenberg matrix H̄m and the corresponding right-hand side ḡ0 ≡
βe1 by a sequence of such matrices from the left. The coefficients si , ci are selected
to eliminate hi+1,i at each time. Thus, if m = 5 we would have


 
h11 h12 h13 h14 h15
β
 h21 h22 h23 h24 h25 
0


 

0
h32 h33 h34 h35 


 .
H̄5 = 
,
ḡ
=
0
0
h43 h44 h45 


 


0
h54 h55
h65

0

Then premultiply H̄5 by



c1
 −s1

Ω1 = 



with

1
1
1

h21
,
s1 = p 2
h11 + h221
to obtain the matrix and right-hand side





(1)
H̄5 = 




(1)

h11

(1)

h12
(1)
h22
h32

(1)

h13
(1)
h23
h33
h43



s1
c1

(1)

h14
(1)
h24
h34
h44
h54







h11
c1 = p 2
h11 + h221
(1) 
h15
(1)
h25 

h35 
,
h45 

h55 
h65


c1 β
 −s1 β 


 0 
.

ḡ1 = 

 0 
 0 


(6.35)

0

We can now premultiply the above matrix and right-hand side again by a rotation
matrix Ω2 to eliminate h32 . This is achieved by taking
s2 = q

h32
(1)

(h22 )2 + h232

(1)

,

c2 = q

h22
(1)

(h22 )2 + h232

.

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

176

This elimination process is continued until the m-th rotation is applied, which transforms the problem into one involving the matrix and right-hand side,
 (5)
(5)
(5)
(5)
(5) 
 
h11 h12 h13 h14 h15
γ1
(5)
(5)
(5)
(5) 



h
h
h
h

22
23
24
25 
 γ2 

(5)
(5)
(5) 

γ3 
h33 h34 h35 

(5)
.
H̄5 = 
ḡ5 = 
(6.36)
(5)
(5)  ,

. 


h
h


44
45


 . 
(5)

h55 
γ6
0
Generally, the scalars ci and si of the ith rotation Ωi are defined as
si = q

(i−1)

hi+1,i

,

(i−1) 2

(hii

) + h2i+1,i

Define Qm the product of matrices Ωi ,

ci = q

hii

(i−1) 2

(hii

.

(6.37)

) + h2i+1,i

Qm = Ωm Ωm−1 . . . Ω1

(6.38)

and
(m)
R̄m = H̄m
= Qm H̄m ,

(6.39)
T

ḡm = Qm (βe1 ) = (γ1 , . . . , γm+1 ) .

(6.40)

Since Qm is unitary,
min kβe1 − H̄m yk2 = min kḡm − R̄m yk2 .
The solution to the above least-squares problem is obtained by simply solving the
triangular system resulting from deleting the last row of the matrix R̄m and righthand side ḡm in (6.36). In addition, it is clear that for the solution y∗ , the “residual”
kβe1 − H̄m y∗ k is nothing but the last element of the right-hand side, i.e., the term γ6
in the above illustration.
Proposition 6.9 Let m ≤ n and Ωi , i = 1, . . . , m be the rotation matrices used to
transform H̄m into an upper triangular form. Denote by Rm , ḡm = (γ1 , . . . , γm+1 )T
the resulting matrix and right-hand side, as defined by (6.39), (6.40). and by Rm , gm
the m×m upper triangular matrix and m-dimensional vector obtained from R̄m , ḡm
by deleting their last row and component respectively. Then,
1. The rank of AVm is equal to the rank of Rm . In particular, if rmm = 0 then A
must be singular.
2. The vector ym which minimizes kβe1 − H̄m yk2 is given by
−1
y m = Rm
gm .

6.5. GMRES

177

3. The residual vector at step m satisfies

b − Axm = Vm+1 βe1 − H̄m ym = Vm+1 QTm (γm+1 em+1 )

(6.41)

and, as a result,

kb − Axm k2 = |γm+1 |.

(6.42)

Proof. To prove first part (1), use (6.7), to obtain the relation
AVm = Vm+1 H̄m
= Vm+1 QTm Qm H̄m
= Vm+1 QTm R̄m .
Since Vm+1 QTm is unitary, the rank of AVm is that of R̄m , which equals the rank
of Rm since these two matrices differ only by a zero row (the last row of R̄m ). If
rmm = 0 then Rm is of rank ≤ m − 1 and as a result AVm is also of rank ≤ m − 1.
Since Vm is of full rank, this means that A must be singular.
The second part (2), was essentially proved before the proposition. For any vector y,
kβe1 − H̄m yk22 = kQm (βe1 − H̄m y)k22
= kḡm − R̄m yk22

= |γm+1 |2 + kgm − Rm yk22

(6.43)

The minimum of the left-hand side is reached when the second term in the right-hand
−1 g .
side of (6.43) is zero. Since Rm is nonsingular, this is achieved when y = Rm
m
To prove the third part (3), we start with the definitions used for GMRES and the
relation (6.27). For any x = x0 + Vm y,

b − Ax = Vm+1 βe1 − H̄m y

= Vm+1 QTm Qm βe1 − H̄m y

= Vm+1 QTm ḡm − R̄m y .

As was seen in the proof of the second part above, the 2-norm of ḡm − R̄m y is
minimized when y annihilates all components of the right-hand side ḡm except the
last one, which is equal to γm+1 . As a result,
b − Axm = Vm+1 QTm (γm+1 em+1 )
which is (6.41). The result (6.42) follows from the orthonormality of the columnvectors of Vm+1 QTm .

So far we have only described a process for computing the least-squares solution ym of (6.30). Note that this approach with plane rotations can also be used to
solve the linear system (6.17) for the FOM method. The only difference is that the

178

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

last rotation Ωm must be omitted. In particular, a single program can be written to
implement both algorithms using a switch for selecting the FOM or GMRES options.
It is possible to implement the above process in a progressive manner, i.e., at each
step of the GMRES algorithm. This approach will allow one to obtain the residual
norm at every step, with virtually no additional arithmetic operations. To illustrate
this, start with (6.36), i.e., assume that the first m rotations have already been applied.
Now the residual norm is available for x5 and the stopping criterion can be applied.
Assume that the test dictates that further steps be taken. One more step of the Arnoldi
algorithm must be executed to get Av6 and the 6-th column of H̄6 . This column is
appended to R̄5 which has been augmented by a zero row to match the dimension.
Then the previous rotations Ω1 , Ω2 , . . ., Ω5 are applied to this last column. After this
is done the following matrix and right-hand side are obtained (superscripts are now
omitted from the hij entries):


 
γ1
h11 h12 h13 h14 h15 h16




h
h
h
h
h
22
23
24
25
26 

 γ2 




h33 h34 h35 h36 

 γ3 
(5)
(5)



H̄6 = 
h44 h45 h46  , ḡ6 =  . 
(6.44)
.




h55 h56 

 . 

 γ6 
0 h66 
0 h76
0

The algorithm now continues in the same way as before. We need to premultiply the
matrix by a rotation matrix Ω6 (now of size 7 × 7) with
s6 = p

(5)

h76

,
(h66 )2 + h276

to get the matrix and right-hand side,

r11 r12 r13 r14

r22 r23 r24


r33 r34


R̄6 = 
r44




r15
r25
r35
r45
r55

c6 = q

h66

(5)
(h66 )2 + h276




r16
γ1
 γ2 
r26 



 γ3 
r36 



 . .
r46 
,
ḡ
=
6



 . 
r56 



 c6 γ6 
r66 
0

(6.45)

(6.46)

−s6 γ6

If the residual norm as given by |γm+1 | is small enough, the process must be
stopped. The last rows of R̄m and ḡm are deleted and the resulting upper triangular
system is solved to obtain ym . Then the approximate solution xm = x0 + Vm ym is
computed.
Note from (6.46) that the following useful relation for γj+1 results
γj+1 = −sj γj .

(6.47)

In particular, if sj = 0 then the residual norm must be equal to zero which means
that the solution is exact at step j.

6.5. GMRES

6.5.4

179

Breakdown of GMRES

If Algorithm 6.9 is examined carefully, we observe that the only possibilities of
breakdown in GMRES are in the Arnoldi loop, when wj = 0, i.e., when hj+1,j = 0
at a given step j. In this situation, the algorithm stops because the next Arnoldi vector cannot be generated. However, in this situation, the residual vector is zero, i.e.,
the algorithm will deliver the exact solution at this step. In fact, the converse is also
true: If the algorithm stops at step j with b − Axj = 0, then hj+1,j = 0.
Proposition 6.10 Let A be a nonsingular matrix. Then, the GMRES algorithm
breaks down at step j, i.e., hj+1,j = 0, if and only if the approximate solution xj
is exact.
Proof. To show the necessary condition, observe that if hj+1,j = 0, then sj = 0.
(j−1)
Indeed, since A is nonsingular, then rjj = hjj
is nonzero by the first part of
Proposition 6.9 and (6.37) implies sj = 0. Then, the relations (6.42) and (6.47)
imply that rj = 0.
To show the sufficient condition, we use (6.47) again. Since the solution is exact
at step j and not at step j − 1, then sj = 0. From the formula (6.37), this implies that
hj+1,j = 0.

6.5.5

Variation 1: Restarting

Similar to the FOM algorithm of the previous section, the GMRES algorithm becomes impractical when m is large because of the growth of memory and computational requirements as m increases. These requirements are identical with those of
FOM. As with FOM, there are two remedies. One is based on restarting and the other
on truncating the Arnoldi orthogonalization. The straightforward restarting option is
described here.
A LGORITHM 6.11 Restarted GMRES

1.
2.
3.
4.
5.

Compute r0 = b − Ax0 , β = kr0 k2 , and v1 = r0 /β
Generate the Arnoldi basis and the matrix H̄m using the Arnoldi algorithm
starting with v1
Compute ym which minimizes kβe1 − H̄m yk2 and xm = x0 + Vm ym
If satisfied then Stop, else set x0 := xm and GoTo 1

Note that the implementation tricks discussed in the previous section can be applied,
providing the residual norm at each sub-step j without computing the approximation
xj . This enables the program to exit as soon as this norm is small enough.
A well known difficulty with the restarted GMRES algorithm is that it can stagnate when the matrix is not positive definite. The full GMRES algorithm is guaranteed to converge in at most n steps, but this would be impractical if there were many

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

180
Matrix

Iters

Kflops

Residual

Error

F2DA

95

3841

0.32E-02

0.11E-03

F3D

67

11862

0.37E-03

0.28E-03

ORS

205

9221

0.33E+00

0.68E-04

Table 6.2: A test run of GMRES with no preconditioning.
steps required for convergence. A typical remedy is to use preconditioning techniques (see chapters 9 and 10) whose goal is to reduce the number of steps required
to converge.
Example 6.2. Table 6.2 shows the results of applying the GMRES algorithm with
no preconditioning to three of the test problems described in Section 3.7. See Example 6.1 for the meaning of the column headers in the table. In this test, the dimension
of the Krylov subspace is m = 10. Observe that the problem ORS, which could not
be solved by FOM(10), is now solved in 205 steps.

6.5.6

Variation 2: Truncated GMRES Versions

It is possible to derive an Incomplete version of the GMRES algorithm. This algorithm is called Quasi-GMRES (QGMRES) for the sake of notational uniformity with
other algorithms developed in the literature (some of which will be seen in the next
chapter). A direct version called DQGMRES using exactly the same arguments as
in Section 6.4.2 for DIOM can also be derived. We begin by defining a hypothetical QGMRES algorithm, in simple terms, by replacing the Arnoldi Algorithm with
Algorithm 6.6, the Incomplete Orthogonalization procedure.
A LGORITHM 6.12 Quasi-GMRES

Run a modification of Algorithm 6.9 in which the Arnoldi process in lines
2 to 10 is replaced by the Incomplete Orthogonalization process and all
other computations remain unchanged.
Similar to IOM, only the k previous vi vectors must be kept at any given step.
However, this version of GMRES will potentially save computations but not storage.
This is because computing the solution by formula (6.29) requires the vectors vi for
i = 1, . . . , m to be accessed. Fortunately, the approximate solution can be updated
in a progressive manner, as in DIOM.
The implementation of this progressive version is quite similar to DIOM. First,

6.5. GMRES

181

note that if H̄m is banded, as for example, when m = 5, k = 2,


 
h11 h12
β
 h21 h22 h23

0


 


 
h
h
h
32
33
34
, g =  0 
H̄5 = 


0
h43 h44 h45 

 

0
h54 h55 
h65

(6.48)

0

then the premultiplications by the rotation matrices Ωi as described in the previous
section will only introduce an additional diagonal. For the above case, the resulting
least-squares system is R̄5 y = ḡ5 with:


 
r11 r12 r13
γ1




r
r
r
22
23
24


 γ2 



r33 r34 r35 
γ3 
.
R̄5 = 
,
ḡ5 = 
(6.49)




r44 r45 

 . 

 . 
r55 
0
γ6
The approximate solution is given by

−1
xm = x0 + Vm Rm
gm

where Rm and gm are obtained by removing the last row of R̄m and ḡm , respectively.
Defining Pm as in DIOM,
−1
Pm ≡ Vm Rm
then,
xm = x0 + Pm gm .
Also note that similarly to DIOM,
gm =



gm−1
γm



in which
(m−1)
γm = cm γm
,
(m−1)

where γm
is the last component of the vector ḡm−1 , i.e., the right-hand side
before the m-th rotation is applied. Thus, xm can be updated at each step, via the
relation
xm = xm−1 + γm pm .
A LGORITHM 6.13 DQGMRES

1.
2.
3.

Compute r0 = b − Ax0 , γ1 := kr0 k2 , and v1 := r0 /γ1
For m = 1, 2, . . . , until convergence Do:
Compute him , i = max{1, m − k + 1}, . . . , m and vm+1

182

4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I
as in lines 2 to 6 of Algorithm 6.6
Update the QR factorization of H̄m , i.e.,
Apply Ωi , i = m − k, . . . , m − 1 to the m-th column of H̄m
Compute the rotation coefficients cm , sm by (6.37)
Apply Ωm to H̄m and ḡm , i.e., Compute:
γm+1 := −sm γm
γm := cm γm

 q
=
hmm := cm hmm + sm hm+1,m


Pm−1
pm = vm − i=m−k him pi /hmm

h2m+1,m + h2mm

xm = xm−1 + γm pm
If |γm+1 | is small enough then Stop
EndDo

The above algorithm does not minimize the norm of the residual vector over x0 +Km .
Rather, it attempts to perform an approximate minimization. Formula (6.41), which
is still valid since orthogonality was not used to derive it, also yields the following
equaliy for DQGMRES:

kb − Axm k2 = kVm+1 βe1 − H̄m ym k2

where as before ym minimizes the norm kβe1 − H̄m yk2 over all vectors y in Rm . The
norm kβe1 − H̄m yk2 is called the quasi-residual norm of the vector x0 + Vm y, which
is a member of x0 + Km . If the vi ’s were orthogonal to each other, then the quasiresidual norm and the actual residual norm would be identical and QGMRES would
be equivalent to GMRES, i.e., the residual norm is minimized over all vectors of the
form x0 + Vm y. Since only an incomplete orthogonalization is used then the vi ’s are
only locally orthogonal and, as a result, only an approximate minimization may be
obtained. Now, (6.42) is no longer valid since its proof required the orthogonality of
the vi ’s. However, the following relation will be helpful in understand the behavior
of QGMRES
b − Axm = Vm+1 QTm (γm+1 em+1 ) ≡ γm+1 zm+1 .

(6.50)

The actual residual norm is equal to the quasi-residual norm (i.e., |γm+1 |), multiplied
by the norm of zm+1 . The vector zm+1 is the last column of Vm+1 QTm , which is no
longer a unitary matrix. It turns out that in practice, |γm+1 | remains a reasonably
good estimate of the actual residual norm because the vi ’s are nearly orthogonal.
The following inequality provides an actual upper bound of the residual norm in
terms of computable quantities:
√
(6.51)
kb − Axm k ≤ m − k + 1 |γm+1 |.
Here, k is to be replaced by m when m ≤ k. The proof of this inequality is a consequence of (6.50). If the unit vector q ≡ QTm em+1 has components η1 , η2 , . . . , ηm+1 ,

6.5. GMRES

183

then
kb − Axm k2 = |γm+1 | kVm+1 qk2

k+1
X

ηi vi
≤ |γm+1 |
"

≤ |γm+1 | 

"

≤ |γm+1 | 

+

m+1
X

ηi vi

i=1

2

i=k+2

k+1
X

ηi2

#1/2

ηi2

#1/2

m+1
X

i=1

k+1
X
i=1

+

i=k+2

+

√

2






|ηi | kvi k2 

m−k

" m+1
X

i=k+2

#1/2 

ηi2

The orthogonality of the first k + 1 vectors vi was used and the last term comes from
using the Cauchy-Schwartz inequality. The desired inequality follows from using the
Cauchy-Schwartz inequality again in the form
p
√
√
1 . a + m − k . b ≤ m − k + 1 a 2 + b2

and from the fact that the vector q is of norm unity.√Thus, using |γm+1 | as a residual
estimate, we would make an error of a factor of m − k + 1 at most. In general,
this is an overestimate and |γm+1 | tends to give an adequate estimate for the residual
norm.
It is also interesting to observe that with a little bit more arithmetic, the exact
residual vector and norm can be obtained. This is based on the observation that,
according to (6.50), the residual vector is γm+1 times the vector zm+1 which is the
last column of the matrix
Zm+1 ≡ Vm+1 QTm .
(6.52)

It is an easy exercise to see that this last column can be updated from vm+1 and zm .
Indeed, assuming that all the matrices related to the rotation are of size (m + 1) ×
(m + 1), the last row of Qm−1 is the (m + 1) − st row of the identity, so we can
write
Zm+1 = [Vm , vm+1 ]QTm−1 ΩTm
= [Zm , vm+1 ]ΩTm .
The result is that
zm+1 = −sm zm + cm vm+1 .

(6.53)

The zi ’s can be updated at the cost of one extra vector in memory and 4n operations
at each step. The norm of zm+1 can be computed at the cost of 2n operations and
the exact residual norm for the current approximate solution can then be obtained by
multiplying this norm by |γm+1 |.
Because this is a little expensive, it may be preferred to just “correct” the estimate
provided by γm+1 by exploiting the above recurrence relation,
kzm+1 k2 ≤ |sm |kzm k2 + |cm |.

184

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

If ζm ≡ kzm k2 , then the following recurrence relation holds,
ζm+1 ≤ |sm |ζm + |cm |.

(6.54)

The above relation is inexpensive to update, yet provides an upper bound that is
sharper than (6.51); see Exercise 25.
Equation (6.53) shows an interesting relation between two successive residual
vectors:
rm = γm+1 zm+1
= γm+1 [−sm zm + cm vm+1 ]
= s2m rm−1 + cm γm+1 vm+1 .

(6.55)

This exploits the fact that γm+1 = −sm γm and rj = γj+1 zj+1 .
Relating the DQGMRES and FOM residuals may provide some useful insight.
We will denote by the superscript I all quantities relared to IOM (or DIOM). For
example, the m-th iterate in IOM is denoted by xIm and its residual vector will be
I = b − AxI . It is already known that the IOM residual is a scaled version of the
rm
m
vector vm+1 obtained by the incomplete Arnoldi process. To be more accurate, the
following equality holds,
I
rm
= −hm+1,m eTm ym vm+1 = −hm+1,m

hm+1,m
γm
v
=
γ
v
.
(m−1) m+1
(m−1) m+1 m+1
hmm
sm hmm
(m)

The next relation is then obtained by observing that hm+1,m /hmm = tan θm . Hence,
I
γm+1 vm+1 = cm rm
,

(6.56)

ρQ
m = |cm | ρm ,

(6.57)

I
rm = s2m rm−1 + c2m rm
.

(6.58)

from which it follows that
I k is the actual residual norm of the m-th IOM iterate. As an
where ρm = krm
2
important consequence of (6.56), note that (6.55) becomes,

Example 6.3. Table 6.3 shows the results of applying the DQGMRES algorithm
with no preconditioning to three of the test problems described in Section 3.7. See
Example 6.1 for the meaning of the column headers in the table. In this test the
number k of directions in the recurrence is k = 10.
There exist several other ways to relate the quasi-minimal residual norm to the
actual minimal residual norm provided by GMRES. The following result was proved
by Freund and Nachtigal [136] for the QMR algorithm to be seen in the next chapter.
Theorem 6.11 Assume that Vm+1 , the Arnoldi basis associated with DQGMRES,
Q
G be the residual norms obtained after m steps of the
is of full rank. Let rm
and rm
DQGMRES and GMRES algorithms, respectively. Then
Q
G
krm
k2 ≤ κ2 (Vm+1 )krm
k2 .

(6.59)

6.5. GMRES

185
Matrix

Iters

Kflops

Residual

Error

F2DA

98

7216

0.36E-02

0.13E-03

F3D

75

22798

0.64E-03

0.32E-03

ORS

300

24138

0.13E+02

0.25E-02

Table 6.3: A test run of DQGMRES with no preconditioning.
Proof. Consider the subset of Km+1 defined by
R = {r : r = Vm+1 t; t = βe1 − H̄m y; y ∈ Cm }.
Denote by ym the minimizer of kβe1 − H̄m yk2 over y and tm = βe1 − H̄m ym , rm =
Q
Vm+1 tm ≡ rm
. By assumption, Vm+1 is of full rank and there is an (m+1)×(m+1)
nonsingular matrix S such that Wm+1 = Vm+1 S is unitary. Then, for any member
of R,
H
r
r = Wm+1 S −1 t, t = SWm+1
and, in particular,
krm k2 ≤ kS −1 k2 ktm k2 .

(6.60)

Now ktm k2 is the minimum of the 2-norm of βe1 − H̄m y over all y’s and therefore,
H
H
rk2
ktm k2 = kSWm+1
rm k ≤ kSWm+1

≤ kSk2 krk2
G

≤ kSk2 kr k2 .

∀r ∈ R

∀r ∈ R
(6.61)

The result follows from (6.60), (6.61), and the fact that κ2 (Vm+1 ) = κ2 (S).

6.5.7

Relations between FOM and GMRES

If the last row of the least-squares system in (6.44) is deleted, instead of the one in
(6.46), i.e., before the last rotation Ω6 is applied, the same approximate solution as
FOM would result. Indeed, this would correspond to solving the system Hm y = βe1
using the QR factorization. As a practical consequence a single subroutine can be
written to handle both cases. This observation can also be helpful in understanding
the relationships between the two algorithms.
In what follows the FOM and GMRES iterates are denoted by the superscripts
F and G, respectively. The residual norm achieved at step j will be denoted by ρFj
for FOM and ρG
j for GMRES. An important consequence of (6.47) is that
G
ρG
m = |sm |ρm−1 ,

which leads to he following equality:
ρG
m = |s1 s2 . . . sm |β .

(6.62)

186

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Note that formulas (6.37) yield nonnegative si ’s, so the absolute values are not required. They are left only for generality.
(k)
Define H̄m to be the matrix resulting form applying the first k rotations to
(k)
H̄m and, similarly, let ḡm be the vector resulting from applying the first k rota(k)
(k)
tions to the right-hand side βe1 . As usual Hm is the matrix H̄m with its last row
(k)
deleted and gm the vector of size m obtained by removing the last component of
(k)
ḡm . By formula (6.18), the residual obtained from the Arnoldi process is given
−1
T
F k = kb − AxF k = h
by krm
m+1,m |em ym |. In addition, ym = Hm (βe1 ) can
2
m 2
(m−1)
be obtained by back-solving Hm
y = g(m−1) . Therefore, its last component is
(m−1)
(m−1)
T
em gm
/hmm . Hence,
−1
ρFm = hm+1,m |eTm Hm
(βe1 )| = hm+1,m

eTm g(m−1)
(m−1)

hmm

.

As before, let γm denote the last component of ḡm−1 , or equivalently, the m-th component of g(m−1) , i.e., before the last rotation Ωm is applied (See (6.36) and (6.44)
for an illustration). Then,
|eTm g(m−1) | = |sm−1 γm | = · · · = |s1 s2 . . . sm−1 β| .
Therefore, the above expression for ρFm becomes,
ρFm =

hm+1,m
(m−1)

|hmm |

|s1 s2 . . . sm−1 β|.
(m−1)

Now expressions (6.37) show that hm+1,m /|hmm | is the tangent of the angle defining the m-th rotation, and therefore,
ρFm =

|sm |
|s1 s2 . . . sm−1 β| .
|cm |

A comparison with (6.62), yields a revealing relation between the residuals of the
FOM and GMRES algorithms, namely,
ρFm =

1 G
ρ .
|cm | m

The trigonometric relation 1/ cos2 θ = 1 + tan2 θ, can now be invoked: 1/|cm | =
(m−1)
[1 + (hm+1,m /hmm )2 ]1/2 . These results are summarized in the following proposition (Brown [66]).
Proposition 6.12 Assume that m steps of the Arnoldi process have been taken and
that Hm is nonsingular. Let ξ ≡ (Qm−1 H̄m )mm and h ≡ hm+1,m . Then the residual
norms produced by the FOM and the GMRES algorithms are related by the equality
s
1 G
h2
ρm = ρG
(6.63)
ρFm =
1+ 2.
m
|cm |
ξ

6.5. GMRES

187

It is also possible to prove the above result by exploiting the relation (6.75); see
Exercise 14.
The term ξ in the expression (6.63) is not readily available and this results in
an expression that is hard to interpret practically. Another, somewhat more explicit
expression, can be obtained from simply relating cm with two consecutive residual
norms of GMRES. The next result shown by Cullum and Greenbaum [92] follows
G
immediatly from the above proposition and the relation |sm | = ρG
m /ρm−1 which is a
consequence of (6.62).
Proposition 6.13 Assume that m steps of the Arnoldi process have been taken and
that Hm is nonsingular. Then the residual norms produced by the FOM and the
GMRES algorithms are related by the equality
ρFm = q

ρG
m
G
1 − ρG
m /ρm−1

2 .

The above relation can be recast as
1
1
1
2 = G 2
2 +
F
G
(ρm )
(ρm )
ρm−1

(6.64)

(6.65)

Consider now these equations for m, m − 1, · · ·, 1,
1
1
1
2 =
2 +
G
F
G
(ρm )
(ρm )2
ρm−1
1
1
1
+
=


2
2
2
ρFm−1
ρG
ρG
m−2
m−1
··· = ···
1
1
1
+
=


2
2
2
ρF1
ρG
ρG
0
1

F
Note that ρG
0 is simply the initial residual norm and can as well be denoted by ρ0 .
Summing the above equations yields,
m
X
i=0

1

1

2 = G 2 .
(ρm )
ρFi

(6.66)

Corollary 6.14 The residual norms produced by the FOM and the GMRES algorithms are related by the equality
1
ρG
(6.67)
m = qP

m
F 2
1/ρ
i=0
i

The above relation establishes rigorously the intuitive fact that FOM and GMF
RES are never too far away from each other. It is clear that ρG
m ≤ ρm . On the other
F
hand, let ρm∗ by the smallest residual norms achieved the first m steps of FOM. Then
1
(ρG
m)

2 =

m
X
i=0

1

 ≤
F 2

ρi

m+1
2
ρFm∗

188

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

An immediate consequence of this inequality is the following proposition.
Proposition 6.15 Assume that m steps of GMRES and FOM are taken (steps in FOM
with a singular Hm are skipped). Let ρFm∗ be the smallest residual norm achieved by
FOM in the first m steps. Then, the following inequalities hold:
√
F
ρG
m ρG
(6.68)
m ≤ ρm∗ ≤
m
We now establish another interesting relation between the FOM and GMRES
iterates, which will be exploited in the next chapter. A general lemma is first shown
regarding the solutions of the triangular systems
Rm ym = gm
obtained from applying successive rotations to the Hessenberg matrices H̄m . As was
stated before, the only difference between the ym vectors obtained in GMRES and
Arnoldi is that the last rotation Ωm is omitted in FOM. In other words, the Rm matrix
for the two methods differs only in its (m, m) entry while the right-hand sides differ
only in their last components.
Lemma 6.16 Let R̃m be the m × m upper part of the matrix Qm−1 H̄m and, as
before, let Rm be the m × m upper part of the matrix Qm H̄m . Similarly, let g̃m be
the vector of the first m components of Qm−1 (βe1 ) and let gm be the vector of the
first m components of Qm (βe1 ). Define
−1
g̃m ,
ỹm = R̃m

−1
gm
y m = Rm

the y vectors obtained for an m-dimensional FOM and GMRES methods, respectively. Then


y

y
m−1
m−1
(6.69)
= c2m ỹm −
ym −
0
0
in which cm is the cosine used in the m-th rotation Ωm , as defined by (6.37).
Proof. The following relation holds:


Rm−1 zm
Rm =
,
0
ξm
Similarly, for the right-hand sides,


gm−1
,
gm =
γm

R̃m =



Rm−1
0

g̃m =



gm−1
γ̃m

zm
ξ̃m



.



with
γm = cm γ̃m .
Denoting by λ the scalar
we obtain

q

(6.70)

2 + h2
ξ̃m
m+1,m , and using the definitions of sm and cm ,

ξm = cm ξ̃m + sm hm+1,m =

2
h2m+1,m
ξ˜m
ξ˜m
+
=λ=
.
λ
λ
cm

(6.71)

6.5. GMRES

189

Now,
−1
y m = Rm
gm =



−1
Rm−1
0

−1
zm
− ξ1m Rm−1
1
ξm

−1
which, upon observing that Rm−1
gm−1 = ym−1 , yields,

ym −

y

m−1

0



=

γm
ξm





−1
−Rm−1
zm
1



.

gm−1
γm



(6.72)

(6.73)

Replacing ym , ξm , γm by ỹm , ξ˜m , γ̃m , respectively, in (6.72), a relation similar to
(6.73) would result except that γm /ξm is replaced by γ̃m /ξ̃m which, by (6.70) and
(6.71), satisfies the relation
γm
γ̃m
= c2m
.
ξm
ξ̃m
The result follows immediately.
If the FOM and GMRES iterates are denoted by the superscripts F and G, respectively, then the relation (6.69) implies that

G
2
F
G
xG
m − xm−1 = cm xm − xm−1 ,

or,

2 G
2 F
xG
m = sm xm−1 + cm xm .

(6.74)

This leads to the following relation for the residual vectors obtained by the two methods,
G
G
F
rm
= s2m rm−1
+ c2m rm
(6.75)
which indicates that, in general, the two residual vectors will evolve hand in hand.
In particular, if cm = 0, then GMRES will not progress at step m, a phenomenon
known as stagnation. However, in this situation, according to the definitions (6.37)
(m−1)
of the rotations, hmm = 0 which implies that Hm is singular and, therefore, xFm is
not defined. In fact, the reverse of this is also true, a result due to Brown [66], which
is stated without proof in the following proposition.
Proposition 6.17 If at any given step m, the GMRES iterates make no progress, i.e.,
G
F
if xG
m = xm−1 then Hm is singular and xm is not defined. Conversely, if Hm is
singular at step m, i.e., if FOM breaks down at step m, and A is nonsingular, then
G
xG
m = xm−1 .
Note also that the use of the above lemma is not restricted to the GMRES-FOM
pair. Some of the iterative methods defined in this chapter and the next involve a
least-squares problem of the form (6.30). In such cases, the iterates of the leastsquares method and those of the orthogonal residual (Galerkin) method will be related by the same equation.

190

6.5.8

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Residual smoothing

The previous section established strong relations between the GMRES and FOM
iterates. In fact it is possible to derive the GMRES iterates from the FOM iterates,
by simply exploiting the relations (6.74 – 6.75), which we now rewrite as
G
2
F
G
xG
m = xm−1 + cm (xm − xm−1 ) ;

G
G
F
G
rm
= rm−1
+ c2m (rm
− rm−1
).

The above relations are instances of a class of algorithms derived by ‘residual smoothing’, which define a new sequence of iterates, denoted here by xSi from an original
sequence, denoted by xO
i . The residual vectors of the two sequences are denoted by
S
O
ri and ri respectively. The new sequences are as follows:
S
xSm = xSm−1 + ηm (xO
m − xm−1 ) ;

S
S
O
S
rm
= rm−1
+ ηm (rm
− rm−1
).

The parameter ηm is selected so as to make the residual rm behave better than the
original one, in the sense that large variations in the residual are dampened. In Minimal Residual Smoothing the ηm ’s are selected to minimize the new residual norm
S k . This is in essence a minimal residual projection method in the direction
krm
2
S
S
xO
m − xm−1 and it is achieved by selecting ηm so that the new residual rm is orthogO
S
O
S
onal to A(xm − xm−1 ) = −(rm − rm−1 ). Thus,
ηm = −

S
O − rS
(rm−1
, rm
m−1 )
,
S
O
krm − rm−1 k22

resulting in the following algorithm.

A LGORITHM 6.14 Minimal residual smoothing

1.
2.
3.
4.
5.
6.
7.

O
S
xS0 = xO
0 , r0 = r0 ;
For m = 1, . . . , Do:
O
Compute xO
m and rm

2
O − rS
S
S
O
/krm
ηm = − rm−1 , rm − rm−1
m−1 k2
S
xSm = xSm−1 + ηm (xO
m − xm−1 )
S
O
S
S
rm = rm−1 + ηm (rm − rm−1 )
EndDo

O is orthogonal to r S
In the situation when rm
m−1 , then it is possible to show that the
same relation as (6.64) (or equivalently (6.65)) is satisfied. This result is due to
Weiss [307].
O is orthogonal to r S
Lemma 6.18 If rm
m−1 at each step m ≥ 1, then the residual
norms satisfy the relation
1
1
1
+ O 2 ,
= S
(6.76)
2
S k2
krm
kr
kr
k
m k2
2
m−1 2

and the coefficient ηm is given by

ηm =

S
krm−1
k22
.
S
O k2
krm−1
k22 + krm
2

(6.77)

6.5. GMRES

191

S
S
S
S
O
O ⊥ rS
Proof. Since rm
m−1 it follows that (rm−1 , rm − rm−1 ) = −(rm−1 , rm−1 ) and
S
2
S
2
O
2
S
O
krm − rm−1 k2 = krm k2 + krm−1 k2 . This shows (6.77). The orthogonality of rm
S
S
with rm − rm−1 , implies that
S 2
S
2
O
S
krm
k2 = krm−1
k22 − ηm
krm
− rm−1
k22
S
O k2
kr S k4
krm−1
k2 krm
2
S
= krm−1
k22 − O 2 m−1 S2
=
.
2
O k2 + kr S
krm k2 + krm−1 k22
krm
2
m−1 k2

The result (6.76) follows by inverting both sides of the above equality.
The assumptions of the lemma are satisfied in particular when the residual vectors of the original algorithm are orthogonal to each other, as is the case for the FOM
method. This can be shown by simple induction, using the fact that each new rkS is
ultimately a linear combination of the riO ’s, for i ≤ k. Since the relation established
by the lemma is identical with that of the GMRES algorithm, it follows that the
residual norms are identical, since they both satisfy (6.67). Because the approximate
solutions belong to the same subspace and GMRES minimizes the residual norm, it
is clear that the resulting approximate solutions are identical.
This result can also be shown in a different way. Induction shows that the vectors
S
T
p j = xO
j − xj−1 are A A - orthogonal, i.e., (Api , Apj ) = 0 for i 6=. Then a lemma
to be seen in Section 6.9 (Lemma 6.21) can be expoited to prove the same result.
This is left as an exercise (Exercise 26).
The computation of the scalar ηm is likely to be subject to large errors when
the residuals become small because there may be a substantial difference between
the actual residual and the one computed recursively by the algorithm. One remedy
is to explicitly use the directions pj mentioned above. The formulas and the actual
update will then follow closely those seen in Section 5.3, with v replaced by pm ,
and w by Apm . Speficially, lines 5 and 6 of Algorithm 6.14 are repaced by xSm =
S = rS
xSm−1 + ηm pm and rm
m−1 − ηm Apm , respectively, while the coefficient ηm
S
, Apm )/(Apm , Apm ). Details are omitted but may be
is computed as ηm = (rm−1
found in [324].
Lemma 6.18 yields the following equality, in which ρj denotes krjO k2 and τj
denotes krjS k2 ,
S
rm
=

=

2
τm−1
ρ2m
S
O
r
+
rm
m−1
2
2
ρ2m + τm−1
ρ2m + τm−1


1
1 S
1 O
rm−1 + 2 rm .
1
2
ρm
+ ρ12 τm−1
τ2
m−1

m

Summing up the relations (6.76), yields an expression similar to (6.66),
j
X
1
1
=
.
2
τj
ρ2
i=0 j

(6.78)

192

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Combining this with (6.78) and using induction immediatly yields the following expression which holds under the assumptions of Lemma 6.18 :
m
X
rjO
1
S
rm = Pm 1
2 .
j=1 ρ2j j=1 ρj

(6.79)

The smoothed residual is a convex combination of the residuals obtained by the original algorithm (e.g., FOM). The coefficient used for a given residual is inversely
proportional to its norm squared. In other words, residual smoothing will tend to
dampen wide variations in the original residuals. If the original residual moves up
very high then (6.79) or (6.78) show that the next S-residual will tend to stagnate. If
the other hand, the original residual decreases very rapidly at a given step, then the
smoothed residual will be close to it. In other words, stagnation and fast convergence
of the S-residual goes hand in hand with poor convergence and fast convergence, respectively, of the original scheme.
Consider now the general situation when the residual vectors do not satisfy the
conditions of Lemma 6.18. In this case the above results are not valid. However,
one may ask whether or not it is possible to still select the ηm ’s by an alternative
formula such that the nice relation (6.79) remains valid. A hint at a possible answer
is provided by a look at Equations (6.76) and (6.77). These are the only relations
used to establish (6.79). This suggests computing the ηm ’s recursively as follows
ηm =

2
τm−1
;
2
τm−1
+ ρ2m

1
1
1
+
= 2
2
τm
τm−1 ρ2m

It is only when the conditions of Lemma 6.18 are satisfied, that τk is the norm of the
residuals rkS . What is important is that the relation (6.78) can be shown to be valid
with krjS k22 replaced by τj2 . As result, the same induction proof as before will show
that (6.79) is also valid. Replacing the ηm of Algorithm 6.14 by the one defined above
gives rise to an algorithm known as quasi-minimal residual smoothing, or QMRS.
It can easily be shown that when applied to the sequence of iterates produced
by IOM/DIOM, then QMRS will, in exact arithmetic, yield the same sequence as
QMRES/DQGMRES. The key relations are (6.47), which is still valid, and (6.57).
S is now equal to γ
The quasi-residual norm which replaces the actual norm rm
m+1 .
By (6.57), the cosine used in the m-th step of QGMRES/DQGMES satisfies: |cm | =
|γm+1 |/ρ2m . By formula (6.47), |sm | = |γm+1 /γm |. Writing c2m + s2m = 1 and using
the notation τm ≡ γm+1 , yields
2
2
γm+1
γm+1
+
=1
2
γm
ρ2m

→

1
1
1
= 2
+ 2
2
τm
τm−1 ρm

This, along with the relation (6.58), shows that the residual vectors computed by
QGMRES-/DQGMRES obey the exact same recurrence as those defined by QMRS.
Quasi-minimal residual smoothing is related to several other algorithms to be described in the next sections.

6.6. THE SYMMETRIC LANCZOS ALGORITHM

6.5.9

193

GMRES for complex systems

Complex linear systems arise in many important applications. Perhaps the best
known of these is when solving Maxwell’s equations in electromagnetics. The most
common method used in this context gives rise to large dense and complex linear
systems.
Adapting GMRES to the complex case is fairly straightforward. The guiding
principle is that the method should minimize the 2-norm of the residual on the affine
Krylov subspace. This is achieved by Algorithm 6.9 in which the inner products are
now the complex inner produts in Cn , defined by (1.3) of Chapter 1. The only part
requiring some attention is the solution of the least-squares problem in Line 12 of the
Algorithm or rather, the practical implementation using Givens rotations outlined in
Section 6.5.3.
Complex Givens rotations are defined in the following way instead of (6.34):


1
.
..






1




← row i
c̄i s̄i


(6.80)
Ωi = 

←
row i + 1
−s
c
i
i




1


..


.
1

with |ci |2 + |si |2 = 1. The description of Section 6.5.3 can be followed in the same
way. In particular the sine and cosine defined in (6.37) for the Givens rotation matrix
at step i are given by
si = q

hi+1,i
(i−1)
|hii |2 + h2i+1,i

(i−1)

,

ci = q

hii

(i−1)
|hii |2 + h2i+1,i

.

(6.81)

A slight simplification takes place when applying the successive rotations. Since
hj+1,j is the 2-norm of a vector, it is real (nonnegative), and so si is also a real
(nonnegative) number while, in general, ci is complex. The rest of the development
is identical, though it is worth noting that the diagonal entries of the upper triangular
matrix R are (nonnegative) real and that the scalars γi are real.

6.6

The Symmetric Lanczos Algorithm

The symmetric Lanczos algorithm can be viewed as a simplification of Arnoldi’s
method for the particular case when the matrix is symmetric. When A is symmetric,
then the Hessenberg matrix Hm becomes symmetric tridiagonal. This leads to a
three-term recurrence in the Arnoldi process and short-term recurrences for solution
algorithms such as FOM and GMRES. On the theoretical side, there is also much
more that can be said on the resulting approximation in the symmetric case.

194

6.6.1

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

The Algorithm

To introduce the Lanczos algorithm we begin by making the observation stated in the
following theorem.
Theorem 6.19 Assume that Arnoldi’s method is applied to a real symmetric matrix
A. Then the coefficients hij generated by the algorithm are such that
hij = 0,

for 1 ≤ i < j − 1,

hj,j+1 = hj+1,j , j = 1, 2, . . . , m.

(6.82)
(6.83)

In other words, the matrix Hm obtained from the Arnoldi process is tridiagonal and
symmetric.
Proof. The proof is an immediate consequence of the fact that Hm = VmT AVm is
a symmetric matrix which is also a Hessenberg matrix by construction. Therefore,
Hm must be a symmetric tridiagonal matrix.
The standard notation used to describe the Lanczos algorithm is obtained by setting
αj ≡ hjj ,

βj ≡ hj−1,j ,

and if Tm denotes the resulting Hm matrix, it is of the form,


α1 β2
 β2 α2

β3


.
Tm = 
.
.
.



βm−1 αm−1 βm 
βm
αm

(6.84)

This leads to the following form of the Modified Gram-Schmidt variant of Arnoldi’s
method, namely, Algorithm 6.2.
A LGORITHM 6.15 The Lanczos Algorithm

1.
2.
3.
4.
5.
6.
7.
8.

Choose an initial vector v1 of 2-norm unity. Set β1 ≡ 0, v0 ≡ 0
For j = 1, 2, . . . , m Do:
wj := Avj − βj vj−1
αj := (wj , vj )
wj := wj − αj vj
βj+1 := kwj k2 . If βj+1 = 0 then Stop
vj+1 := wj /βj+1
EndDo

It is rather surprising that the above simple algorithm guarantees, at least in exact
arithmetic, that the vectors vi , i = 1, 2, . . . , are orthogonal. In reality, exact orthogonality of these vectors is only observed at the beginning of the process. At some point

6.6. THE SYMMETRIC LANCZOS ALGORITHM

195

the vi ’s start losing their global orthogonality rapidly. There has been much research
devoted to finding ways to either recover the orthogonality, or to at least diminish its
effects by partial or selective orthogonalization; see Parlett [224].
The major practical differences with Arnoldi’s method are that the matrix Hm is
tridiagonal and, more importantly, that only three vectors must be saved, unless some
form of reorthogonalization is employed.

6.6.2

Relation with Orthogonal Polynomials

In exact arithmetic, the core of Algorithm 6.15 is a relation of the form
βj+1 vj+1 = Avj − αj vj − βj vj−1 .
This three-term recurrence relation is reminiscent of the standard three-term recurrence relation of orthogonal polynomials. In fact, there is indeed a strong relationship
between the Lanczos algorithm and orthogonal polynomials. To begin, recall that if
the grade of v1 is ≥ m, then the subspace Km is of dimension m and consists of all
vectors of the form q(A)v1 , where q is a polynomial with degree(q) ≤ m − 1. In this
case there is even an isomorphism between Km and Pm−1 , the space of polynomials
of degree ≤ m − 1, which is defined by
q ∈ Pm−1 → x = q(A)v1 ∈ Km .
Moreover, we can consider that the subspace Pm−1 is provided with the inner product
< p, q >v1 = (p(A)v1 , q(A)v1 ).

(6.85)

This is indeed a nondegenerate bilinear form under the assumption that m does not
exceed µ, the grade of v1 . Now observe that the vectors vi are of the form
vi = qi−1 (A)v1
and the orthogonality of the vi ’s translates into the orthogonality of the polynomials
with respect to the inner product (6.85).
It is known that real orthogonal polynomials satisfy a three-term recurrence.
Moreover, the Lanczos procedure is nothing but the Stieltjes algorithm; (see, for
example, Gautschi [141]) for computing a sequence of orthogonal polynomials with
respect to the inner product (6.85). It is known [246] that the characteristic polynomial of the tridiagonal matrix produced by the Lanczos algorithm minimizes the
norm k.kv1 over the monic polynomials. The recurrence relation between the characteristic polynomials of tridiagonal matrices also shows that the Lanczos recurrence
computes the sequence of vectors pTm (A)v1 , where pTm is the characteristic polynomial of Tm .

196

6.7

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

The Conjugate Gradient Algorithm

The Conjugate Gradient algorithm is one of the best known iterative techniques for
solving sparse Symmetric Positive Definite linear systems. Described in one sentence, the method is a realization of an orthogonal projection technique onto the
Krylov subspace Km (r0 , A) where r0 is the initial residual. It is therefore mathematically equivalent to FOM. However, because A is symmetric, some simplifications
resulting from the three-term Lanczos recurrence will lead to more elegant algorithms.

6.7.1

Derivation and Theory

We first derive the analogue of FOM, or Arnoldi’s method, for the case when A is
symmetric. Given an initial guess x0 to the linear system Ax = b and the Lanczos
vectors vi , i = 1, . . . , m together with the tridiagonal matrix Tm , the approximate
solution obtained from an orthogonal projection method onto Km , is given by
x m = x 0 + Vm y m ,

−1
(βe1 ).
ym = Tm

(6.86)

A LGORITHM 6.16 Lanczos Method for Linear Systems

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Compute r0 = b − Ax0 , β := kr0 k2 , and v1 := r0 /β
For j = 1, 2, . . . , m Do:
wj = Avj − βj vj−1 (If j = 1 set β1 v0 ≡ 0)
αj = (wj , vj )
wj := wj − αj vj
βj+1 = kwj k2 . If βj+1 = 0 set m := j and go to 9
vj+1 = wj /βj+1
EndDo
Set Tm = tridiag (βi , αi , βi+1 ), and Vm = [v1 , . . . , vm ].
−1 (βe ) and x = x + V y
Compute ym = Tm
1
m
0
m m

Many of the results obtained from Arnoldi’s method for linear systems are still valid.
For example, the residual vector of the approximate solution xm is such that
b − Axm = −βm+1 eTm ym vm+1 .

(6.87)

The Conjugate Gradient algorithm can be derived from the Lanczos algorithm in
the same way DIOM was derived from IOM. In fact, the Conjugate Gradient algorithm can be viewed as a variation of DIOM(2) for the case when A is symmetric. We
will follow the same steps as with DIOM, except that the notation will be simplified
whenever possible.
First write the LU factorization of Tm as Tm = Lm Um . The matrix Lm is unit
lower bidiagonal and Um is upper bidiagonal. Thus, the factorization of Tm is of the

6.7. THE CONJUGATE GRADIENT ALGORITHM

197

form


1
 λ2

Tm = 



1
λ3



1
λ4

1
λ5

1



η1

 
 
×
 
 

β2
η2

β3
η3

The approximate solution is then given by,

β4
η4





.

β5 
η5

−1 −1
xm = x0 + Vm Um
Lm (βe1 ).

Letting
−1
Pm ≡ Vm Um

and
zm = L−1
m βe1 ,
then,
xm = x0 + Pm zm .
As for DIOM, pm , the last column of Pm , can be computed from the previous pi ’s
and vm by the simple update
−1
pm = ηm
[vm − βm pm−1 ].

Note that βm is a scalar computed from the Lanczos algorithm, while ηm results from
the m-th Gaussian elimination step on the tridiagonal matrix, i.e.,
βm
,
ηm−1
= αm − λm βm .

λm =

(6.88)

ηm

(6.89)

In addition, following again what has been shown for DIOM,


zm−1
,
zm =
ζm
in which ζm = −λm ζm−1 . As a result, xm can be updated at each step as
xm = xm−1 + ζm pm
where pm is defined above.
This gives the following algorithm, which we call the direct version of the Lanczos algorithm for linear systems.
A LGORITHM 6.17 D-Lanczos

198

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I
Compute r0 = b − Ax0 , ζ1 := β := kr0 k2 , and v1 := r0 /β
Set λ1 = β1 = 0, p0 = 0
For m = 1, 2, . . . , until convergence Do:
Compute w := Avm − βm vm−1 and αm = (w, vm )
βm
If m > 1 then compute λm = ηm−1
and ζm = −λm ζm−1
ηm = αm − λm βm
−1 (v − β p
pm = ηm
m
m m−1 )
xm = xm−1 + ζm pm
If xm has converged then Stop
w := w − αm vm
βm+1 = kwk2 , vm+1 = w/βm+1
EndDo

This algorithm computes the solution of the tridiagonal system Tm ym = βe1
progressively by using Gaussian elimination without pivoting. However, as was explained for DIOM, partial pivoting can also be implemented at the cost of having to
keep an extra vector. In fact, Gaussian elimination with partial pivoting is sufficient
to ensure stability for tridiagonal systems. The more complex LQ factorization has
also been exploited in this context and gave rise to an algorithm known as SYMMLQ
[223].
The two algorithms 6.16 and 6.17 are mathematically equivalent, that is, they
deliver the same approximate solution if they are both executable. However, since
Gaussian elimination without pivoting is being used implicitly to solve the tridiagonal system Tm y = βe1 , the direct version may be more prone to breakdowns.
Observe that the residual vector for this algorithm is in the direction of vm+1 due
to equation (6.87). Therefore, the residual vectors are orthogonal to each other as
in FOM. Likewise, the vectors pi are A-orthogonal, or conjugate. These results are
established in the next proposition.
Proposition 6.20 Let rm = b−Axm , m = 0, 1, . . ., be the residual vectors produced
by the Lanczos and the D-Lanczos algorithms (6.16 and 6.17) and pm , m = 0, 1, . . . ,
the auxiliary vectors produced by Algorithm 6.17. Then,
1. Each residual vector rm is such that rm = σm vm+1 where σm is a certain
scalar. As a result, the residual vectors are orthogonal to each other.
2. The auxiliary vectors pi form an A-conjugate set, i.e., (Api , pj ) = 0, for i 6= j.
Proof. The first part of the proposition is an immediate consequence of the relation
T AP is a diagonal matrix,
(6.87). For the second part, it must be proved that Pm
m
−1 . This follows from
where Pm = Vm Um
T
−T T
−1
Pm
APm = Um
Vm AVm Um
−T
−1
= Um
Tm Um
−T
= Um
Lm .

6.7. THE CONJUGATE GRADIENT ALGORITHM

199

−T L is a lower triangular matrix which is also symmetric since
Now observe that Um
m
T AP . Therefore, it must be a diagonal matrix.
it is equal to the symmetric matrix Pm
m

A consequence of the above proposition is that a version of the algorithm can be
derived by imposing the orthogonality and conjugacy conditions. This gives the Conjugate Gradient algorithm which we now derive. The vector xj+1 can be expressed
as
xj+1 = xj + αj pj .
(6.90)
In order to conform with standard notation used in the literature to describe the algorithm, the indexing of the p vectors now begins at zero instead of one as was done so
far. This explains the difference between the above formula and formula (6.21) used
for DIOM. Now, the residual vectors must satisfy the recurrence
rj+1 = rj − αj Apj .

(6.91)

If the rj ’s are to be orthogonal, then it is necessary that (rj − αj Apj , rj ) = 0 and as
a result
(rj , rj )
.
(6.92)
αj =
(Apj , rj )
Also, it is known that the next search direction pj+1 is a linear combination of rj+1
and pj , and after rescaling the p vectors appropriately, it follows that
pj+1 = rj+1 + βj pj .

(6.93)

Thus, a first consequence of the above relation is that
(Apj , rj ) = (Apj , pj − βj−1 pj−1 ) = (Apj , pj )
because Apj is orthogonal to pj−1 . Then, (6.92) becomes αj = (rj , rj )/(Apj , pj ).
In addition, writing that pj+1 as defined by (6.93) is orthogonal to Apj yields
βj = −

(rj+1 , Apj )
.
(pj , Apj )

Apj = −

1
(rj+1 − rj )
αj

Note that from (6.91)

and therefore,
βj =

(rj+1 , rj+1 )
1 (rj+1 , (rj+1 − rj ))
=
.
αj
(Apj , pj )
(rj , rj )

Putting these relations together gives the following algorithm.
A LGORITHM 6.18 Conjugate Gradient

(6.94)

200

1.
2.
3.
4.
5.
6.
7.
8.

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I
Compute r0 := b − Ax0 , p0 := r0 .
For j = 0, 1, . . . , until convergence Do:
αj := (rj , rj )/(Apj , pj )
xj+1 := xj + αj pj
rj+1 := rj − αj Apj
βj := (rj+1 , rj+1 )/(rj , rj )
pj+1 := rj+1 + βj pj
EndDo

It is important to note that the scalars αj , βj in this algorithm are different from those
of the Lanczos algorithm. The vectors pj are multiples of the pj ’s of Algorithm 6.17.
In terms of storage, in addition to the matrix A, four vectors (x, p, Ap, and r) must be
saved in Algorithm 6.18, versus five vectors (vm , vm−1 , w, p, and x) for Algorithm
6.17.

6.7.2

Alternative Formulations

Algorithm 6.18 is the best known formulation of the Conjugate Gradient algorithm.
There are, however, several alternative formulations. Here, only one such formulation is shown, which can be derived once more from the Lanczos algorithm.
The residual polynomial rm (t) associated with the m-th CG iterate must satisfy
a three-term recurrence, implied by the three-term recurrence of the Lanczos vectors.
Indeed, these vectors are just the scaled versions of the residual vectors. Therefore,
we must seek a three-term recurrence of the form
rm+1 (t) = ρm (rm (t) − γm trm (t)) + δm rm−1 (t).
In addition, the consistency condition rm (0) = 1 must be maintained for each m,
leading to the recurrence,
rm+1 (t) = ρm (rm (t) − γm trm (t)) + (1 − ρm )rm−1 (t).

(6.95)

Observe that if rm (0) = 1 and rm−1 (0) = 1, then rm+1 (0) = 1, as desired. Translating the above relation into the sequence of residual vectors yields
rm+1 = ρm (rm − γm Arm ) + (1 − ρm )rm−1 .

(6.96)

Recall that the vectors ri ’s are multiples of the Lanczos vectors vi ’s. As a result,
γm should be the inverse of the scalar αm of the Lanczos algorithm. In terms of the
r-vectors this means
(rm , rm )
.
γm =
(Arm , rm )
Equating the inner products of both sides of (6.96) with rm−1 , and using the orthogonality of the r-vectors, gives the following expression for ρm , after some algebraic
calculations,
−1

(rm , rm )
1
γm
.
(6.97)
ρm = 1 −
γm−1 (rm−1 , rm−1 ) ρm−1

6.7. THE CONJUGATE GRADIENT ALGORITHM

201

The recurrence relation for the approximate solution vectors can be extracted
from the recurrence relation for the residual vectors. This is found by starting from
(6.95) and using the relation rm (t) = 1 − tsm−1 (t) between the solution polynomial
sm−1 (t) and the residual polynomial rm (t). Thus,
1 − rm+1 (t)

t
1 − rm−1 (t)
1 − rm (t)
− γm rm (t) + (1 − ρm )
= ρm
t
t
= ρm (sm−1 (t) − γm rm (t)) + (1 − ρm )sm−2 (t).

sm (t) =

This gives the recurrence,
xm+1 = ρm (xm − γm rm ) + (1 − ρm )xm−1 .

(6.98)

All that is left for the recurrence to be determined completely is to define the first
two iterates. The initial iterate x0 is given. The first vector should be of the form
x1 = x0 − γ0 r0 ,
to ensure that r1 is orthogonal to r0 . This means that the two-term recurrence can be
started with ρ0 = 1, and by setting x−1 ≡ 0. Putting these relations and definitions
together gives the following algorithm.
A LGORITHM 6.19 CG – Three-Term Recurrence Variant

1.
2.
3.
4.
5.
6.
7.

Compute r0 = b − Ax0 . Set x−1 ≡ 0 and ρ0 = 1.
For j = 0, 1, . . . , until convergence Do:
(r ,r )
Compute Arj and γj = (Arjj ,rjj )
h
i−1
γj
(rj ,rj )
1
If (j > 0) compute ρj = 1 − γj−1
(rj−1 ,rj−1 ) ρj−1
Compute xj+1 = ρj (xj − γj rj ) + (1 − ρj )xj−1
Compute rj+1 = ρj (rj − γj Arj ) + (1 − ρj )rj−1
EndDo

This algorithm requires slightly more storage than the standard formulation: in addition to A, the vectors rj , Arj , rj−1 , xj and xj−1 must be kept. It is possible to avoid
keeping rj−1 by computing the residual rj+1 directly as rj+1 = b − Axj+1 in line 6
of the algorithm, but this would entail an additional matrix-vector product.

6.7.3

Eigenvalue Estimates from the CG Coefficients

Sometimes, it is useful to be able to obtain the tridiagonal matrix Tm related to the
underlying Lanczos iteration from the coefficients of the Conjugate Gradient algorithm 6.18. This tridiagonal matrix can provide valuable eigenvalue information on
the matrix A. For example, the largest and smallest eigenvalues of the tridiagonal
matrix can approximate the smallest and largest eigenvalues of A. This could be

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

202

used to compute an estimate of the condition number of A which in turn can help
provide estimates of the error norm from the residual norm. Since the Greek letters
αi and βi have been used in both algorithms, notations must be changed. Denote by
Tm = tridiag [ηj , δj , ηj+1 ],
the tridiagonal matrix (6.84) associated with the m-th step of the Lanczos algorithm.
We must seek expressions of the coefficients ηj , δj in terms of the coefficients αj , βj ,
obtained from the CG algorithm. The key information regarding the correspondence
between the two pairs of coefficients resides in the correspondence between the vectors generated by the two algorithms.
From (6.87) it is known that
rj = scalar × vj+1 .
As a result,
δj+1 =

(6.99)

(Arj , rj )
(Avj+1 , vj+1 )
=
.
(vj+1 , vj+1 )
(rj , rj )

The denominator (rj , rj ) is readily available from the coefficients of the CG algorithm, but the numerator (Arj , rj ) is not. The relation (6.93) can be exploited to
obtain
rj = pj − βj−1 pj−1
(6.100)
which is then substituted in (Arj , rj ) to get
(Arj , rj ) = (A(pj − βj−1 pj−1 ), pj − βj−1 pj−1 ) .
Note that the terms βj−1 pj−1 are defined to be zero when j = 0. Because the p
vectors are A-orthogonal,
2
(Arj , rj ) = (Apj , pj ) + βj−1
(Apj−1 , pj−1 ) ,

from which we finally obtain for j > 0,
δj+1 =

(Apj , pj )
βj−1
1
2 (Apj−1 , pj−1 )
+ βj−1
=
+
.
(rj , rj )
(rj , rj )
αj
αj−1

(6.101)

The above expression is only valid for j > 0. For j = 0, the second term in the
right-hand side should be omitted as was observed above. Therefore, the diagonal
elements of Tm are given by
( 1
for j = 0,
αj
(6.102)
δj+1 =
β
j−1
1
αj + αj−1 for j > 0.
Now an expression for the co-diagonal elements ηj+1 is needed. From the definitions in the Lanczos algorithm,
ηj+1 = (Avj , vj+1 ) =

|(Arj−1 , rj )|
.
krj−1 k2 krj k2

6.8. THE CONJUGATE RESIDUAL METHOD

203

Using (6.100) again and the relation (6.94) as well as orthogonality properties of the
CG algorithm, the following sequence of equalities results:
(Arj−1 , rj ) = (A(pj−1 − βj−2 pj−2 ), rj )

= (Apj−1 , rj ) − βj−2 (Apj−2 , rj )
βj−2
−1
(rj − rj−1 , rj ) +
(rj−1 − rj−2 , rj )
=
αj−1
αj−2
−1
=
(rj , rj ).
αj−1

Therefore,
p
βj−1
(rj , rj )
1 krj k2
=
=
.
ηj+1 =
αj−1 krj−1 k2 krj k2
αj−1 krj−1 k2
αj−1
1

This finally gives the general form of the m-dimensional Lanczos tridiagonal matrix
in terms of the CG coefficients,
√

 1
β0
α

 √β00
 α0

Tm = 




6.8

α0
β0
1
α1 + α0

.

√

β1
α1

.
.

√

.
.

βm−2
αm−2

√

βm−2
αm−2
βm−2
1
αm−1 + αm−2




.




(6.103)

The Conjugate Residual Method

In the previous section we derived the Conjugate Gradient algorithm as a special
case of FOM for Symmetric Positive Definite matrices. Similarly, a new algorithm
can be derived from GMRES for the particular case where A is Hermitian. In this
case, the residual vectors should be A-orthogonal, i.e., conjugate. In addition, the
vectors Api ’s i = 0, 1, . . . , are orthogonal. When looking for an algorithm with the
same structure as CG, but satisfying these conditions, we find the Conjugate Residual
algorithm. Notice that the residual vectors are now conjugate to each other, hence,
the name of the algorithm.
A LGORITHM 6.20 Conjugate Residual Algorithm

1.
2.
3.
4.
5.
6.
7.
8.
9.

Compute r0 := b − Ax0 , p0 := r0
For j = 0, 1, . . . , until convergence Do:
αj := (rj , Arj )/(Apj , Apj )
xj+1 := xj + αj pj
rj+1 := rj − αj Apj
βj := (rj+1 , Arj+1 )/(rj , Arj )
pj+1 := rj+1 + βj pj
Compute Apj+1 = Arj+1 + βj Apj
EndDo

204

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Line 8 in the above algorithm computes Apj+1 from Arj+1 without an additional
matrix-vector product. Five vectors of storage are needed in addition to the matrix A:
x, p, Ap, r, Ar. The algorithm requires one more vector update, i.e., 2n more operations than the Conjugate Gradient method and one more vector of storage. Since the
two methods exhibit typically similar convergence, the Conjugate Gradient method
is often preferred.

6.9

GCR, ORTHOMIN, and ORTHODIR

All algorithms developed in this chapter are strongly related to, as well as defined
by, the choice of a basis of the Krylov subspace. The GMRES algorithm uses an orthonormal basis. In the Conjugate Gradient algorithm, the p’s are A-orthogonal, i.e.,
conjugate. In the Conjugate Residual method just described, the Api ’s are orthogonal, i.e., the pi ’s are AT A-orthogonal. A number of algorithms can be developed
using a basis of this form in the nonsymmetric case as well. The main result that is
exploited in all these algorithms is the following lemma.
Lemma 6.21 Let p0 , p1 , . . . , pm−1 , be a sequence of vectors such that each set {p0 , p1 ,. . . , pj−1 } for j ≤ m is a basis of the Krylov subspace Kj (A, r0 ) which is AT Aorthogonal, i.e., such that
(Api , Apk ) = 0,

for i 6= k.

Then the approximate solution xm which has the smallest residual norm in the affine
space x0 + Km (A, r0 ) is given by
xm = x0 +

m−1
X
i=0

(r0 , Api )
pi .
(Api , Api )

(6.104)

In addition, xm can be computed from xm−1 by
xm = xm−1 +

(rm−1 , Apm−1 )
pm−1 .
(Apm−1 , Apm−1 )

(6.105)

Proof. The approximate solution and the associated residual vector can be written in
the form
m−1
m−1
X
X
αi Api .
(6.106)
αi pi , rm = r0 −
xm = x0 +
i=0

i=0

According to the optimality result of Proposition 5.3, in order for krm k2 to be minimum, the orthogonality relations
(rm , Api ) = 0,

i = 0, . . . , m − 1

must be enforced. Using (6.106) and the orthogonality of the Api ’s gives immediately,
αi = (r0 , Api )/(Api , Api ).

6.9. GCR, ORTHOMIN, AND ORTHODIR

205

This proves the first part of the lemma. Assume now that xm−1 is known and that xm
must be determined. According to formula (6.104), and the fact that p0 , . . . , pm−2 is
a basis of Km−1 (A, r0 ), we can write xm = xm−1 + αm−1 pm−1 with αm−1 defined
above. Note that from the second part of (6.106),
rm−1 = r0 −

m−2
X

αj Apj

j=0

so that
(rm−1 , Apm−1 ) = (r0 , Apm−1 ) −

m−2
X

αj (Apj , Apm−1 ) = (r0 , Apm−1 )

j=0

exploiting, once more, the orthogonality of the vectors Apj , j = 0, . . . , m − 1. Thus,
αm−1 =

(rm−1 , Apm−1 )
,
(Apm−1 , Apm−1 )

which proves the expression (6.105).
This lemma opens up many different ways to obtain algorithms that are mathematically equivalent to the full GMRES. The simplest option computes the next basis
vector pm+1 as a linear combination of the current residual rm and all previous pi ’s.
The approximate solution is updated by using (6.105). This is called the Generalized
Conjugate Residual (GCR) algorithm.
A LGORITHM 6.21 GCR

1.
2.
3.
4.
5.
6.
7.
8.

Compute r0 = b − Ax0 . Set p0 = r0 .
For j = 0, 1, . . . , until convergence Do:
(r ,Ap )
αj = (Apj j ,Apjj )
xj+1 = xj + αj pj
rj+1 = rj − αj Apj
(Ar
,Api )
Compute βij = − (Apj+1
, for i = 0, 1, . . . , j
Pj i ,Api )
pj+1 = rj+1 + i=0 βij pi
EndDo

To compute the scalars βij in the above algorithm, the vector Arj and the previous
Api ’s are required. In order to limit the number of matrix-vector products per step to
one, we can proceed as follows. Follow line 5 by a computation of Arj+1 and then
compute Apj+1 after line 7 from the relation
Apj+1 = Arj+1 +

j
X
i=0

βij Api .

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

206

Both the set of pi ’s and that of the Api ’s need to be saved. This doubles the storage
requirement compared with GMRES. The number of arithmetic operations per step
is also roughly 50% higher than GMRES.
The above version of GCR suffers from the same practical limitations as GMRES and FOM. A restarted version called GCR(m) can be trivially defined. Also,
a truncation of the orthogonalization of the Api ’s, similar to IOM, leads to an algorithm known as ORTHOMIN(k). Specifically, lines 6 and 7 of Algorithm 6.21 are
replaced by
(Ar

,Ap )

i
Compute βij = − (Apj+1
, for i = j − k + 1, . . . , j
Pj i ,Api )
pj+1 = rj+1 + i=j−k+1 βij pi .

6a.
7a.

Another class of algorithms is defined by computing the next basis vector pj+1
as
pj+1 = Apj +

j
X

βij pi

(6.107)

i=0

in which, as before, the βij ’s are selected to make the Api ’s orthogonal, i.e.,
βij = −

(A2 pj , Api )
.
(Api , Api )

The resulting algorithm is called ORTHODIR [178]. Restarted and truncated versions of ORTHODIR can also be defined.

6.10

The Faber-Manteuffel Theorem

As was seen in Section 6.6 when A is symmetric, the Arnoldi algorithm simplifies
into the Lanczos procedure, which is defined through a three-term recurrence. As
a consequence, FOM is mathematically equivalent to the Conjugate Gradient algorithm in this case. Similarly, the full GMRES algorithm gives rise to the Conjugate
Residual algorithm. It is clear that the CG-type algorithms, i.e., algorithms defined
through short-term recurrences, are more desirable than those algorithms which require storing entire sequences of vectors as in the GMRES process. These algorithms
require less memory and operations per step.
Therefore, the question is: Is it possible to define algorithms which are based
on optimal Krylov subspace projection and which give rise to sequences involving
short-term recurrences? An optimal Krylov subspace projection means a technique
which minimizes a certain norm of the error, or residual, on the Krylov subspace.
Such methods can be defined from the Arnoldi process.
It is sufficient to consider the Arnoldi process. If Arnoldi’s algorithm reduces
to the s-term Incomplete Orthogonalization Algoritm (Algorithm 6.6 with k ≡ s),
i.e., if hij = 0 for i < j − s + 1, then an (s − 1)-term recurrence can be defined
for updating the iterates, as was done in Section 6.4.2. Conversely, if the solution is
updated as xj+1 = xj + αj pj and pj satisfies a short recurrence, then the residual

6.10. THE FABER-MANTEUFFEL THEOREM

207

vectors will satisfy an s-term recurrence, i.e., hij = 0 for i < j − s + 1. A similar
argument can be used for the the (full) GMRES algorithm when it simplifies into
DQGMRES. For all purposes, it is therefore sufficient to analyze what happens to
the Arnoldi process (or FOM). We start by generalizing the CG result in a simple
way, by considering the DIOM algorithm.
Proposition 6.22 Let A be a matrix such that
AT v ∈ Ks (A, v)
for any vector v. Then, DIOM(s) is mathematically equivalent to the FOM algorithm.
Proof. The assumption is equivalent to the statement that, for any v, there is a polynomial qv of degree ≤ s − 1, such that AT v = qv (A)v. In the Arnoldi process, the
scalars hij are defined by hij = (Avj , vi ) and therefore
hij = (Avj , vi ) = (vj , AT vi ) = (vj , qvi (A)vi ).

(6.108)

Since qvi is a polynomial of degree ≤ s − 1, the vector qvi (A)vi is a linear combination of the vectors vi , vi+1 , . . . , vi+s−1 . As a result, if i < j − s + 1, then hij = 0.
Therefore, DIOM(s) will give the same approximate solution as FOM.
In particular, if
AT = q(A)
where q is a polynomial of degree ≤ s − 1, then the result holds. However, since
Aq(A) = q(A)A for any polynomial q, the above relation implies that A is normal.
As it turns out, the reverse is also true. That is, when A is normal, then there is a
polynomial of degree ≤ n − 1 such that AH = q(A). Proving this is easy because
when A = QΛQH where Q is unitary and Λ diagonal, then q(A) = Qq(Λ)QH .
Choosing the polynomial q so that
q(λj ) = λ̄j , j = 1, . . . , n
results in q(A) = QΛ̄QH = AH as desired.
Let ν(A) be the smallest degree of all polynomials q such that AH = q(A). Then
the following lemma due to Faber and Manteuffel [121] states an interesting relation
between s and ν(A).
Lemma 6.23 A nonsingular matrix A is such that
AH v ∈ Ks (A, v)
for every vector v if and only if A is normal and ν(A) ≤ s − 1.

208

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Proof. The sufficient condition is trivially true. To prove the necessary condition,
assume that, for any vector v, AH v = qv (A)v where qv is a polynomial of degree
≤ s − 1. Then it is easily seen that any eigenvector of A is also an eigenvector
of AH . Therefore, from Lemma 1.15, A is normal. Let µ be the degree of the
minimal polynomial for A. Then, since A has µ distinct eigenvalues, there is a
polynomial q of degree µ − 1 such that q(λi ) = λ̄i for i = 1, . . . , µ. According to
the above argument, for this q, it holds AH = q(A) and therefore ν(A) ≤ µ − 1.
Now it must be shown that µ ≤ s. Let w be a (nonzero) vector whose grade is
µ. By assumption, AH w ∈ Ks (A, w). On the other hand, we also have AH w =
q(A)w. Since the vectors w, Aw, . . . , Aµ−1 w are linearly independent, µ − 1 must
not exceed s − 1. Otherwise, two different expressions for AH w with respect to the
basis w, Aw, . . . , Aµ−1 w would result and this would imply that AH w = 0. Since
A is nonsingular, then w = 0, which is a contradiction.
Proposition 6.22 gives a sufficient condition for DIOM(s) to be equivalent to
FOM. According to Lemma 6.23, this condition is equivalent to A being normal and
ν(A) ≤ s − 1. Now consider the reverse result. Faber and Manteuffel define CG(s)
to be the class of all matrices such that for every v1 , it is true that (Avj , vi ) = 0 for
all i, j such that i + s ≤ j ≤ µ(v1 ) − 1. The inner product can be different from
the canonical Euclidean dot product. With this definition it is possible to show the
following theorem [121] which is stated without proof.
Theorem 6.24 A ∈ CG(s), if and only if the minimal polynomial of A has degree
≤ s, or A is normal and ν(A) ≤ s − 1.
It is interesting to consider the particular case where ν(A) ≤ 1, which is the case
of the Conjugate Gradient method. In fact, it is easy to show that in this case A either
has a minimal degree ≤ 1, or is Hermitian, or is of the form
A = eiθ (ρI + B)
where θ and ρ are real and B is skew-Hermitian, i.e., B H = −B. Thus, the cases
in which DIOM simplifies into an (optimal) algorithm defined from a three-term
recurrence are already known. The first is the Conjugate Gradient method. The
second is a version of the CG algorithm for skew-Hermitian matrices which can be
derived from the Lanczos algorithm in the same way as CG. This algorithm will be
seen in Chapter 9.

6.11

Convergence Analysis

The convergence behavior of the different algorithms seen in this chapter can be
analyzed by exploiting optimality properties whenever such properties exist. This
is the case for the Conjugate Gradient and the GMRES algorithms. On the other
hand, the non-optimal algorithms such as FOM, IOM, and QGMRES will be harder
to analyze.

6.11. CONVERGENCE ANALYSIS

209

One of the main tools used in the analysis of these methods is Chebyshev polynomials. These polynomials are useful both in theory, when studying convergence,
and in practice, as a means of accelerating single-vector iterations or projection processes. In the following, real and complex Chebyshev polynomials are discussed
separately.

6.11.1

Real Chebyshev Polynomials

The Chebyshev polynomial of the first kind of degree k is defined by
Ck (t) = cos[k cos−1 (t)]

for

− 1 ≤ t ≤ 1.

(6.109)

That this is a polynomial with respect to t can be shown easily by induction from the
trigonometric relation
cos[(k + 1)θ] + cos[(k − 1)θ] = 2 cos θ cos kθ,
and the fact that C1 (t) = t, C0 (t) = 1. Incidentally, this also shows the important
three-term recurrence relation
Ck+1 (t) = 2 t Ck (t) − Ck−1 (t).
The definition (6.109) can be extended to cases where |t| > 1 with the help of the
following formula:
Ck (t) = cosh [k cosh−1 (t)],

|t| ≥ 1.

(6.110)

This is readily seen by passing to complex variables and using the definition cos θ =
(eiθ + e−iθ )/2. As a result of (6.110) the following expression can be derived:

k 
−k 
p
p
1 
t + t2 − 1 + t + t2 − 1
,
(6.111)
Ck (t) =
2

which is valid for |t| ≥ 1 but can also be extended to the case of |t| < 1. The
following approximation, valid for large values of k, will be sometimes used:
k
p
1
t + t2 − 1
Ck (t) '
for |t| ≥ 1.
(6.112)
2
In what follows we denote by Pk the set of all polynomials of degree k. An
important result from approximation theory is the following theorem.
Theorem 6.25 Let [α, β] be a non-empty interval in R and let γ be any real scalar
outside the interval [α, β]. Then the minimum
min

max |p(t)|

p∈Pk ,p(γ)=1 t∈[α,β]

is reached by the polynomial


t−β
Ck 1 + 2 β−α

.
Ĉk (t) ≡
γ−β
Ck 1 + 2 β−α

(6.113)

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

210

For a proof, see Cheney [77]. The maximum of Ck for t in [−1, 1] is 1 and a
corollary of the above result is
min

max |p(t)| =

p∈Pk , p(γ)=1 t∈[α,β]

1
γ−β
|Ck (1 + 2 β−α
)|

=

1
γ−µ
|Ck (2 β−α
)|

in which µ ≡ (α + β)/2 is the middle of the interval. The absolute values in the
denominator are needed only when γ is to the left of the interval, i.e., when γ ≤ α.
For this case, it may be more convenient to express the best polynomial as


α−t
Ck 1 + 2 β−α

.
Ĉk (t) ≡
α−γ
Ck 1 + 2 β−α
which is obtained by exchanging the roles of α and β in (6.113).

6.11.2

Complex Chebyshev Polynomials

The standard definition of real Chebyshev polynomials given by equation (6.109)
extends without difficulty to complex variables. First, as was seen before, when t is
real and |t| > 1, the alternative definition, Ck (t) = cosh[k cosh−1 (t)], can be used.
These definitions can be unified by switching to complex variables and writing
Ck (z) = cosh(kζ),

where

cosh(ζ) = z .

Defining the variable w = eζ , the above formula is equivalent to
Ck (z) =

1 k
[w + w−k ] where
2

1
z = [w + w−1 ].
2

(6.114)

The above definition for Chebyshev polynomials will be used in C. Note that the
equation 12 (w + w−1 ) = z has two solutions w which are inverse of each other. As
a result, the value of Ck (z) does not depend on which of these solutions is chosen.
It can be verified directly that the Ck ’s defined by the above equations are indeed
polynomials in the z variable and that they satisfy the three-term recurrence
Ck+1 (z) = 2 zCk (z) − Ck−1 (z),
C0 (z) ≡ 1,

(6.115)

C1 (z) ≡ z.

As is now explained, Chebyshev polynomials are intimately related to ellipses in
the complex plane. Let Cρ be the circle of radius ρ centered at the origin. Then the
so-called Joukowski mapping
1
J(w) = [w + w−1 ]
2
transforms Cρ into an ellipse centered at the origin, with foci −1, 1, major semi-axis
1
1
−1
−1
2 [ρ + ρ ] and minor semi-axis 2 |ρ − ρ |. This is illustrated in Figure 6.2.

6.11. CONVERGENCE ANALYSIS

211

There are two circles which have the same image by the mapping J(w), one
with the radius ρ and the other with the radius ρ−1 . So it is sufficient to consider
only those circles with radius ρ ≥ 1. Note that the case ρ = 1 is a degenerate case in
which the ellipse E(0, 1, −1) reduces to the interval [−1, 1] traveled through twice.
An important question is whether or not a generalization of the min-max result of
Theorem 6.25 holds for the complex case. Here, the maximum of |p(z)| is taken over
the ellipse boundary and γ is some point not enclosed by the ellipse. The answer to
the question is no; Chebyshev polynomials are only optimal in some cases. However,
Chebyshev polynomials are asymptotically optimal, which is all that is needed in
practice.
J(w)
ℑm(w)

✻

✲
ℑm(z)

• w = ρe

iθ

✲ ℜe(w)

✻

w+w
• z=
2

−1

✲ ℜe(z)

Figure 6.2: The Joukowski mapping transforms a circle into an ellipse in the complex
plane.
To prove the asymptotic optimality, we begin with a lemma due to Zarantonello,
which deals with the particular case where the ellipse reduces to a circle. This particular case is important in itself.
Lemma 6.26 (Zarantonello) Let C(0, ρ) be a circle of center the origin and radius
ρ and let γ be a point of C not enclosed by C(0, ρ). Then
 k
ρ
,
(6.116)
min
max |p(z)| =
|γ|
p∈Pk , p(γ)=1
z ∈ C(0,ρ)

the minimum being achieved for the polynomial (z/γ)k .
Proof. See reference [232] for a proof.

Note that by changing variables, shifting, and rescaling the polynomial, then for
any circle centered at c and for any scalar γ such that |γ| > ρ, the following min-max
result holds:

k
ρ
.
min
max |p(z)| =
|γ − c|
p∈Pk p(γ)=1
z ∈ C(c,ρ)
Now consider the case of an ellipse centered at the origin, with foci 1, −1 and
semi-major axis a, which can be considered as mapped by J from the circle C(0, ρ),
with the convention that ρ ≥ 1. Denote by Eρ such an ellipse.

212

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Theorem 6.27 Consider the ellipse Eρ mapped from C(0, ρ) by the mapping J and
let γ be any point in the complex plane not enclosed by it. Then
ρk
≤
min
|wγ |k
p∈Pk p(γ)=1

max |p(z)| ≤

z ∈ Eρ

ρk + ρ−k
|wγk + wγ−k |

(6.117)

in which wγ is the dominant root of the equation J(w) = γ.
Proof. We start by showing the second inequality. Any polynomial p of degree k
satisfying the constraint p(γ) = 1 can be written as
Pk
j
j=0 ξj z
.
p(z) = Pk
j
j=0 ξj γ

A point z on the ellipse is transformed by J from a certain w in C(0, ρ). Similarly,
let wγ be one of the two inverse transforms of γ by the mapping, namely, the one
with largest modulus. Then, p can be rewritten as
Pk
j
−j
j=0 ξj (w + w )
p(z) = Pk
.
(6.118)
j
−j
j=0 ξj (wγ + wγ )

Consider the particular polynomial obtained by setting ξk = 1 and ξj = 0 for j 6= k,
p∗ (z) =

wk + w−k
wγk + wγ−k

which is a scaled Chebyshev polynomial of the first kind of degree k in the variable z.
It is apparent that the maximum modulus of this polynomial is reached in particular
when w = ρeiθ is real, i.e., when w = ρ. Thus,
max |p∗ (z)| =
z∈Eρ

ρk + ρ−k
|wγk + wγ−k |

which proves the second inequality.
To prove the left inequality, we rewrite (6.118) as
! Pk
k+j + w k−j )
w−k
j=0 ξj (w
p(z) =
Pk
k+j
wγ−k
+ wγk−j )
j=0 ξj (wγ

and take the modulus of p(z),

ρ−k
|p(z)| =
|wγ |−k

Pk

k+j + w k−j )
j=0 ξj (w
Pk
k+j
+ wγk−j )
j=0 ξj (wγ

.

The polynomial in w of degree 2k inside the large modulus bars in the right-hand side
is such that its value at wγ is one. By Lemma 6.26, the modulus of this polynomial

6.11. CONVERGENCE ANALYSIS

213

over the circle C(0, ρ) is not less than (ρ/|wγ |)2k , i.e., for any polynomial, satisfying
the constraint p(γ) = 1,
max |p(z)| ≥

z∈ Eρ

ρ2k
ρk
ρ−k
=
.
|wγ |−k |wγ |2k
|wγ |k

This proves that the minimum over all such polynomials of the maximum modulus
on the ellipse Eρ is ≥ (ρ/|wγ |)k .
The difference between the left and right bounds in (6.117) tends to zero as k
increases to infinity. Thus, the important point made by the theorem is that for large
k, the Chebyshev polynomial
p∗ (z) =

wk + w−k
,
wγk + wγ−k

where

z=

w + w−1
2

is close to the optimal polynomial. More specifically, Chebyshev polynomials are
asymptotically optimal.
For a more general ellipse E(c, d, a) centered at c, and with focal distance d and
semi-major axis a, a simple change of variables shows that the near-best polynomial
is given by

Ck c−z
d
.
(6.119)
Ĉk (z) =
Ck c−γ
d

In addition, by examining the expression (wk + w−k )/2 for w = ρeiθ it is easily
seen that the maximum modulus of Ĉk (z), i.e., the infinity norm of this polynomial
over the ellipse, is reached at the point c + a located on the real axis. From this we
get,

Ck ad

max |Ĉk (z)| =
z ∈ E(c,d,a)
|Ck c−γ
|
d

Here, we point out that d and a both can be purely imaginary [for an example, see part
(B) of Figure 6.3]. In this case a/d is real and the numerator in the above expression
is always real. Using the definition for Ck we obtain the following useful expression
and approximation:

k 
−k
q 
q 
2
2
a
a
a
a

−1 + d +
−1
d +
d
d
Ck ad
 = 
k 
−k (6.120)
q
q
Ck c−γ
c−γ
c−γ 2
c−γ 2
c−γ
d
−1 +
−1
d +
d
d +
d
!k
√
a + a2 − d2
p
≈
(6.121)
c − γ + (c − γ)2 − d2

Finally, we note that an alternative and more detailed result has been proven by
Fischer and Freund in [127].

214

6.11.3

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Convergence of the CG Algorithm

As usual, kxkA denotes the norm defined by
kxkA = (Ax, x)1/2 .
The following lemma characterizes the approximation obtained from the Conjugate
Gradient algorithm.
Lemma 6.28 Let xm be the approximate solution obtained from the m-th step of the
CG algorithm, and let dm = x∗ − xm where x∗ is the exact solution. Then, xm is of
the form
xm = x0 + qm (A)r0
where qm is a polynomial of degree m − 1 such that
k(I − Aqm (A))d0 kA =

min

q ∈ Pm−1

k(I − Aq(A))d0 kA .

Proof. This is a consequence of the fact that xm minimizes the A-norm of the error
in the affine subspace x0 + Km , a result of Proposition 5.2, and the fact that Km is
the set of all vectors of the form x0 + q(A)r0 , where q is a polynomial of degree
≤ m − 1.
From this, the following theorem can be proved.
Theorem 6.29 Let xm be the approximate solution obtained at the m-th step of the
Conjugate Gradient algorithm, and x∗ the exact solution and define
η=

λmin
.
λmax − λmin

(6.122)

Then,

kx∗ − x0 kA
,
Cm (1 + 2η)
in which Cm is the Chebyshev polynomial of degree m of the first kind.
kx∗ − xm kA ≤

(6.123)

Proof. From the previous lemma, it is known that kx∗ − xm kA minimizes A-norm
of the error over polynomials r(t) which take the value one at 0, i.e.,
kx∗ − xm kA =

min

r∈ Pm , r(0)=1

kr(A)d0 kA .

If λi , i = 1, . . . , n are the eigenvalues of A, and ξi , i = 1, . . . , n the components of
the initial error d0 in the eigenbasis, then
kr(A)d0 k2A =
≤

n
X
i=1

λi r(λi )2 (ξi )2 ≤ max(r(λi ))2 kd0 k2A
i

max

λ ∈[λmin ,λmax ]

(r(λ))2 kd0 k2A .

6.11. CONVERGENCE ANALYSIS

215

Therefore,
kx∗ − xm kA ≤

min

r∈ Pm , r(0)=1

max

λ ∈[λmin ,λmax ]

|r(λ)|kd0 kA .

The result follows immediately by using the well known result of Theorem 6.25 from
approximation theory. This gives the polynomial r which minimizes the right-hand
side.
A slightly different formulation of inequality (6.123) can be derived. Using the
relation,

m 
−m 
p
p
1 
2
2
+ t+ t −1
Cm (t) =
t+ t −1
2
m
p
1
≥
t + t2 − 1
2
then

Cm (1 + 2η) ≥
≥
Now notice that

m
p
1
1 + 2η + (1 + 2η)2 − 1
2
m
p
1
.
1 + 2η + 2 η(η + 1)
2

√
2
p
p
η+ η+1
1 + 2η + 2 η(η + 1) =
2
√
√
λmin + λmax
=
λ
−λ
√ max √ min
λmax + λmin
√
= √
λmax − λmin
√
κ+1
= √
κ−1
in which κ is the spectral condition number κ = λmax /λmin .
Substituting this in (6.123) yields,
√
m
κ−1
kx∗ − xm kA ≤ 2 √
kx∗ − x0 kA .
κ+1

(6.124)
(6.125)
(6.126)
(6.127)

(6.128)

This bound is similar to that of the steepest descent algorithm except that the condition number of A is now replaced by its square root.

6.11.4

Convergence of GMRES

We begin by stating a global convergence result. Recall that a matrix A is called
positive definite if its symmetric part (A + AT )/2 is Symmetric Positive Definite.
This is equivalent to the property that (Ax, x) > 0 for all nonzero real vectors x.

216

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Theorem 6.30 If A is a positive definite matrix, then GMRES(m) converges for any
m ≥ 1.
Proof. This is true because the subspace Km contains the initial residual vector at
each restart. Since the algorithm minimizes the residual norm in the subspace Km ,
at each outer iteration, the residual norm will be reduced by as much as the result of
one step of the Minimal Residual method seen in the previous chapter. Therefore, the
inequality (5.15) is satisfied by residual vectors produced after each outer iteration
and the method converges.
Next we wish to establish a result similar to the one for the Conjugate Gradient
method, which would provide an upper bound on the convergence rate of the GMRES
iterates. We begin with a lemma similar to Lemma 6.28.
Lemma 6.31 Let xm be the approximate solution obtained from the m-th step of the
GMRES algorithm, and let rm = b − Axm . Then, xm is of the form
xm = x0 + qm (A)r0
and
krm k2 = k(I − Aqm (A))r0 k2 =

min

q ∈ Pm−1

k(I − Aq(A))r0 k2 .

Proof. This is true because xm minimizes the 2-norm of the residual in the affine
subspace x0 + Km , a result of Proposition 5.3, and the fact that Km is the set of all
vectors of the form x0 + q(A)r0 , where q is a polynomial of degree ≤ m − 1.
Unfortunately, it not possible to prove a simple result such as Theorem 6.29 unless
A is normal.
Proposition 6.32 Assume that A is a diagonalizable matrix and let A = XΛX −1
where Λ = diag {λ1 , λ2 , . . . , λn } is the diagonal matrix of eigenvalues. Define,
ǫ(m) =

min

max |p(λi )|.

p∈Pm ,p(0)=1 i=1,...,n

Then, the residual norm achieved by the m-th step of GMRES satisfies the inequality
krm k2 ≤ κ2 (X)ǫ(m) kr0 k2 .
where κ2 (X) ≡ kXk2 kX −1 k2 .
Proof. Let p be any polynomial of degree ≤ m which satisfies the constraint p(0) =
1, and x the vector in Km to which it is associated via b − Ax = p(A)r0 . Then,
kb − Axk2 = kXp(Λ)X −1 r0 k2 ≤ kXk2 kX −1 k2 kr0 k2 kp(Λ)k2

6.11. CONVERGENCE ANALYSIS

217

Since Λ is diagonal, observe that
kp(Λ)k2 = max |p(λi )|.
i=1,...,n

Since xm minimizes the residual norm over x0 + Km , then for any consistent polynomial p,
kb − Axm k ≤ kb − Axk2 ≤ kXk2 kX −1 k2 kr0 k2 max |p(λi )|.
i=1,...,n

Now the polynomial p which minimizes the right-hand side in the above inequality
can be used. This yields the desired result,
kb − Axm k ≤ kb − Axk2 ≤ kXk2 kX −1 k2 kr0 k2 ǫ(m) .

(A)

(B)
ℑm(z)

✻
ℑm(z)

c+a

c+d

✻
c−d

■c − a

c

c+d

c+a

✲ ℜe(z)

c

✲ ℜe(z)

c−d

c−a

Figure 6.3: Ellipses containing the spectrum of A. Case (A): real d; case (B): purely
imaginary d.
The results of Section 6.11.2 on near-optimal Chebyshev polynomials in the
complex plane can now be used to obtain an upper bound for ǫ(m) . Assume that
the spectrum of A in contained in an ellipse E(c, d, a) with center c, focal distance
d, and major semi axis a. In addition it is required that the origin lie outside this
ellipse. The two possible cases are shown in Figure 6.3. Case (B) corresponds to
the situation when d is purely imaginary, i.e., the major semi-axis is aligned with the
imaginary axis.
Corollary 6.33 Let A be a diagonalizable matrix, i.e, let A = XΛX −1 where Λ =
diag {λ1 , λ2 , . . . , λn } is the diagonal matrix of eigenvalues. Assume that all the

218

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

eigenvalues of A are located in the ellipse E(c, d, a) which excludes the origin. Then,
the residual norm achieved at the m-th step of GMRES satisfies the inequality,

Cm ad
 kr0 k2 .
krm k2 ≤ κ2 (X)
Cm dc
Proof. All that is needed is an upper bound for the scalar ǫ(m) under the assumptions.
By definition,
ǫ(m) =
≤

min

max |p(λi )|

min

max

p∈Pm ,p(0)=1 i=1,...,n

p∈Pm ,p(0)=1 λ ∈ E(c,d,a)

|p(λ)|.

The second inequality is due to the fact that the maximum modulus of a complex
analytical function is reached on the boundary of the domain. We can now use as a
trial polynomial Ĉm defined by (6.119), with γ = 0:
ǫ(m) ≤

min

max

p∈Pm ,p(0)=1 λ ∈ E(c,d,a)

|p(λ)|

Cm
≤
max |Ĉm (λ)| =
λ ∈ E(c,d,a)
Cm
This completes the proof.



a
d
c .
d



An explicit expression for the coefficient Cm ad / Cm dc and an approximation
are readily obtained from (6.120-6.121) by taking γ = 0:
m 
−m

q 
q 
2
2
a
a
a
a

+ d+
−1
−1
d +
d
d
Cm ad
 = 
m 
−m
q 
q 
Cm dc
c
c 2
c 2
c
+ d+
−1
−1
d +
d
d
!m
√
a + a2 − d2
√
.
≈
c + c2 − d2
Since the condition number κ2 (X) of the matrix of eigenvectors X is typically
not known and can be very large, results of the nature of the corollary are of limited
practical interest. They can be useful only when it is known that the matrix is nearly
normal, in which case, κ2 (X) ≈ 1.

6.12

Block Krylov Methods

In many circumstances, it is desirable to work with a block of vectors instead of
a single vector. For example, out-of-core finite-element codes are more efficient
when they are programmed to exploit the presence of a block of the matrix A in fast
memory, as much as possible. This can be achieved by using block generalizations of

6.12. BLOCK KRYLOV METHODS

219

Krylov subspace methods, for which A always operates on a group of vectors instead
of a single vector. We begin by describing a block version of the Arnoldi algorithm.
A LGORITHM 6.22 Block Arnoldi

1.
2.
3.
4.
5.
6.

Choose a unitary matrix V1 of dimension n × p.
For j = 1, 2, . . . , m Do:
Compute Hij = ViT AVj i = 1, 2, . . . , j
P
Compute Wj = AVj − ji=1 Vi Hij
Compute the Q-R factorization of Wj : Wj = Vj+1 Hj+1,j
EndDo

The above algorithm is a straightforward block analogue of Algorithm 6.1. By
construction, the blocks generated by the algorithm are orthogonal blocks that are
also orthogonal to each other. In the following we denote by Ik the k × k identity
matrix and use the following notation:
Um = [V1 , V2 , . . . , Vm ],
Hm = (Hij )1≤i,j≤m ,

Hij ≡ 0,

for

i > j + 1,

Em = matrix of the last p columns of Imp .
Then, the following analogue of the relation (6.6) is easily proved:
T
AUm = Um Hm + Vm+1 Hm+1,m Em
.

(6.129)

Here, the matrix Hm is no longer Hessenberg, but band-Hessenberg, meaning that it
has p subdiagonals instead of only one. Note that the dimension of the subspace in
which the solution is sought is not m but m.p.
A second version of the algorithm uses a modified block Gram-Schmidt procedure instead of the simple Gram-Schmidt procedure used above. This leads to a block
generalization of Algorithm 6.2, the Modified Gram-Schmidt version of Arnoldi’s
method.
A LGORITHM 6.23 Block Arnoldi with Block MGS

1.
2.
3.
4.
5.
6.
7.
8.
9.

Choose a unitary matrix V1 of size n × p
For j = 1, 2, . . . , m Do:
Compute Wj := AVj
For i = 1, 2, . . . , j do:
Hij := ViT Wj
Wj := Wj − Vi Hij
EndDo
Compute the Q-R decomposition Wj = Vj+1 Hj+1,j
EndDo

Again, in practice the above algorithm is more viable than its predecessor. Finally, a third version, developed by A. Ruhe [236] for the symmetric case (block

220

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Lanczos), yields a variant that is quite similar to the original Arnoldi algorithm. Assume that the initial block of p orthonormal vectors, v1 , . . . , vp is available. The first
step of the algorithm is to multiply v1 by A and orthonormalize the resulting vector
w against v1 , . . . , vp . The resulting vector is defined to be vp+1 . In the second step
it is v2 that is multiplied by A and orthonormalized against all available vi ’s. Thus,
the algorithm works similarly to Algorithm 6.2 except for a delay in the vector that
is multiplied by A at each step.
A LGORITHM 6.24 Block Arnoldi–Ruhe’s variant

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Choose p initial orthonormal vectors {vi }i=1,...,p .
For j = p, p + 1, . . . , m + p − 1 Do:
Set k := j − p + 1;
Compute w := Avk ;
For i = 1, 2, . . . , j Do:
hi,k := (w, vi )
w := w − hi,k vi
EndDo
Compute hj+1,k := kwk2 and vj+1 := w/hj+1,k .
EndDo

Observe that the particular case p = 1 coincides with the usual Arnoldi process.
Also, the dimension m of the subspace of approximants, is no longer restricted to
being a multiple of the block-size p as in the previous algorithms. The mathematical
equivalence of Algorithms 6.23 and 6.24 when m is a multiple of p is straightforward to show. The advantage of the above formulation is its simplicity. A slight
disadvantage is that it gives up some potential parallelism. In the original version,
the columns of the matrix AVj can be computed in parallel whereas in the new algorithm, they are computed in sequence. This can be remedied, however, by performing
p matrix-by-vector products every p steps.
At the end of the loop consisting of lines 5 through 8 of Algorithm 6.24, the
vector w satisfies the relation
w = Avk −

j
X

hik vi ,

i=1

where k and j are related by k = j − p + 1. Line 9 gives w = hj+1,k vj+1 which
results in
k+p
X
hik vi .
Avk =
i=1

As a consequence, the analogue of the relation (6.7) for Algorithm 6.24 is
AVm = Vm+p H̄m .

(6.130)

As before, for any j the matrix Vj represents the n×j matrix with columns v1 , . . . vj .
The matrix H̄m is now of size (m + p) × m.

6.12. BLOCK KRYLOV METHODS

221

Now the block generalizations of FOM and GMRES can be defined in a straightforward way. These block algorithms can solve linear systems with multiple righthand sides,
Ax(i) = b(i) , i = 1, · · · , p,
(6.131)
or, in matrix form
AX = B,

(6.132)

where the columns of the n × p matrices B and X are the b(i) ’s and x(i) ’s, respec(i)
tively. Given an initial block of initial guesses x0 for i = 1, . . . , p, we define R0 the
block of initial residuals
(1)

(2)

(p)

R0 ≡ [r0 , r0 , . . . , r0 ],
(i)

(i)

where each column is r0 = b(i) − Ax0 . It is preferable to use the unified notation
derived from Algorithm 6.24. In this notation, m is not restricted to being a multiple
of the block-size p and the same notation is used for the vi ’s as in the scalar Arnoldi
Algorithm. Thus, the first step of the block-FOM or block-GMRES algorithm is to
compute the QR factorization of the block of initial residuals:
R0 = [v1 , v2 , . . . , vp ] R.
Here, the matrix [v1 , . . . , vp ] is unitary and R is p × p upper triangular. This factorization provides the first p vectors of the block-Arnoldi basis.
Each of the approximate solutions has the form
(i)

x(i) = x0 + Vm y (i) ,

(6.133)

and, grouping these approximations x(i) in a block X and the y (i) in a block Y , we
can write
X = X0 + Vm Y.
(6.134)
It is now possible to imitate what was done for the standard FOM and GMRES
algorithms. The only missing link is the vector βe1 in (6.27) which now becomes a
matrix. Let E1 be the (m + p) × p matrix whose upper p × p principal block is an
identity matrix. Then, the relation (6.130) results in
B − AX = B − A (X0 + Vm Y )
= R0 − AVm Y

The vector

= [v1 , . . . , vp ]R − Vm+p H̄m Y

= Vm+p E1 R − H̄m Y .

(6.135)

ḡ (i) ≡ E1 Rei
is a vector of length m+p whose components are zero except those from 1 to i which
are extracted from the i-th column of the upper triangular matrix R. The matrix H̄m

222

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

is an (m + p) × m matrix. The block-FOM approximation would consist of deleting
the last p rows of ḡ(i) and H̄m and solving the resulting system,
Hm y (i) = g(i) .
The approximate solution x(i) is then computed by (6.133).
(i)
The block-GMRES approximation x(i) is the unique vector of the form x0 +
Vm y (i) which minimizes the 2-norm of the individual columns of the block-residual
(6.135). Since the column-vectors of Vm+p are orthonormal, then from (6.135) we
get,
kb(i) − Ax(i) k2 = kḡ(i) − H̄m y (i) k2 .
(6.136)
To minimize the residual norm, the function on the right hand-side must be minimized over y (i) . The resulting least-squares problem is similar to the one encountered for GMRES. The only differences are in the right-hand side and the fact that
the matrix is no longer Hessenberg, but band-Hessenberg. Rotations can be used in a
way similar to the scalar case. However, p rotations are now needed at each new step
instead of only one. Thus, if m = 6 and p = 2, the matrix H̄6 and block right-hand
side would be as follows:




h11 h12 h13 h14 h15 h16
g11 g12
 h21 h22 h23 h24 h25 h26 

g22 




 h31 h32 h33 h34 h35 h36 










h42 h43 h44 h45 h46 


.
H̄6 = 
Ḡ
=


h53 h54 h55 h56 








h
h
h
64
65
66








h75 h76
h86

For each new column generated in the block-Arnoldi process, p rotations are
required to eliminate the elements hk,j , for k = j + p down to k = j + 1. This
backward order is important. In the above example, a rotation is applied to eliminate
h3,1 and then a second rotation is used to eliminate the resulting h2,1 , and similarly
for the second, third step, etc. This complicates programming slightly since twodimensional arrays must now be used to save the rotations instead of one-dimensional
arrays in the scalar case. After the first column of H̄m is processed, the block of righthand sides will have a diagonal added under the diagonal of the upper triangular
matrix. Specifically, the above two matrices will have the structure,




⋆ ⋆ ⋆ ⋆ ⋆ ⋆
⋆ ⋆

⋆ ⋆
⋆ ⋆ ⋆ ⋆ ⋆







⋆ ⋆ ⋆ ⋆ ⋆
⋆






⋆ ⋆ ⋆ ⋆ ⋆



,
H̄6 = 
Ḡ = 


⋆
⋆
⋆
⋆








⋆ ⋆ ⋆






⋆ ⋆
⋆

6.12. BLOCK KRYLOV METHODS

223

where a ⋆ represents a nonzero element. After all columns are processed, the following least-squares system is obtained.




⋆ ⋆
⋆ ⋆ ⋆ ⋆ ⋆ ⋆
 ⋆ ⋆ 

⋆ ⋆ ⋆ ⋆ ⋆ 




 ⋆ ⋆ 


⋆
⋆
⋆
⋆




 ⋆ ⋆ 


⋆
⋆
⋆




Ḡ =  ⋆ ⋆  .
H̄6 = 
⋆ ⋆ 




 ⋆ ⋆ 

⋆ 








 ⋆ ⋆ 


⋆

To obtain the least-squares solutions for each right-hand side, ignore anything below
the horizontal lines in the above matrices and solve the resulting triangular systems.
The residual norm of the i-th system for the original problem is the 2-norm of the
vector consisting of the components m + 1, through m + i in the i-th column of the
above block of right-hand sides.
Generally speaking, the block methods are of great practical value in applications involving linear systems with multiple right-hand sides. However, they are
not as well studied from the theoretical point of view. Perhaps, one of the reasons
is the lack of a convincing analogue for the relationship with orthogonal polynomials, established in subsection 6.6.2 for the single-vector Lanczos algorithm. The
block version of the Lanczos algorithm has not been covered but the generalization
is straightforward.

P ROBLEMS
P-6.1 In the Householder implementation of the Arnoldi algorithm, show the following
points of detail:
a. Qj+1 is unitary and its inverse is QTj+1 .
b. QTj+1 = P1 P2 . . . Pj+1 .
c. QTj+1 ei = vi for i < j.
d. Qj+1 AVm = Vm+1 [e1 , e2 , . . . , ej+1 ]H̄m , where ei is the i-th column of the n × n
identity matrix.
e. The vi ’s are orthonormal.
f. The vectors v1 , . . . , vj are equal to the Arnoldi vectors produced by the Gram-Schmidt
version, except possibly for a scaling factor.
P-6.2 Rewrite the Householder implementation of the Arnoldi algorithm with more detail.
In particular, define precisely the Householder vector wj used at step j (lines 3-5).
P-6.3 Consider the Householder implementation of the Arnoldi algorithm. Give a detailed
operation count of the algorithm and compare it with the Gram-Schmidt and Modified GramSchmidt algorithm.

224

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

P-6.4 Consider a variant of the GMRES algorithm in which the Arnoldi process starts with
v1 = Av0 /kAv0 k2 where v0 ≡ r0 . The Arnoldi process is performed the same way as
before to build an orthonormal system v1 , v2 , . . . , vm−1 . Now the approximate solution is
expressed in the basis {v0 , v1 , . . . , vm−1 }.

a. Show that the least squares problem that must be solved to obtain the approximate
solution is now triangular instead of Hessemberg.

b. Show that the residual vector rk is orthogonal to v1 , v2 , . . . , vk−1 .
c. Find a formula which computes the residual norm (without computing the approximate
solution) and write the complete algorithm.
P-6.5 Derive the basic version of GMRES by using the standard formula (5.7) with V = Vm
and W = AVm .
P-6.6 Analyze the arithmic cost, i.e., the number of operations, of Algorithms 6.7 and 6.8.
Similarly analyse the memory requirement of both algorithms.
P-6.7 Derive a version of the DIOM algorithm which includes partial pivoting in the solution of the Hessenberg system.
P-6.8 Show how the GMRES and FOM methods will converge on the linear system Ax = b
when


 
1
1
1

0


 
A=
1
, b = 0


 
1
0
1
0

and with x0 = 0.

P-6.9 Give a full proof of Proposition 6.17.
P-6.10 Let a matrix A have the form
A=



I
0

Y
I



.

Assume that (full) GMRES is used to solve a linear system, with the coefficient matrix A.
What is the maximum number of steps that GMRES would require to converge?
P-6.11 Let a matrix A have the form:
A=



I
0

Y
S



.

Assume that (full) GMRES is used to solve a linear system with the coefficient matrix A. Let
 (1) 
r0
r0 =
(2)
r0
(2)

be the initial residual vector. It is assumed that the degree of the minimal polynomial of r0
with respect to S (i.e., its grade) is k. What is the maximum number
steps that GMRES
Pof
k
would require to converge for this matrix? [Hint: Evaluate the sum i=0 βi (Ai+1 − Ai )r0
P
(2)
where ki=0 βi ti is the minimal polynomial of r0 with respect to S.]

6.12. BLOCK KRYLOV METHODS
P-6.12 Let






A=




I

Y2
I

225

Y3
I

..






.


Y 

.

I

Yk−1
I

k

I

a. Show that (I − A)k = 0.

b. Assume that (full) GMRES is used to solve a linear system with the coefficient matrix
A. What is the maximum number of steps that GMRES would require to converge?
P-6.13 Show that if Hm is nonsingular, i.e., when the FOM iterate xF
m is defined, and if the
G
F
G
F
GMRES iterate xG
m is such that xm = xm , then rm = rm = 0, i.e., both the GMRES and
FOM solutions are exact. [Hint: use the relation (6.74) and Proposition 6.17 or Proposition
6.12.]
P-6.14 Derive the relation (6.63) from (6.75). [Hint: Use the fact that the vectors on the
right-hand side of (6.75) are orthogonal.]
P-6.15 In the Householder-GMRES algorithm the approximate solution can be computed
by formulas (6.31-6.33). What is the exact cost of this alternative (compare memory as well
as arithmetic requirements)? How does it compare with the cost of keeping the vi ’s?
P-6.16 An alternative to formulas (6.31-6.33) for accumulating the approximate solution in
the Householder-GMRES algorithm without keeping the vi ’s is to compute xm as
xm = x0 + P1 P2 . . . Pm y
where y is a certain n-dimensional vector to be determined. (1) What is the vector y for
the above formula in order to compute the correct approximate solution xm ? [Hint: Exploit
(6.13).] (2) Write down an alternative to formulas (6.31-6.33) derived from this approach.
(3) Compare the cost of this approach with the cost of using (6.31-6.33).
P-6.17 Obtain the formula (6.97) from (6.96).
P-6.18 Show that the determinant of the matrix Tm in (6.103) is given by
1
det (Tm ) = Qm−1
i=0

αi

.

P-6.19 The Lanczos algorithm is more closely related to the implementation of Algorithm
6.19 of the Conjugate Gradient algorithm. As a result the Lanczos coefficients δj+1 and ηj+1
are easier to extract from this algorithm than from Algorithm 6.18. Obtain formulas for these
coefficients from the coefficients generated by Algorithm 6.19, as was done in Section 6.7.3
for the standard CG algorithm.
P-6.20 What can be said of the Hessenberg matrix Hm when A is skew-symmetric? What
does this imply on the Arnoldi algorithm?
P-6.21 Consider a matrix of the form
A = I + αB
where B is skew-symmetric (real), i.e., such that B T = −B.
a. Show that (Ax, x)/(x, x) = 1 for all nonzero x.

(6.137)

226

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

b. Consider the Arnoldi process for A. Show that the resulting Hessenberg matrix will
have the following tridiagonal form


1 −η2
1
−η3

 η2


Hm = 
.
.
.
.


ηm−1 1 −ηm
ηm
1
c. Using the result of the previous question, explain why the CG algorithm applied as is
to a linear system with the matrix A, which is nonsymmetric, will still yield residual
vectors that are orthogonal to each other.
P-6.22 Establish the three relations (6.22), (6.23), and (6.24).
P-6.23 Show that if the rotations generated in the course of the GMRES (and DQGMRES)
algorithm are such that
|cm | ≥ c > 0,
then GMRES, DQGMRES, and FOM will all converge.
P-6.24 Show the exact expression of the residual vector in the basis v1 , v2 , . . . , vm+1 for
either GMRES or DQGMRES. [Hint: A starting point is (6.50).]
P-6.25 Prove that the inequality (6.54) is sharper than (6.51), in the sense that ζm+1 ≤
√
m − k + 1 (for m ≥ k). [Hint: Use Cauchy-Schwarz inequality on (6.54).]
P-6.26 Consider the minimal residual smoothing algorithm (Algorithm 7.5) in the situation
when the residual vectors rjO of the original sequence are orthogonal to each other. Show
that the vectors
S
S
rjO − rj−1
= −A(xO
j − xj−1 )
are orthogonal to each other [Hint: use induction]. Then use Lemma 6.21 to conclude that
the iterates of the algorithm are identical with those of ORTHOMIN and GMRES.
P-6.27 Consider the complex GMRES algorithm in Section 6.5.9. Show at least two other
ways of defining complex Givens rotations (the requirement is that Ωi be a unitary matrix,
i.e., that ΩH
i Ωi = I). Which among the three possible choices give (s) a nonnegative real
diagonal for the resulting Rm matrix?
P-6.28 Work out the details of a Householder implementation of the GMRES algorithm for
complex linear systems (The Householder matrices are now of the form I−2wwH ; part of the
practical implementation details is already available for the complex case in Section 6.5.9.)
P-6.29 Denote by Sm the unit upper triangular matrix S in the proof of Theorem 6.11
which is obtained from the Gram-Schmidt process (exact arithmetic assumed) applied to the
Q
incomplete orthogonalization basis Vm . Show that the Hessenberg matrix H̄m
obtained in
G
the incomplete orthogonalization process is related to the Hessenberg matrix H̄m
obtained
from the (complete) Arnoldi process by
−1
G
Q
H̄m
= Sm+1
H̄m
Sm .

N OTES AND R EFERENCES . The Conjugate Gradient method was developed independently and in
different forms by Lanczos [197] and Hestenes and Stiefel [167]. The method was essentially viewed
as a direct solution technique and was abandoned early on because it did not compare well with other
existing techniques. For example, in inexact arithmetic, the method does not terminate in n steps as

6.12. BLOCK KRYLOV METHODS

227

is predicted by the theory. This is caused by the severe loss of of orthogonality of vector quantities
generated by the algorithm. As a result, research on Krylov-type methods remained dormant for over
two decades thereafter. This changed in the early 1970s when several researchers discovered that this
loss of orthogonality did not prevent convergence. The observations were made and explained for
eigenvalue problems [222, 147] as well as linear systems [231]. The early to the middle 1980s saw
the development of a new class of methods for solving nonsymmetric linear systems [12, 13, 178, 238,
239, 251, 298]. The works of Faber and Manteuffel [121] and Voevodin [299] showed that one could
not find optimal methods which, like CG, are based on short-term recurrences. Many of the methods
developed are mathematically equivalent, in the sense that they realize the same projection process,
with different implementations.
Lemma 6.16 was proved by Roland Freund [134] in a slightly different form. Proposition 6.12 is
due to Brown [66] who proved a number of other theoretical results, including Proposition 6.17. The
inequality (6.64), which can be viewed as a reformulation of Brown’s result, was proved by Cullum
and Greenbaum [92]. This result is equivalent to Equation (6.67) which was shown in a very different
way by Zhou and Walker [324].
The Householder version of GMRES is due to Walker [303]. The Quasi-GMRES algorithm described in Section 6.5.6 was initially described by Brown and Hindmarsh [67], and the direct version
DQGMRES was discussed in [255]. The proof of Theorem 6.11 for DQGMRES is adapted from the
result shown in [213] for the QMR algorithm.
Schönauer [260] seems to have been the originator or Minimal Residual Smoothing methods,
but Weiss [307] established much of the theory and connections with other techniques. The Quasiminimization extension of these techniques (QMRS) was developed by Zhou and Walker [324].
The non-optimality of the Chebyshev polynomials on ellipses in the complex plane was established by Fischer and Freund [128]. Prior to this, a 1963 paper by Clayton [86] was believed to have
established the optimality for the special case where the ellipse has real foci and γ is real.
Various types of Block Krylov methods were considered. In addition to their attraction for solving
linear systems with several right-hand sides [243, 267], one of the other motivations for these techniques
is that they can also help reduce the effect of the sequential inner products in parallel environments
and minimize I/O costs in out-of-core implementations. A block Lanczos algorithm was developed
by Underwood [287] for the symmetric eigenvalue problem, while O’Leary discussed a block CG
algorithm [215]. The block-GMRES algorithm is analyzed by Simoncini and Gallopoulos [266] and in
[250]. Besides the straightforward extension presented in Section 6.12, a variation was developed by
Jbilou et al., in which a ‘global’ inner product for the blocks was considered instead of the usual scalar
inner product for each column [176].
Alternatives to GMRES which require fewer inner products have been proposed by Sadok [256]
and Jbilou [175]. Sadok investigated a GMRES-like method based on the Hessenberg algorithm [317],
while Jbilou proposed a multi-dimensional generalization of Gastinel’s method seen in Exercise 2 of
Chapter 5.

228

CHAPTER 6. KRYLOV SUBSPACE METHODS PART I

Chapter 7

KRYLOV SUBSPACE METHODS PART II

The previous chapter considered a number of Krylov subspace methods which relied on some
form of orthogonalization of the Krylov vectors in order to compute an approximate solution.
This chapter will describe a class of Krylov subspace methods which are instead based on a biorthogonalization algorithm due to Lanczos. These are projection methods that are intrinsically
non-orthogonal. They have some appealing properties, but are harder to analyze theoretically.

7.1

Lanczos Biorthogonalization

The Lanczos biorthogonalization algorithm is an extension to nonsymmetric matrices of the symmetric Lanczos algorithm seen in the previous chapter. One such
extension, the Arnoldi procedure, has already been seen. However, the nonsymmetric Lanczos algorithm is quite different in concept from Arnoldi’s method because it
relies on biorthogonal sequences instead of orthogonal sequences.

7.1.1

The Algorithm

The algorithm proposed by Lanczos for nonsymmetric matrices builds a pair of biorthogonal bases for the two subspaces
Km (A, v1 ) = span{v1 , Av1 , . . . , Am−1 v1 }
and
Km (AT , w1 ) = span{w1 , AT w1 , . . . , (AT )m−1 w1 }.
The algorithm that achieves this is the following.
A LGORITHM 7.1 The Lanczos Biorthogonalization Procedure

1.
2.
3.
4.
5.
6.

Choose two vectors v1 , w1 such that (v1 , w1 ) = 1.
Set β1 = δ1 ≡ 0, w0 = v0 ≡ 0
For j = 1, 2, . . . , m Do:
αj = (Avj , wj )
v̂j+1 = Avj − αj vj − βj vj−1
ŵj+1 = AT wj − αj wj − δj wj−1
229

230

7.
8.
9.
10.
11.

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II
δj+1 = |(v̂j+1 , ŵj+1 )|1/2 . If δj+1 = 0 Stop
βj+1 = (v̂j+1 , ŵj+1 )/δj+1
wj+1 = ŵj+1 /βj+1
vj+1 = v̂j+1 /δj+1
EndDo

Note that there are numerous ways to choose the scalars δj+1 , βj+1 in lines 7 and
8. These two parameters are scaling factors for the two vectors vj+1 and wj+1 and
can be selected in any manner to ensure that (vj+1 , wj+1 ) = 1. As a result of lines
9 and 10 of the algorithm, it is only necessary to choose two scalars βj+1 , δj+1 that
satisfy the equality
δj+1 βj+1 = (v̂j+1 , ŵj+1 ).
(7.1)
The choice taken in the above algorithm scales the two vectors so that they are divided by two scalars which have the same modulus. Both vectors can also be scaled
by their 2-norms. In that case, the inner product of vj+1 and wj+1 is no longer equal
to 1 and the algorithm must be modified accordingly; see Exercise 3.
Consider the case where the pair of scalars δj+1 , βj+1 is any pair that satisfies
the relation (7.1). Denote by Tm the tridiagonal matrix


α1 β2
 δ2 α2

β3



.
Tm = 
.
.
.
(7.2)


δm−1 αm−1 βm 
δm
αm

If the determinations of βj+1 , δj+1 of lines 7–8 are used, then the δj ’s are positive
and βj = ±δj .
Observe from the algorithm that the vectors vi belong to Km (A, v1 ), while the
wj ’s are in Km (AT , w1 ). In fact, the following proposition can be proved.
Proposition 7.1 If the algorithm does not break down before step m, then the vectors
vi , i = 1, . . . , m, and wj , j = 1, . . . , m, form a biorthogonal system, i.e.,
(vj , wi ) = δij

1 ≤ i, j ≤ m.

Moreover, {vi }i=1,2,...,m is a basis of Km (A, v1 ) and {wi }i=1,2,...,m is a basis of
Km (AT , w1 ) and the following relations hold,
AVm = Vm Tm + δm+1 vm+1 eTm ,
T

T
A Wm = Wm Tm
+ βm+1 wm+1 eTm ,
T
Wm
AVm = Tm .

(7.3)
(7.4)
(7.5)

Proof. The biorthogonality of the vectors vi , wi will be shown by induction. By
assumption (v1 , w1 ) = 1. Assume now that the vectors v1 , . . . vj and w1 , . . . wj

7.1. LANCZOS BIORTHOGONALIZATION

231

are biorthogonal, and let us prove that the vectors v1 , . . . vj+1 and w1 , . . . wj+1 are
biorthogonal.
First, we show that (vj+1 , wi ) = 0 for i ≤ j. When i = j, then
−1
(vj+1 , wj ) = δj+1
[(Avj , wj ) − αj (vj , wj ) − βj (vj−1 , wj )].

The last inner product in the above expression vanishes by the induction hypothesis. The two other terms cancel each other by the definition of αj and the fact that
(vj , wj ) = 1. Consider now the inner product (vj+1 , wi ) with i < j,
−1
(vj+1 , wi ) = δj+1
[(Avj , wi ) − αj (vj , wi ) − βj (vj−1 , wi )]
−1
= δj+1
[(vj , AT wi ) − βj (vj−1 , wi )]

−1
= δj+1
[(vj , βi+1 wi+1 + αi wi + δi wi−1 ) − βj (vj−1 , wi )].

For i < j − 1, all of the inner products in the above expression vanish, by the
induction hypothesis. For i = j − 1, the inner product is
−1
(vj+1 , wj−1 ) = δj+1
[(vj , βj wj + αj−1 wj−1 + δj−1 wj−2 ) − βj (vj−1 , wj−1 )]
−1
= δj+1
[βj (vj , wj ) − βj (vj−1 , wj−1 )]

= 0.

It can be proved in an identical way that (vi , wj+1 ) = 0 for i ≤ j. Finally, by
construction (vj+1 , wj+1 ) = 1. This completes the induction proof. The proof of
the matrix relations (7.3–7.5) is similar to that of the relations (6.6–6.8) in Arnoldi’s
method.
The relations (7.3–7.5) allow us to interpret the algorithm. The matrix Tm is
the projection of A obtained from an oblique projection process onto Km (A, v1 )
T represents the projection of AT
and orthogonally to Km (AT , w1 ). Similarly, Tm
T
on Km (A , w1 ) and orthogonally to Km (A, v1 ). Thus, an interesting new feature
here is that the operators A and AT play a dual role because similar operations are
performed with them. In fact, two linear systems are solved implicitly, one with A
and the other with AT . If there were two linear systems to solve, one with A and
the other with AT , then this algorithm is suitable. Otherwise, the operations with
AT are essentially wasted. Later a number of alternative techniques developed in the
literature will be introduced that avoid the use of AT .
From a practical point of view, the Lanczos algorithm has a significant advantage over Arnoldi’s method because it requires only a few vectors of storage, if no
reorthogonalization is performed. Specifically, six vectors of length n are needed,
plus some storage for the tridiagonal matrix, no matter how large m is.
On the other hand, there are potentially more opportunities for breakdown with
the nonsymmetric Lanczos method. The algorithm will break down whenever δj+1
as defined in line 7 vanishes. This is examined more carefully in the next section. In
practice, the difficulties are more likely to be caused by the near occurrence of this
phenomenon. A look at the algorithm indicates that the Lanczos vectors may have

232

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

to be scaled by small quantities when this happens. After a few steps the cumulated
effect of these scalings may introduce excessive rounding errors.
Since the subspace from which the approximations are taken is identical to that
of Arnoldi’s method, the same bounds for the distance k(I − Pm )uk2 are valid.
However, this does not mean in any way that the approximations obtained by the two
methods are likely to be similar in quality. The theoretical bounds shown in Chapter
5 indicate that the norm of the projector may play a significant role.

7.1.2

Practical Implementations

There are various ways to improve the standard nonsymmetric Lanczos algorithm
which we now discuss briefly. A major concern here is the potential breakdowns
or “near breakdowns” in the algorithm. There exist a number of approaches that
have been developed to avoid such breakdowns. Other approaches do not attempt to
eliminate the breakdown, but rather try to deal with it. The pros and cons of these
strategies will be discussed after the various existing scenarios are described.
Algorithm 7.1 will abort in line 7 whenever,
(v̂j+1 , ŵj+1 ) = 0.

(7.6)

This can arise in two different ways. Either one of the two vectors v̂j+1 or ŵj+1
vanishes, or they are both nonzero, but their inner product is zero. The first case is
the “lucky breakdown” scenario which has been seen for symmetric matrices. Thus,
if v̂j+1 = 0 then span{Vj } is invariant and, as was seen in Chapter 5, the approximate
solution is exact. If ŵj+1 = 0 then span{Wj } is invariant. However, in this situation
nothing can be said about the approximate solution for the linear system with A. If
the algorithm is being used to solve a pair of linear systems, one with A and a dual
system with AT , then the approximate solution for the dual system will be exact
in this case. The second scenario in which (7.6) can occur is when neither of the
two vectors is zero, but their inner product is zero. Wilkinson (see [317], p. 389)
called this a serious breakdown. Fortunately, there are cures for this problem which
allow the algorithm to continue in most cases. The corresponding modifications of
the algorithm are often put under the denomination Look-Ahead Lanczos algorithms.
There are also rare cases of incurable breakdowns which will not be discussed here
(see references [225] and [284]).
The main idea of Look-Ahead variants of the Lanczos algorithm is that the pair
vj+2 , wj+2 can often be defined even though the pair vj+1 , wj+1 is not defined. The
algorithm can be pursued from that iterate as before until a new breakdown is encountered. If the pair vj+2 , wj+2 cannot be defined then the pair vj+3 , wj+3 can be
tried, and so on. To better explain the idea, it is best to refer to the connection with orthogonal polynomials mentioned earlier for the symmetric case. The relationship can
be extended to the nonsymmetric case by defining the bilinear form on the subspace
Pm−1
< p, q >= (p(A)v1 , q(AT )w1 ).
(7.7)

7.1. LANCZOS BIORTHOGONALIZATION

233

Unfortunately, this is now an “indefinite inner product” in general since < p, p >
can be zero or even negative. Note that there is a polynomial pj of degree j such that
v̂j+1 = pj (A)v1 and, in fact, the same polynomial intervenes in the equivalent expression of wj+1 . More precisely, there is a scalar γj such that ŵj+1 = γj pj (AT )v1 .
Similar to the symmetric case, the nonsymmetric Lanczos algorithm attempts to compute a sequence of polynomials that are orthogonal with respect to the indefinite inner
product defined above. If we define the moment matrix
Mk = {< xi−1 , xj−1 >}i,j=1,...,k
then this process is mathematically equivalent to the computation of the factorization
Mk = Lk Uk
of the moment matrix Mk , in which Uk is upper triangular and Lk is lower triangular.
Note that Mk is a Hankel matrix, i.e., its coefficients mij are constant along antidiagonals, i.e., for i + j = constant.
Because
< pj , pj >= γj (pj (A)v1 , pj (AT )w1 ),
we observe that there is a serious breakdown at step j if and only if the indefinite
norm of the polynomial pj at step j vanishes. If this polynomial is skipped, it may
still be possible to compute pj+1 and continue to generate the sequence. To explain
this simply, consider
qj (t) = xpj−1 (t)

and

qj+1 (t) = x2 pj−1 (t).

Both qj and qj+1 are orthogonal to the polynomials p1 , . . . , pj−2 . We can define
(somewhat arbitrarily) pj = qj , and then pj+1 can be obtained by orthogonalizing
qj+1 against pj−1 and pj . It is clear that the resulting polynomial will then be orthogonal against all polynomials of degree ≤ j; see Exercise 5. Therefore, the algorithm
can be continued from step j + 1 in the same manner. Exercise 5 generalizes this for
the case where k polynomials are skipped rather than just one. This is a simplified
description of the mechanism which underlies the various versions of Look-Ahead
Lanczos algorithms proposed in the literature. The Parlett-Taylor-Liu implementation [225] is based on the observation that the algorithm breaks because the pivots
encountered during the LU factorization of the moment matrix Mk vanish. Then,
divisions by zero are avoided by performing implicitly a pivot with a 2 × 2 matrix
rather than using a standard 1 × 1 pivot.
The drawback of Look-Ahead implementations is the nonnegligible added complexity. Besides the difficulty of identifying these near breakdown situations, the
matrix Tm ceases to be tridiagonal. Indeed, whenever a step is skipped, elements
are introduced above the superdiagonal positions, in some subsequent step. In the
context of linear systems, near breakdowns are rare and their effect generally benign.
Therefore, a simpler remedy, such as restarting the Lanczos procedure, may well be
adequate. For eigenvalue problems, Look-Ahead strategies may be more justified.

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

234

7.2

The Lanczos Algorithm for Linear Systems

We present in this section a brief description of the Lanczos method for solving
nonsymmetric linear systems. Consider the (single) linear system:
Ax = b

(7.8)

where A is n × n and nonsymmetric. Suppose that a guess x0 to the solution is
available and let its residual vector be r0 = b − Ax0 . Then the Lanczos algorithm
for solving (7.8) can be described as follows.
A LGORITHM 7.2 Two-sided Lanczos Algorithm for Linear Systems

1.
2.
3.
4.
5.
6.

Compute r0 = b − Ax0 and β := kr0 k2
Run m steps of the nonsymmetric Lanczos Algorithm, i.e.,
Start with v1 := r0 /β , and any w1 such that (v1 , w1 ) = 1
Generate the Lanczos vectors v1 , . . . , vm , w1 , . . . , wm
and the tridiagonal matrix Tm from Algorithm 7.1.
−1 (βe ) and x := x + V y .
Compute ym = Tm
1
m
0
m m

Note that it is possible to incorporate a convergence test when generating the
Lanczos vectors in the second step without computing the approximate solution explicitly. This is due to the following formula, which is similar to Equation (6.87) for
the symmetric case,
kb − Axj k2 = |δj+1 eTj yj | kvj+1 k2 ,

(7.9)

and which can be proved in the same way, by using (7.3). This formula gives us the
residual norm inexpensively without generating the approximate solution itself.

7.3

The BCG and QMR Algorithms

The Biconjugate Gradient (BCG) algorithm can be derived from Algorithm 7.1 in exactly the same way as the Conjugate Gradient method was derived from Algorithm
6.15. The algorithm was first proposed by Lanczos [197] in 1952 and then in a different form (Conjugate Gradient-like version) by Fletcher [130] in 1974. Implicitly, the
algorithm solves not only the original system Ax = b but also a dual linear system
AT x∗ = b∗ with AT . This dual system is often ignored in the formulations of the
algorithm.

7.3.1

The Biconjugate Gradient Algorithm

The Biconjugate Gradient (BCG) algorithm is a projection process onto
Km = span{v1 , Av1 , · · · , Am−1 v1 }
orthogonally to
Lm = span{w1 , AT w1 , · · · , (AT )m−1 w1 }

7.3. THE BCG AND QMR ALGORITHMS

235

taking, as usual, v1 = r0 /kr0 k2 . The vector w1 is arbitrary, provided (v1 , w1 ) 6= 0,
but it is often chosen to be equal to v1 . If there is a dual system AT x∗ = b∗ to solve
with AT , then w1 is obtained by scaling the initial residual b∗ − AT x∗0 .
Proceeding in the same manner as for the derivation of the Conjugate Gradient
algorithm from the symmetric Lanczos algorithm, we write the LDU decomposition
of Tm as
Tm = Lm Um
(7.10)
and define
−1
Pm = Vm Um
.

(7.11)

The solution is then expressed as
−1
xm = x0 + Vm Tm
(βe1 )
−1 −1
Lm (βe1 )
= x0 + Vm Um

= x0 + Pm L−1
m (βe1 ).
Notice that the solution xm is updatable from xm−1 in a similar way to the Conjugate
Gradient algorithm. Like the Conjugate Gradient algorithm, the vectors rj and rj∗ are
in the same direction as vj+1 and wj+1 , respectively. Hence, they form a biorthogonal sequence. Define similarly the matrix
∗
Pm
= Wm L−T
m .

(7.12)

∗ and those p of P are A-conjugate, since,
Clearly, the column-vectors p∗i of Pm
i
m
∗ T
T
−1
−1
−1
(Pm
) APm = L−1
m Wm AVm Um = Lm Tm Um = I.

Utilizing this information, a Conjugate Gradient–like algorithm can be easily derived
from the Lanczos procedure.
A LGORITHM 7.3 Biconjugate Gradient (BCG)

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

Compute r0 := b − Ax0 . Choose r0∗ such that (r0 , r0∗ ) 6= 0.
Set, p0 := r0 , p∗0 := r0∗
For j = 0, 1, . . . , until convergence Do:
αj := (rj , rj∗ )/(Apj , p∗j )
xj+1 := xj + αj pj
rj+1 := rj − αj Apj
∗
rj+1
:= rj∗ − αj AT p∗j
∗ )/(r , r ∗ )
βj := (rj+1 , rj+1
j j
pj+1 := rj+1 + βj pj
∗
p∗j+1 := rj+1
+ βj p∗j
EndDo

If a dual system with AT is being solved, then in line 1 r0∗ should be defined as
r0∗ = b∗ − AT x∗0 and the update x∗j+1 := x∗j + αj p∗j to the dual approximate solution
must beinserted after line 5. The vectors produced by this algorithm satisfy a few
biorthogonality properties stated in the following proposition.

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

236

Proposition 7.2 The vectors produced by the Biconjugate Gradient algorithm satisfy
the following orthogonality properties:
(rj , ri∗ ) = 0,
(Apj , p∗i )

= 0,

for i 6= j,

(7.13)

for i 6= j.

(7.14)

Proof. The proof is either by induction or by simply exploiting the relations between
∗.
the vectors rj , rj∗ , pj , p∗j , and the vector columns of the matrices Vm , Wm , Pm , Pm
This is left as an exercise.
Example 7.1. Table 7.1 shows the results of applying the BCG algorithm with no
preconditioning to three of the test problems described in Section 3.7. See Example 6.1 for the meaning of the column headers in the table. Recall that Iters really
represents the number of matrix-by-vector multiplications rather the number of Biconjugate Gradient steps.
Matrix

Iters

Kflops

Residual

Error

F2DA

163

2974

0.17E-03

0.86E-04

F3D

123

10768

0.34E-04

0.17E-03

ORS

301

6622

0.50E-01

0.37E-02

Table 7.1: A test run of BCG without preconditioning.
Thus, the number 163 in the first line represents 81 steps of BCG, which require
81 × 2 matrix-by-vector products in the iteration, and an extra one to compute the
initial residual.

7.3.2

Quasi-Minimal Residual Algorithm

The result of the Lanczos algorithm is a relation of the form
AVm = Vm+1 T̄m

(7.15)

in which T̄m is the (m + 1) × m tridiagonal matrix


Tm
T̄m =
.
δm+1 eTm
Now (7.15) can be exploited in the same way as was done to develop GMRES. If v1
is defined as a multiple of r0 , i.e., if v1 = βr0 , then the residual vector associated
with an approximate solution of the form
x = x0 + Vm y

7.3. THE BCG AND QMR ALGORITHMS

237

is given by
b − Ax = b − A (x0 + Vm y)
= r0 − AVm y

= βv1 − Vm+1 T̄m y


= Vm+1 βe1 − T̄m y .

(7.16)


kb − Axk = kVm+1 βe1 − T̄m y k2 .

(7.17)

The norm of the residual vector is therefore

If the column-vectors of Vm+1 were orthonormal, then we would have kb − Axk =
kβe1 − T̄m yk2 , as in GMRES. Therefore, a least-squares solution could be obtained
from the Krylov subspace by minimizing kβe1 − T̄m yk2 over y. In the Lanczos
algorithm, the vi ’s are not orthonormal. However, it is still a reasonable idea to
minimize the function
J(y) ≡ kβe1 − T̄m yk2
over y and compute the corresponding approximate solution x0 +Vm y. The resulting
solution is called the Quasi-Minimal Residual approximation. The norm kJ(y)k2 is
called the quasi-residual norm for the approximation x0 + Vm y.
Thus, the Quasi-Minimal Residual (QMR) approximation from the m-th Krylov
subspace is obtained as xm = x0 + Vm ym , which minimizes the quasi residual norm
J(y) = kβe1 − T̄m yk2 , i.e., just as in GMRES, except that the Arnoldi process is
replaced by the Lanczos process. Because of the structure of the matrix T̄m , it is easy
to adapt the DQGMRES algorithm (Algorithm 6.13), and obtain an efficient version
of the QMR method. The algorithm is presented next.
A LGORITHM 7.4 QMR

11.

Compute r0 = b − Ax0 and γ1 := kr0 k2 , w1 := v1 := r0 /γ1
For m = 1, 2, . . . , until convergence Do:
Compute αm , δm+1 and vm+1 , wm+1 as in Algorithm 7.1
Update the QR factorization of T̄m , i.e.,
Apply Ωi , i = m − 2, m − 1 to the m-th column of T̄m
Compute the rotation coefficients cm , sm by (6.37)
Apply rotation Ωm , to last column of T̄m and to ḡm , i.e., compute:
γm+1 := −sm γm ,
γm := cm γm , and,

 q

12.
13.
14.

xm = xm−1 + γm pm
If |γm+1 | is small enough then Stop
EndDo

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

2
αm := cm αm + sm δm+1 = δm+1
+ α2m


P
pm = vm − m−1
i=m−2 tim pi /tmm

238

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

It is clear that the matrix Tm is not actually saved. Only the two most recent rotations
need to be saved. For the remainder of this subsection, it is assumed (without loss of
generality) that the vi ’s are normalized to have unit two norms. Then, the situation is
similar with that of DQGMRES, in that the “quasi-residual” norm defined by
ρQ
m = kβe1 − T̄m ym k2 ≡ minm kβe1 − T̄m yk2
y∈R

is usually a fairly good estimate of the actual residual norm. Following the same
arguments as in Section 6.5.3 in Chapter 6, it is easily seen that
Q
ρQ
m = |s1 s2 . . . sm | kr0 k2 = |sm |ρm−1

(7.18)

If the same notation as in Sections 6.5.3 and 6.5.7 is employed, then the actual residual rm = b − Axm obtained at the m-th step of BCG satisfies
rm = −hm+1,m eTm ym vm+1 = −hm+1,m

γm
hm+1,m
v
=
γ
v
.
(m−1) m+1
(m−1) m+1 m+1
hmm
sm hmm

For convenience, we have kept the notation hij used in Chapter 6, for the entries of
the matrix T̂m . The next relation is then obtained by noticing, as in Section 6.5.7,
(m)
that hm+1,m /hmm = tan θm
γm+1 vm+1 = cm rm ,

(7.19)

ρQ
m = |cm | ρm ,

(7.20)

from which it follows that
where ρm = krm k2 is the actual residual norm of the m-th BCG iterate.
The following proposition, which is similar to Proposition 6.9, establishes a result on the actual residual norm of the solution.
Proposition 7.3 The residual norm of the approximate solution xm satisfies the relation
kb − Axm k ≤ kVm+1 k2 |s1 s2 . . . sm | kr0 k2 .
(7.21)
Proof. According to (7.16) the residual norm is given by
b − Axm = Vm+1 [βe1 − T̄m ym ]

(7.22)

and using the same notation as in Proposition 6.9, referring to (6.43)
kβe1 − H̄m yk22 = |γm+1 |2 + kgm − Rm yk22
in which gm − Rm y = 0 by the minimization procedure. In addition, by (6.47) we
have
γm+1 = (−1)m s1 . . . sm γ1 , γ1 = β.
The result follows immediately using (7.22).

7.3. THE BCG AND QMR ALGORITHMS

239

A simple upper bound for kVm+1 k2 can be derived from the Cauchy Schwarz inequality:
√
kVm+1 k2 ≤ m + 1.
A comparison theorem which is similar to that of Theorem 6.11 can also be stated
for QMR.
Theorem 7.4 Assume that the Lanczos algorithm does not break down on or before
Q
G
step m and let Vm+1 be the Lanczos basis obtained at step m. Let rm
and rm
be the residual norms obtained after m steps of the QMR and GMRES algorithms,
respectively. Then,
Q
G
krm
k2 ≤ κ2 (Vm+1 )krm
k2 .
The proof of this theorem is essentially identical with that of Theorem 6.11. Note
that Vm+1 is now known to be of full rank, so we need not make this assumption as
in Theorem 6.11.
It is not easy to analyze the QMR algorithm in terms of the exact residual norms,
but the quasi residual norms yield interesting properties. For example, an expression
similar to (6.65) relates the actual BCG residual norm ρj with the “quasi-residual”
norm ρQ
j obtained by QMR:
1
1
1
2 +
 2 = 
2 .
Q
Q
(ρ
)
j
ρj
ρj−1

(7.23)

The proof of this result is identical with that of (6.65): it is an immediate consequence
of (7.18) and (7.20). An argument similar to the one used to derive (6.67) leads to a
similar conclusion:
1
(7.24)
ρQ
m = qP
m
2
(1/ρ
)
i
i=0

The above equality underlines the smoothing property of the QMR algorithm since
it shows that the quasi residual norm is akin to an (harmonic) average of the BCG
residual norms.
It is clear from (7.20) that ρQ
m ≤ ρm . An argument similar to that used to derive
Proposition 6.15 can be be made. If ρm∗ is the smallest residual norms achieved
among those of the first m steps of BCG, then,
1


ρQ
m

2 =

m
X

1
m+1
.
2 ≤
(ρi )
(ρm∗ )2
i=0

This proves the following result.

Proposition 7.5 Assume that m steps of QMR and BCG are taken and let ρm∗ be
the smallest residual norm achieved by BCG in the first m steps. Then, the following
inequalities hold:
√
m + 1 ρQ
(7.25)
ρQ
m
m ≤ ρm∗ ≤

240

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

The above results deal with quasi residuals instead of the actual residuals. However,
it is possible to proceed as for DQGMRES, see Equation (6.50) and (6.53), to express
the actual residual as
b − AxQ
(7.26)
m = γm+1 zm+1

where, as before, γm+1 is the last component of the right-hand side βe1 after the
m Givens rotations have been applied to it. Therefore γm+1 satisfies the recurrence
(6.47) starting with γ1 = β. The vector zm+1 can be updated by the same relation,
namely
zm+1 = −sm zm + cm vm+1 .
(7.27)

The sequence zm+1 can be updated and the norm of zm+1 computed to yield the
exact residual norm, but this entails nonnegligible additional operations (5n in total)
and the compromise based on updating an upper bound seen for DQGMRES can be
used here as well.
Q
It is interesting to explore (7.27) further. Denote by rm
the actual residual vector
Q
b − Axm obtained from QMR. Then from (7.26), (7.27), and (6.47), it follows that
Q
Q
+ cm γm+1 vm+1
rm
= s2m rm−1

(7.28)

When combined with (7.19), the above equality leads to the following relation beQ
tween the actual residuals rm
produced at the m-th step of QMR and the residuals
rm obtained from BCG,
Q
Q
rm
= s2m rm−1
+ c2m rm
(7.29)
from which follows the same relation on the iterates:
2 Q
2
xQ
m = sm xm−1 + cm xm .

(7.30)

When sm is close to zero, which corresponds to fast convergence of BCG, then QMR
will be close to the BCG iterate. On the other hand when sm is close to one, then
QMR will tend to make little progress – just as was shown by Brown [66] for the
FOM/GMRES pair. A more pictural way of stating this is that peaks of the BCG
residual norms will correspond to plateaus of the QMR quasi-residuals. The above
relations can be rewritten as follows:
Q
Q
2
xQ
m = xm−1 + cm (xm − xm−1 )

Q
Q
Q
rm
= rm−1
+ c2m (rm − rm−1
)

(7.31)

Schemes of the above general form, where now c2m can be considered a parameter, are
known as residual smoothing methods, and were also considered in Chapter 6. The
minimal residual smoothing seen in Chapter 6, is now replaced by a quasi-minimal
residual smoothing. Indeed, what the above relation shows is that it is possible to
implement QMR as a quasi-minimal residual smoothing algorithm. The only missing ingredient for completing the description of the algorithm is an expression of
the smoothing parameter c2m in terms of quantities that do not refer to the Givens
rotatioms. This expression can be derived from (7.20) which relates the cosine cj
with the ratio of the quasi-residual norm and the actual residual norm of BCG and
from (7.23) which allows to compute ρQ
j recursively. The quasi-minimal residual
smoothing algorithm, developed by Zhou and Walker [324], can now be sketched.

7.4. TRANSPOSE-FREE VARIANTS

241

A LGORITHM 7.5 Quasi Minimal Residual Smoothing

1.
2.
3.
4.
5.
6.

7.4

Q
Set r0 = b − Ax0 , xQ
0 = x0 ; Set ρ0 = ρ0 = kr0 k2
For j = 1, 2, . . . , Do:
Compute xj , and the associated residual rj , and residual norm ρj
2

Q
Compute ρQ
j from (7.23) and set ηj = ρj /ρj
Q
Q
Compute xQ
j = xj−1 + ηj (xj − xj−1 )
EndDo

Transpose-Free Variants

Each step of the Biconjugate Gradient algorithm and QMR requires a matrix-byvector product with both A and AT . However, observe that the vectors p∗i or wj
generated with AT do not contribute directly to the solution. Instead, they are used
only to obtain the scalars needed in the algorithm, e.g., the scalars αj and βj for
BCG.
The question arises as to whether or not it is possible to bypass the use of the
transpose of A and still generate iterates that are related to those of the BCG algorithm. One of the motivations for this question is that, in some applications, A is
available only through some approximations and not explicitly. In such situations,
the transpose of A is usually not available. A simple example is when a CG-like
algorithm is used in the context of Newton’s iteration for solving F (u) = 0.
The linear system that arises at each Newton step can be solved without having to compute the Jacobian J(uk ) at the current iterate uk explicitly, by using the
difference formula
F (uk + ǫv) − F (uk )
.
J(uk )v =
ǫ
This allows the action of this Jacobian to be computed on an arbitrary vector v. Unfortunately, there is no similar formula for performing operations with the transpose
of J(uk ).

7.4.1

Conjugate Gradient Squared

The Conjugate Gradient Squared algorithm was developed by Sonneveld in 1984
[272], mainly to avoid using the transpose of A in the BCG and to gain faster convergence for roughly the same computational cost. The main idea is based on the
following simple observation. In the BCG algorithm, the residual vector at step j
can be expressed as
rj = φj (A)r0
(7.32)
where φj is a certain polynomial of degree j satisfying the constraint φj (0) = 1.
Similarly, the conjugate-direction polynomial πj (t) is given by
pj = πj (A)r0 ,

(7.33)

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

242

in which πj is a polynomial of degree j. From the algorithm, observe that the directions rj∗ and p∗j are defined through the same recurrences as rj and pj in which A is
replaced by AT and, as a result,
rj∗ = φj (AT )r0∗ ,

p∗j = πj (AT )r0∗ .

Also, note that the scalar αj in BCG is given by
αj =

(φ2j (A)r0 , r0∗ )
(φj (A)r0 , φj (AT )r0∗ )
=
(Aπj (A)r0 , πj (AT )r0∗ )
(Aπj2 (A)r0 , r0∗ )

which indicates that if it is possible to get a recursion for the vectors φ2j (A)r0 and
πj2 (A)r0 , then computing αj and, similarly, βj causes no problem. Hence, the idea of
seeking an algorithm which would give a sequence of iterates whose residual norms
rj′ satisfy
rj′ = φ2j (A)r0 .
(7.34)
The derivation of the method relies on simple algebra only. To establish the
desired recurrences for the squared polynomials, start with the recurrences that define
φj and πj , which are,
φj+1 (t) = φj (t) − αj tπj (t),

πj+1 (t) = φj+1 (t) + βj πj (t).

(7.35)
(7.36)

If the above relations are squared we get
φ2j+1 (t) = φ2j (t) − 2αj tπj (t)φj (t) + α2j t2 πj2 (t),

2
πj+1
(t) = φ2j+1 (t) + 2βj φj+1 (t)πj (t) + βj2 πj (t)2 .

If it were not for the cross terms πj (t)φj (t) and φj+1 (t)πj (t) on the right-hand sides,
these equations would form an updatable recurrence system. The solution is to introduce one of these two cross terms, namely, φj+1 (t)πj (t), as a third member of the
recurrence. For the other term, i.e., πj (t)φj (t), we can exploit the relation
φj (t)πj (t) = φj (t) (φj (t) + βj−1 πj−1 (t)) = φ2j (t) + βj−1 φj (t)πj−1 (t).
By putting these relations together the following recurrences can be derived, in which
the variable (t) is omitted where there is no ambiguity:

φ2j+1 = φ2j − αj t 2φ2j + 2βj−1 φj πj−1 − αj t πj2
(7.37)
φj+1 πj = φ2j + βj−1 φj πj−1 − αj t πj2
2
πj+1

=

φ2j+1 + 2βj φj+1 πj + βj2 πj2 .

(7.38)

(7.39)

These recurrences are at the basis of the algorithm. If we define
rj = φ2j (A)r0 ,

(7.40)

πj2 (A)r0 ,

(7.41)

qj = φj+1 (A)πj (A)r0 ,

(7.42)

pj =

7.4. TRANSPOSE-FREE VARIANTS

243

then the above recurrences for the polynomials translate into
rj+1 = rj − αj A (2rj + 2βj−1 qj−1 − αj A pj ) ,
qj = rj + βj−1 qj−1 − αj A pj ,
rj+1 + 2βj qj + βj2 pj .

pj+1 =

(7.43)
(7.44)
(7.45)

It is convenient to define the auxiliary vector
dj = 2rj + 2βj−1 qj−1 − αj Apj .
With this we obtain the following sequence of operations to compute the approximate
solution, starting with r0 := b − Ax0 , p0 := r0 , q0 := 0, β0 := 0.
• αj = (rj , r0∗ )/(Apj , r0∗ )

• dj = 2rj + 2βj−1 qj−1 − αj Apj
• qj = rj + βj−1 qj−1 − αj Apj
• xj+1 = xj + αj dj
• rj+1 = rj − αj Adj
• βj = (rj+1 , r0∗ )/(rj , r0∗ )
• pj+1 = rj+1 + βj (2qj + βj pj ).
A slight simplification to the algorithm can be made by using the auxiliary vector
uj = rj + βj−1 qj−1 . This definition leads to the relations
dj

= uj + qj ,

qj = uj − αj Apj ,

pj+1 = uj+1 + βj (qj + βj pj ),
and as a result the vector dj is no longer needed. The resulting algorithm is given
below.
A LGORITHM 7.6 Conjugate Gradient Squared

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

Compute r0 := b − Ax0 ; r0∗ arbitrary.
Set p0 := u0 := r0 .
For j = 0, 1, 2 . . . , until convergence Do:
αj = (rj , r0∗ )/(Apj , r0∗ )
qj = uj − αj Apj
xj+1 = xj + αj (uj + qj )
rj+1 = rj − αj A(uj + qj )
βj = (rj+1 , r0∗ )/(rj , r0∗ )
uj+1 = rj+1 + βj qj
pj+1 = uj+1 + βj (qj + βj pj )
EndDo

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

244

Observe that there are no matrix-by-vector products with the transpose of A. Instead,
two matrix-by-vector products with the matrix A are now performed at each step. In
general, one should expect the resulting algorithm to converge twice as fast as BCG.
Therefore, what has essentially been accomplished is to replace the matrix-by-vector
products with AT by more useful work.
The Conjugate Gradient Squared algorithm works quite well in many cases.
However, one difficulty is that, since the polynomials are squared, rounding errors
tend to be more damaging than in the standard BCG algorithm. In particular, very
high variations of the residual vectors often cause the residual norms computed from
the result of line 7 of the above algorithm to become inaccurate.

7.4.2

BICGSTAB

The CGS algorithm is based on squaring the residual polynomial, and, in cases of
irregular convergence, this may lead to substantial build-up of rounding errors, or
possibly even overflow. The Biconjugate Gradient Stabilized (BICGSTAB) algorithm is a variation of CGS which was developed to remedy this difficulty. Instead of
seeking a method which delivers a residual vector of the form rj′ defined by (7.34),
BICGSTAB produces iterates whose residual vectors are of the form
rj′ = ψj (A)φj (A)r0 ,

(7.46)

in which, as before, φj (t) is the residual polynomial associated with the BCG algorithm and ψj (t) is a new polynomial which is defined recursively at each step with
the goal of “stabilizing” or “smoothing” the convergence behavior of the original
algorithm. Specifically, ψj (t) is defined by the simple recurrence,
ψj+1 (t) = (1 − ωj t)ψj (t)

(7.47)

in which the scalar ωj is to be determined. The derivation of the appropriate recurrence relations is similar to that of CGS. Ignoring the scalar coefficients at first, we
start with a relation for the residual polynomial ψj+1 φj+1 . We immediately obtain
ψj+1 φj+1 = (1 − ωj t)ψj (t)φj+1

= (1 − ωj t) (ψj φj − αj tψj πj )

(7.48)
(7.49)

which is updatable provided a recurrence relation is found for the products ψj πj . For
this, write
ψj πj = ψj (φj + βj−1 πj−1 )
= ψj φj + βj−1 (1 − ωj−1 t)ψj−1 πj−1 .
Define,
rj = ψj (A)φj (A)r0 ,
pj = ψj (A)πj (A)r0 .

(7.50)
(7.51)

7.4. TRANSPOSE-FREE VARIANTS

245

According to the above formulas, these vectors can be updated from a double recurrence provided the scalars αj and βj were computable. This recurrence is
rj+1 = (I − ωj A)(rj − αj Apj )

(7.52)

pj+1 = rj+1 + βj (I − ωj A)pj .

Consider now the computation of the scalars needed in the recurrence. According to the original BCG algorithm, βj = ρj+1 /ρj with
ρj = (φj (A)r0 , φj (AT )r0∗ ) = (φj (A)2 r0 , r0∗ )
Unfortunately, ρj is not computable from these formulas because none of the vectors
φj (A)r0 , φj (AT )r0∗ or φj (A)2 r0 is available. However, ρj can be related to the scalar
ρ̃j = (φj (A)r0 , ψj (AT )r0∗ )
which is computable via
ρ̃j = (φj (A)r0 , ψj (AT )r0∗ ) = (ψj (A)φj (A)r0 , r0∗ ) = (rj , r0∗ ).
To relate the two scalars ρj and ρ̃j , expand ψj (AT )r0∗ explicitly in the power basis,
to obtain


(j)
(j)
ρ̃j = φj (A)r0 , η1 (AT )j r0∗ + η2 (AT )j−1 r0∗ + . . . .

Since φj (A)r0 is orthogonal to all vectors (AT )k r0∗ , with k < j, only the leading
power is relevant in the expansion on the right side of the above inner product. In
(j)
particular, if γ1 is the leading coefficient for the polynomial φj (t), then
!
(j)
(j)
η1
η1
T
ρ̃j = φj (A)r0 , (j) φj (A )r0 = (j) ρj .
γ1
γ1

When examining the recurrence relations for φj+1 and ψj+1 , leading coefficients for
these polynomials are found to satisfy the relations
(j+1)

η1

(j)

= −ωj η1 ,

and as a result

(j+1)

γ1

(j)

= −αj γ1 ,

ρ̃j+1
ωj ρj+1
=
ρ̃j
αj ρj

which yields the following relation for βj :
βj =

ρ̃j+1
αj
×
.
ρ̃j
ωj

Similarly, a simple recurrence formula for αj can be derived. By definition,
αj =

(φj (A)r0 , φj (AT )r0∗ )
(Aπj (A)r0 , πj (AT )r0∗ )

(7.53)

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

246

and as in the previous case, the polynomials in the right sides of the inner products
in both the numerator and denominator can be replaced by their leading terms. However, in this case the leading coefficients for φj (AT )r0∗ and πj (AT )r0∗ are identical,
and therefore,
αj =
=
=

(φj (A)r0 , φj (AT )r0∗ )
(Aπj (A)r0 , φj (AT )r0∗ )
(φj (A)r0 , ψj (AT )r0∗ )
(Aπj (A)r0 , ψj (AT )r0∗ )
(ψj (A)φj (A)r0 , r0∗ )
.
(Aψj (A)πj (A)r0 , r0∗ )

Since pj = ψj (A)πj (A)r0 , this yields,
αj =

ρ̃j
.
(Apj , r0∗ )

(7.54)

Next, the parameter ωj must be defined. This can be thought of as an additional
free parameter. One of the simplest choices, and perhaps the most natural, is to
select ωj to achieve a steepest descent step in the residual direction obtained before
multiplying the residual vector by (I − ωj A) in (7.52). In other words, ωj is chosen
to minimize the 2-norm of the vector (I − ωj A)ψj (A)φj+1 (A)r0 . Equation (7.52)
can be rewritten as
rj+1 = (I − ωj A)sj
in which
sj ≡ rj − αj Apj .
Then the optimal value for ωj is given by
ωj =

(Asj , sj )
.
(Asj , Asj )

(7.55)

Finally, a formula is needed to update the approximate solution xj+1 from xj .
Equation (7.52) can be rewritten as
rj+1 = sj − ωj Asj = rj − αj Apj − ωj Asj
which yields
xj+1 = xj + αj pj + ωj sj .
After putting these relations together, we obtain the final form of the BICGSTAB
algorithm, due to van der Vorst [290].
A LGORITHM 7.7 BICGSTAB

1.
2.
3.

Compute r0 := b − Ax0 ; r0∗ arbitrary;
p0 := r0 .
For j = 0, 1, . . . , until convergence Do:

7.4. TRANSPOSE-FREE VARIANTS
4.
5.
6.
7.
8.
9.
10.
11.

247

αj := (rj , r0∗ )/(Apj , r0∗ )
sj := rj − αj Apj
ωj := (Asj , sj )/(Asj , Asj )
xj+1 := xj + αj pj + ωj sj
rj+1 := sj − ωj Asj
α
(r
,r0∗ )
× ωjj
βj := (rj+1
∗
j ,r0 )
pj+1 := rj+1 + βj (pj − ωj Apj )
EndDo

Example 7.2. Table 7.2 shows the results of applying the BICGSTAB algorithm
with no preconditioning to three of the test problems described in Section 3.7. See
Matrix

Iters

Kflops

Residual

Error

F2DA

96

2048

0.14E-02

0.77E-04

F3D

64

6407

0.49E-03

0.17E-03

ORS

208

5222

0.22E+00

0.68E-04

Table 7.2: A test run of BICGSTAB with no preconditioning.
Example 6.1 for the meaning of the column headers in the table. As in Example 7.1,
’Iters’ is the number of matrix-by-vector multiplications required to converge. As can
be seen it is less than with BCG. Thus, using the number of matrix-by-vector products
as a criterion, BCG is more expensive than BICGSTAB in all three examples. For
problem 3, the number matvecs exceeds the 300 limit with BCG. If the number of
actual iterations is used as a criterion, then the two methods come close for the second
problem [61 steps for BCG versus 64 for BICGSTAB] while BCG is slightly faster
for Problem 1. Observe also that the total number of operations favors BICGSTAB.
This illustrates the main weakness of BCG as well as QMR, namely, the matrix-byvector products with the transpose are essentially wasted unless a dual system with
AT must be solved simultaneously.

7.4.3

Transpose-Free QMR (TFQMR)

The Transpose-Free QMR algorithm of Freund [134] is derived from the CGS algorithm. Observe that xj can be updated in two half-steps in line 6 of Algorithm 7.6,
namely, xj+ 1 = xj + αj uj and xj+1 = xj+ 1 + αj qj . This is only natural since
2
2
the actual update from one iterate to the next involves two matrix-by-vector multiplications, i.e., the degree of the residual polynomial is increased by two. In order
to avoid indices that are multiples of 21 , it is convenient when describing TFQMR to
double all subscripts in the CGS algorithm. With this change of notation, the main
steps of the Algorithm 7.6 (CGS) become

248

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

α2j = (r2j , r0∗ )/(Ap2j , r0∗ )

(7.56)

q2j = u2j − α2j Ap2j

(7.57)

x2j+2 = x2j + α2j (u2j + q2j )

(7.58)

r2j+2 = r2j − α2j A(u2j + q2j )

(7.59)

β2j = (r2j+2 , r0∗ )/(r2j , r0∗ )

(7.60)

u2j+2 = r2j+2 + β2j q2j

(7.61)

p2j+2 = u2j+2 + β2j (q2j + βp2j ).

(7.62)

The initialization is identical with that of Algorithm 7.6. The update of the approximate solution in (7.58) can now be split into the following two half-steps:
x2j+1 = x2j + α2j u2j

(7.63)

x2j+2 = x2j+1 + α2j q2j .

(7.64)

This can be simplified by defining the vectors um for odd m as u2j+1 = q2j . Similarly, the sequence of αm is defined for odd values of m as α2j+1 = α2j . In summary,

um ≡ qm−1
.
(7.65)
for m odd define:
αm ≡ αm−1
With these definitions, the relations (7.63–7.64) are translated into the single equation
xm = xm−1 + αm−1 um−1 ,
which is valid whether m is even or odd. The intermediate iterates xm , with m odd,
which are now defined do not exist in the original CGS algorithm. For even values
of m the sequence xm represents the original sequence or iterates from the CGS
algorithm. It is convenient to introduce the N × m matrix,
Um = [u0 , . . . , um−1 ]
and the m-dimensional vector
zm = (α0 , α1 , . . . , αm−1 )T .
The general iterate xm satisfies the relation
xm = x0 + Um zm
= xm−1 + αm−1 um−1 .

(7.66)
(7.67)

From the above equation, it is clear that the residual vectors rm are related to the
u-vectors by the relations
rm = r0 − AUm zm

= rm−1 − αm−1 Aum−1 .

(7.68)
(7.69)

7.4. TRANSPOSE-FREE VARIANTS

249

Next, a relation similar to the relation (6.7) seen for FOM and GMRES will be
extracted using the matrix AUm . As a result of (7.69), the following relation holds:
Aui =

1
(ri − ri+1 ) .
αi

Translated in matrix form, this relation becomes
AUm = Rm+1 B̄m

(7.70)

Rk = [r0 , r1 , . . . , rk−1 ]

(7.71)

where
and where B̄m is the (m + 1) × m matrix,


1
0 ... ... 0
.. 
 −1 1
. 



 0 −1 1 . . .

1
1 1


, ,...
.
B̄m =  ..
..  × diag
..
..
.
.
 .
α0 α1
αm−1
. 
 .

 ..
−1 1 
0 ...
−1

(7.72)

The columns of Rm+1 can be rescaled, for example, to make each of them have a
2-norm equal to one, by multiplying Rm+1 to the right by a diagonal matrix. Let this
diagonal matrix be the inverse of the matrix
∆m+1 = diag [δ0 , δ1 , . . . , δm ] .
Then,
AUm = Rm+1 ∆−1
m+1 ∆m+1 B̄m .

(7.73)

With this, equation (7.68) becomes


rm = r0 − AUm zm = Rm+1 e1 − B̄m zm


= Rm+1 ∆−1
m+1 δ0 e1 − ∆m+1 B̄m zm .

(7.74)
(7.75)

By analogy with the GMRES algorithm, define

H̄m ≡ ∆m+1 B̄m .
Similarly, define Hm to be the matrix obtained from H̄m by deleting its last row. It is
easy to verify that the CGS iterates xm (now defined for all integers m = 0, 1, 2, . . .)
satisfy the same definition as FOM, i.e.,
−1
xm = x0 + Um Hm
(δ0 e1 ).

(7.76)

It is also possible to extract a GMRES-like solution from the relations (7.73) and
(7.75), similar to DQGMRES. In order to minimize the residual norm over the Krylov
subspace, the 2-norm of the right-hand side of (7.75) would have to be minimized,

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

250

but this is not practical since the columns of Rm+1 ∆−1
m+1 are not orthonormal as in
GMRES. However, the 2-norm of δ0 e1 − ∆m+1 B̄m z can be minimized over z, as
was done for the QMR and DQGMRES algorithms.
This defines the TFQMR iterates theoretically. However, it is now necessary to
find a formula for expressing the iterates in a progressive way. There are two ways
to proceed. The first follows DQGMRES closely, defining the least-squares solution
progressively and exploiting the structure of the matrix Rm to obtain a formula for
xm from xm−1 . Because of the special structure of H̄m , this is equivalent to using the
DQGMRES algorithm with k = 1. The second way to proceed exploits Lemma 6.16
seen in the previous chapter. This lemma, which was shown for the FOM/GMRES
pair, is also valid for the CGS/TFQMR pair. There is no fundamental difference
between the two situations. Thus, the TFQMR iterates satisfy the relation
xm − xm−1 = c2m (x̃m − xm−1 )

(7.77)

where the tildes are now used to denote the CGS iterate. Setting
dm ≡

1
1
(x̃m − xm−1 ) = 2
(xm − xm−1 )
αm−1
cm αm−1

(7.78)

ηm ≡ c2m αm−1 ,
the above expression for xm becomes
xm = xm−1 + ηm dm .

(7.79)

Now observe from (7.67) that the CGS iterates x̃m satisfy the relation
x̃m = x̃m−1 + αm−1 um−1 .

(7.80)

From the above equations, a recurrence relation from dm can be extracted. The
definition of dm and the above relations yield
dm =

1
αm−1

(x̃m − x̃m−1 + x̃m−1 − xm−1 )
1

(x̃m−1 − xm−2 − (xm−1 − xm−2 ))
αm−1
1 − c2m−1
= um−1 +
(x̃m−1 − xm−2 ) .
αm−1
= um−1 +

Therefore,
dm = um−1 +

(1 − c2m−1 )ηm−1
dm−1 .
c2m−1 αm−1

The term (1−c2m−1 )/c2m−1 is the squared tangent of the angle used in the (m−1)−st
rotation. This tangent will be denoted by θm−1 , and we have
θm =

sm
,
cm

c2m =

1
,
2
1 + θm

dm+1 = um +

2 η
θm
m
dm .
αm

7.4. TRANSPOSE-FREE VARIANTS

251

The angle used in the m-th rotation, or equivalently cm , can be obtained by examining the matrix H̄m :


δ0
0
... ...
0
.

 −δ
..

 1 δ1
 

 0
−δ2 δ2
...
1


. (7.81)
H̄m =  ..
 × diag
..
.
.
.
.

 .
αi i=0,...,m−1
.
.
.

 .
 ..
−δm
δm 
0
...
−δm+1

The diagonal matrix in the right-hand side scales the columns of the matrix. It is easy
to see that it has no effect on the determination of the rotations. Ignoring this scaling,
the above matrix becomes, after j rotations,


⋆ ⋆


⋆ ⋆


.
.
..
..






τ
0
j



.
−δj+1 δj+1




..
..


.
.



−δm
δm 
−δm+1

The next rotation is then determined by,
sj+1 = q

−δj+1

2
τj2 + δj+1

,

cj+1 = q

τj
2
τj2 + δj+1

,

θj+1 =

−δj+1
.
τj

In addition, after this rotation is applied to the above matrix, the diagonal element
δj+1 which is in position (j + 1, j + 1) is transformed into
τj+1 = δj+1 × cj+1 = q

τj δj+1
2
τj2 + δj+1

= −τj sj+1 = −τj θj+1 cj+1 .

(7.82)

The above relations enable us to update the direction dm and the required quantities
cm and ηm . Since only the squares of these scalars are invoked in the update of the
direction dm+1 , a recurrence for their absolute values is sufficient. This gives the
following recurrences which will be used in the algorithm:
2
dm+1 = um + (θm
/αm )ηm dm

θm+1 = δm+1 /τm
cm+1 =

2
1 + θm+1

− 1

τm+1 = τm θm+1 cm+1
ηm+1 = c2m+1 αm .

2

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

252

Before writing down the algorithm, a few relations must be exploited. Since the
vectors rm are no longer the actual residuals in the algorithm, we change the notation
to wm . These residual vectors can be updated by the formula
wm = wm−1 − αm−1 Aum−1 .
The vectors Aui can be used to update the vectors
v2j ≡ Ap2j
which are needed in the CGS algorithm. Multiplying (7.62) by A results in
Ap2j = Au2j + β2j−2 (Aq2j−2 + βj Ap2j−2 )
which, upon substituting the relation
q2j = u2j+1
translates into
v2j = Au2j + β2j−2 (Au2j−1 + β2j−2 v2j−2 ).
Also, observe that the recurrences in (7.57) and (7.61) for q2j and u2j+2 , respectively,
become
u2j+1 = u2j − α2j v2j

u2j+2 = w2j+2 + β2j u2j+1 .
The first equation should be used to compute um+1 when m is even, and the second
when m is odd. In the following algorithm, the normalization δm = kwm k2 , which
normalize each column of Rm to have 2-norm unity, is used.
A LGORITHM 7.8 Transpose-Free QMR (TFQMR)

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.

Compute w0 = u0 = r0 = b − Ax0 , v0 = Au0 , d0 = 0;
τ0 = kr0 k2 , θ0 = η0 = 0.
Choose r0∗ such that ρ0 ≡ (r0∗ , r0 ) 6= 0.
For m = 0, 1, 2, . . . , until convergence Do:
If m is even then
αm+1 = αm = ρm /(vm , r0∗ )
um+1 = um − αm vm
EndIf
wm+1 = wm − αm Aum
2 /α )η d
dm+1 = um + (θm
m m m
− 1
2
2
θm+1 = kwm+1 k2 /τm ; cm+1 = 1 + θm+1
2
τm+1 = τm θm+1 cm+1 ; ηm+1 = cm+1 αm
xm+1 = xm + ηm+1 dm+1
If m is odd then

7.4. TRANSPOSE-FREE VARIANTS
15.
16.
17.
18.
19.

253

ρm+1 = (wm+1 , r0∗ ); βm−1 = ρm+1 /ρm−1
um+1 = wm+1 + βm−1 um
vm+1 = Aum+1 + βm−1 (Aum + βm−1 vm−1 )
EndIf
EndDo

Notice that the quantities in the odd m loop are only defined for even values of
m. The residual norm of the approximate solution xm is not available from the
above algorithm as it is described. However, good estimates can be obtained using
similar strategies to those used for DQGMRES. Referring to GMRES, an interesting
observation is that the recurrence (6.47) is identical with the recurrence of the scalars
τj ’s. In addition, these two sequences start with the same values, δ0 for the τ ’s and β
for the γ’s. Therefore,
γm+1 = τm .
Recall that γm+1 is the residual for the (m + 1) × m least-squares problem
min kδ0 e1 − H̄m zk2 .
z

Hence, a relation similar to that for DQGMRES holds, namely,
√
kb − Axm k ≤ m + 1τm .

(7.83)

This provides a readily computable estimate of the residual norm. Another point that
should be made is that it is possible to use the scalars sm , cm in the recurrence instead
of the pair cm , θm , as was done above. In this case, the proper recurrences are
dm+1 = um + (s2m /αm )αm−1 dm
q
2 + δ2
sm+1 = δm+1 / τm
m+1
q
2 + δ2
cm+1 = τm / τm
m+1
τm+1 = τm sm+1

ηm+1 = c2m+1 αm .

Table 7.3 shows the results when TFQMR algorithm without preconditioning is applied to three of the test problems described in Section 3.7.
Matrix Iters Kflops Residual
Error
Example 7.3.

F2DA

112

2736

0.46E-04

0.68E-04

F3D

78

8772

0.52E-04

0.61E-03

ORS

252

7107

0.38E-01

0.19E-03

Table 7.3: A test run of TFQMR with no preconditioning.

254

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

See Example 6.1 for the meaning of the column headers in the table. As with
previous examples, ’Iters’ represents the number of matrix-by-vector multiplications
rather the number of Biconjugate Gradient steps. This number is slightly higher than
that of BICGSTAB.
Using the number of matrix-by-vector products as a criterion, TFQMR is more
expensive that BICGSTAB in all three cases, and it is also less expensive than BCG
for all cases. If the number of actual iterations is used as a criterion, then BCG is
just slightly better for Problems 1 and 2. A comparison is not possible for Problem
3, since the number of matrix-by-vector products required for convergence exceeds
the limit of 300. In general, the number of steps required for convergence is similar
for BICGSTAB and TFQMR. A comparison with the methods seen in the previous
chapter indicates that in many cases, GMRES will be faster if the problem is well
conditioned, resulting in a moderate number of steps required to converge. If many
steps (say, in the hundreds) are required, then BICGSTAB and TFQMR may perform
better. If memory is not an issue, GMRES or DQGMRES, with a large number
of directions, is often the most reliable choice. The issue then is one of trading
robustness for memory usage. In general, a sound strategy is to focus on finding a
good preconditioner rather than the best accelerator.

P ROBLEMS
P-7.1 Consider the following modification of the Lanczos algorithm, Algorithm 7.1. We
replace line 6 by
j
X
hij wi
ŵj+1 = AT wj −
i=1

where the scalars hij are arbitrary. Lines 5 and 7 through 10 remain the same but line 4 in
which αj is computed must be changed.
a. Show how to modify line 4 to ensure that the vector v̂j+1 is orthogonal against the
vectors wi , for i = 1, . . . , j.
b. Prove that the vectors vi ’s and the matrix Tm do not depend on the choice of the hij ’s.
c. Consider the simplest possible choice, namely, hij ≡ 0 for all i, j. What are the
advantages and potential difficulties with this choice?
P-7.2 Assume that the Lanczos algorithm does not break down before step m, i.e., that it is
possible to generate v1 , . . . vm+1 . Show that Vm+1 and Wm+1 are both of full rank.
P-7.3 Develop a modified version of the non-Hermitian Lanczos algorithm that produces
a sequence of vectors vi , wi such that each vi is orthogonal to every wj with j 6= i and
kvi k2 = kwi k2 = 1 for all i. What does the projected problem become?
P-7.4 Develop a version of the non-Hermitian Lanczos algorithm that produces a sequence
of vectors vi , wi which satisfy
(vi , wj ) = ±δij ,

but such that the matrix Tm is Hermitian tridiagonal. What does the projected problem
become in this situation?

7.4. TRANSPOSE-FREE VARIANTS

255

P-7.5 Using the notation of Section 7.1.2 prove that qj+k (t) = tk pj (t) is orthogonal to
the polynomials p1 , p2 , . . . , pj−k , assuming that k ≤ j. Show that if qj+k is orthogonalized
against p1 , p2 , . . . , pj−k , the result would be orthogonal to all polynomials of degree < j +k.
Derive a general Look-Ahead non-Hermitian Lanczos procedure based on this observation.
P-7.6 Consider the matrices Vm = [v1 , . . . , vm ] and Wm = [w1 , . . . , wm ] obtained from
the Lanczos biorthogonalization algorithm. (a) What are the matrix representations of the
(oblique) projector onto Km (A, v1 ) orthogonal to the subspace Km (AT , w1 ), and the projector onto Km (AT , w1 ) orthogonally to the subspace Km (A, v1 )? (b) Express a general
condition for the existence of an oblique projector onto K, orthogonal to L. (c) How can this
condition be interpreted using the Lanczos vectors and the Lanczos algorithm?
P-7.7 Show a three-term recurrence satisfied by the residual vectors rj of the BCG algorithm. Include the first two iterates to start the recurrence. Similarly, establish a three-term
recurrence for the conjugate direction vectors pj in BCG.
P-7.8 Let φj (t) and πj (t) be the residual polynomial and the conjugate direction polynomial, respectively, for the BCG algorithm, as defined in Section 7.4.1. Let ψj (t) be any other
polynomial sequence which is defined from the recurrence
ψ0 (t) = 1,

ψ1 (t) = (1 − ξ0 t)ψ0 (t)

ψj+1 (t) = (1 + ηj − ξj t)ψj (t) − ηj ψj−1 (t)
a. Show that the polynomials ψj are consistent, i.e., ψj (0) = 1 for all j ≥ 0.
b. Show the following relations
ψj+1 φj+1 = ψj φj+1 − ηj (ψj−1 − ψj )φj+1 − ξj tψj φj+1
ψj φj+1 = ψj φj − αj tψj πj

(ψj−1 − ψj )φj+1 = ψj−1 φj − ψj φj+1 − αj tψj−1 πj
ψj+1 πj+1 = ψj+1 φj+1 − βj ηj ψj−1 πj + βj (1 + ηj )ψj πj − βj ξj tψj πj
ψj πj+1 = ψj φj+1 + βj ψj πj .

c. Defining,
tj = ψj (A)φj+1 (A)r0 , yj = (ψj−1 (A) − ψj (A))φj+1 (A)r0 ,
pj = ψj (A)πj (A)r0 ,
sj = ψj−1 (A)πj (A)r0
show how the recurrence relations of the previous question translate for these vectors.
d. Find a formula that allows one to update the approximation xj+1 from the vectors
xj−1 , xj and tj , pj , yj , sj defined above.
e. Proceeding as in BICGSTAB, find formulas for generating the BCG coefficients αj
and βj from the vectors defined in the previous question.
P-7.9 Prove the expression (7.76) for the CGS approximation defined by (7.66–7.67). Is
the relation valid for any choice of scaling ∆m+1 ?
P-7.10 Prove that the vectors rj and ri∗ produced by the BCG algorithm are orthogonal to
each other when i 6= j, while the vectors pi and p∗j are A-orthogonal, i.e., (Apj , p∗i ) = 0 for
i 6= j.
P-7.11 The purpose of this exercise is to develop block variants of the Lanczos algorithm.
Consider a two-sided analogue of the Block-Arnoldi algorithm, in its variant of Algorithm
6.24. Formally, the general step that defines the biorthogonalization process, for j ≥ p, is as
follows:

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

256

Orthogonalize Avj−p+1 versus w1 , w2 , . . . , wj (by subtracting a linear combination
of v1 , . . . , vj from Avj−p+1 ). Call v the resulting vector.
Orthogonalize AT wj−p+1 versus v1 , v2 , . . . , vj (by subtracting a linear combination
of w1 , . . . , wj from AT wj−p+1 ). Call w the resulting vector.
Normalize the two vectors v and w so that (v, w) = 1 to get vj+1 and wj+1 .

1.
2.
3.

Here, p is the block size and it is assumed that the initial blocks are biorthogonal: (vi , wj ) =
δij for i, j ≤ p.

a. Show that Avj−p+1 needs only to be orthogonalized against the 2p previous wi ’s instead of all of them. Similarly, AT wj−p+1 must be orthogonalized only against the 2p
previous vi ’s.

b. Write down the algorithm completely. Show the orthogonality relations satisfied by
the vectors vi and wj . Show also relations similar to (7.3) and (7.4).
c. We now assume that the two sets of vectors vi and wj have different block sizes. Call
q the block-size for the w’s. Line 2 of the above formal algorithm is changed into:
2a.

Orthogonalize AT wj−q+1 versus v1 , v2 , . . . , vj (· · ·). Call w the resulting vector.

and the rest remains unchanged. The initial vectors are again biorthogonal: (vi , wj ) =
δij for i ≤ p and j ≤ q. Show that now Avj−p+1 needs only to be orthogonalized
against the q + p previous wi ’s instead of all of them. Show a simlar result for the wj ’s.
d. Show how a block version of BCG and QMR can be developed based on the algorithm
resulting from question (c).
N OTES AND R EFERENCES . The pioneering paper by Lanczos [197], on what is now referred to as
Bi-CG, did not receive the attention it deserved. Fletcher [130] who developed the modern version of
the algorithm mentions the 1950 Lanczos paper [195] which is devoted mostly to eigenvalue problems,
but seemed unaware of the second [197] which is devoted to linear systems. Likewise, the paper by
Sonneveld [272] which proved for the first time that the AT operations were not necessary, received
little attention for several years (the first reference to the method [312] dates back to 1980). TFQMR
(Freund and Nachtigal [136]) and BICGSTAB (van der Vorst [290]) were later developed to cure
some of the numerical problems that plague CGS. Many additions and variations to the basic BCG,
BICGSTAB, and TFQMR techniques appeared, see, e.g., [63, 72, 160, 161, 260], among others. Some
variations were developed to cope with the breakdown of the underlying Lanczos or BCG algorithm;
see, for example, [62, 27, 135, 260, 321]. Finally, block methods of these algorithms have also been
developed, see, e.g., [5].
The Lanczos-type algorithms developed for solving linear systems are rooted in the theory of
orthogonal polynomials and Padé approximation. Lanczos himself certainly used this viewpoint when
he wrote his breakthrough papers [195, 197] in the early 1950s. The monograph by Brezinski [59]
gives an excellent coverage of the intimate relations between approximation theory and the Lanczostype algorithms. Freund [133] establishes these relations for quasi-minimal residual methods. A few
optimality properties for the class of methods presented in this chapter can be proved using a variable
metric, i.e., an inner product which is different at each step [29]. A survey by Weiss [308] presents a
framework for Krylov subspace methods explaining some of these optimality properties and the interrelationships between Krylov subspace methods. Several authors discuss a class of techniques known
as residual smoothing; see for example [259, 324, 308, 61]. These techniques can be applied to any
iterative sequence xk to build a new sequence of iterates yk by combining yk−1 with the difference
xk − yk−1 . A remarkable result shown by Zhou and Walker [324] is that the iterates of the QMR
algorithm can be obtained from those of the BCG as a particular case of residual smoothing.

7.4. TRANSPOSE-FREE VARIANTS

257

A number of projection-type methods on Krylov subspaces, other than those seen in this chapter
and the previous one are described in [1]. The group of rank-k update methods discussed by Eirola
and Nevanlinna [113] and Deuflhard et al. [100] is closely related to Krylov subspace methods. In
fact, GMRES can be viewed as a particular example of these methods. Also of interest and not
covered in this book are the vector extrapolation techniques which are discussed, for example, in the
books Brezinski [59], Brezinski and Radivo Zaglia [60] and the articles [270] and [177]. Connections
between these methods and Krylov subspace methods, have been uncovered, and are discussed by
Brezinski [59] and Sidi [263].

258

CHAPTER 7. KRYLOV SUBSPACE METHODS PART II

Chapter 8

METHODS RELATED TO THE NORMAL
EQUATIONS

There are a number of techniques for converting a non-symmetric linear system into a symmetric
one. One such technique solves the equivalent linear system AT Ax = AT b, called the normal
equations. Often, this approach is avoided in practice because the coefficient matrix AT A is
much worse conditioned than A. However, the normal equations approach may be adequate in
some situations. Indeed, there are even applications in which it is preferred to the usual Krylov
subspace techniques. This chapter covers iterative methods which are either directly or implicitly
related to the normal equations.

8.1

The Normal Equations

In order to solve the linear system Ax = b when A is nonsymmetric, we can solve
the equivalent system
AT A x = AT b
(8.1)
which is Symmetric Positive Definite. This system is known as the system of the
normal equations associated with the least-squares problem,
minimize

kb − Axk2 .

(8.2)

Note that (8.1) is typically used to solve the least-squares problem (8.2) for overdetermined systems, i.e., when A is a rectangular matrix of size n × m, m < n.
A similar well known alternative sets x = AT u and solves the following equation
for u:
AAT u = b.
(8.3)
Once the solution u is computed, the original unknown x could be obtained by multiplying u by AT . However, most of the algorithms we will see do not invoke the u
variable explicitly and work with the original variable x instead. The above system
of equations can be used to solve under-determined systems, i.e., those systems involving rectangular matrices of size n × m, with n < m. It is related to (8.1) in the
following way. Assume that n ≤ m and that A has full rank. Let x∗ be any solution
to the underdetermined system Ax = b. Then (8.3) represents the normal equations
for the least-squares problem,
minimize

kx∗ − AT uk2 .
259

(8.4)

260

CHAPTER 8. METHODS RELATED TO THE NORMAL EQUATIONS

Since by definition AT u = x, then (8.4) will find the solution vector x that is closest
to x∗ in the 2-norm sense. What is interesting is that when n < m there are infinitely
many solutions x∗ to the system Ax = b, but the minimizer u of (8.4) does not
depend on the particular x∗ used.
The system (8.1) and methods derived from it are often labeled with NR (N
for “Normal” and R for “Residual”) while (8.3) and related techniques are labeled
with NE (N for “Normal” and E for “Error”). If A is square and nonsingular, the
coefficient matrices of these systems are both Symmetric Positive Definite, and the
simpler methods for symmetric problems, such as the Conjugate Gradient algorithm,
can be applied. Thus, CGNE denotes the Conjugate Gradient method applied to the
system (8.3) and CGNR the Conjugate Gradient method applied to (8.1).
There are several alternative ways to formulate symmetric linear systems having
the same solution as the original system. For instance, the symmetric linear system
   

b
r
I
A
(8.5)
=
0
x
AT O
with r = b − Ax, arises from the standard necessary conditions satisfied by the
solution of the constrained optimization problem,
1
kr − bk22
2
subject to AT r = 0.
minimize

(8.6)
(8.7)

The solution x to (8.5) is the vector of Lagrange multipliers for the above problem.
Another equivalent symmetric system is of the form


 

O A
Ax
b
=
.
AT O
x
AT b
The eigenvalues of the coefficient matrix for this system are ±σi , where σi is an
arbitrary singular value of A. Indefinite systems of this sort are not easier to solve
than the original nonsymmetric system in general. Although not obvious immediately, this approach is similar in nature to the approach (8.1) and the corresponding
Conjugate Gradient iterations applied to them should behave similarly.
A general consensus is that solving the normal equations can be an inefficient
approach in the case when A is poorly conditioned. Indeed, the 2-norm condition
number of AT A is given by
Cond2 (AT A) = kAT Ak2 k(AT A)−1 k2 .
2
Now observe that kAT Ak2 = σmax
(A) where σmax (A) is the largest singular value
of A which, incidentally, is also equal to the 2-norm of A. Thus, using a similar
argument for the inverse (AT A)−1 yields

Cond2 (AT A) = kAk22 kA−1 k22 = Cond22 (A).

(8.8)

The 2-norm condition number for AT A is exactly the square of the condition number
of A, which could cause difficulties. For example, if originally Cond2 (A) = 108 ,

8.2. ROW PROJECTION METHODS

261

then an iterative method may be able to perform reasonably well. However, a condition number of 1016 can be much more difficult to handle by a standard iterative
method. That is because any progress made in one step of the iterative procedure
may be annihilated by the noise due to numerical errors.
On the other hand, if the original matrix has a good 2-norm condition number,
then the normal equation approach should not cause any serious difficulties. In the
extreme case when A is unitary, i.e., when AH A = I, then the normal equations
are clearly the best approach (the Conjugate Gradient method will converge in zero
step!).

8.2

Row Projection Methods

When implementing a basic relaxation scheme, such as Jacobi or SOR, to solve the
linear system
AT Ax = AT b,
(8.9)
or
AAT u = b,

(8.10)

it is possible to exploit the fact that the matrices AT A or AAT need not be formed
explicitly. As will be seen, only a row or a column of A at a time is needed at a given
relaxation step. These methods are known as row projection methods since they are
indeed projection methods on rows of A or AT . Block row projection methods can
also be defined similarly.

8.2.1

Gauss-Seidel on the Normal Equations

It was stated above that in order to use relaxation schemes on the normal equations,
only access to one column of A at a time is needed for (8.9) and one row at a time
for (8.10). This is now explained for (8.10) first. Starting from an approximation
to the solution of (8.10), a basic relaxation-based iterative procedure modifies its
components in a certain order using a succession of relaxation steps of the simple
form
unew = u + δi ei
(8.11)
where ei is the i-th column of the identity matrix. The scalar δi is chosen so that the
i-th component of the residual vector for (8.10) becomes zero. Therefore,
(b − AAT (u + δi ei ), ei ) = 0

(8.12)

which, setting r = b − AAT u, yields,
δi =

(r, ei )
.
kAT ei k22

(8.13)

Denote by βi the i-th component of b. Then a basic relaxation step consists of taking
δi =

βi − (AT u, AT ei )
.
kAT ei k22

(8.14)

262

CHAPTER 8. METHODS RELATED TO THE NORMAL EQUATIONS

Also, (8.11) can be rewritten in terms of x-variables as follows:
xnew = x + δi AT ei .

(8.15)

The auxiliary variable u has now been removed from the scene and is replaced by
the original variable x = AT u.
Consider the implementation of a forward Gauss-Seidel sweep based on (8.15)
and (8.13) for a general sparse matrix. The evaluation of δi from (8.13) requires the
inner product of the current approximation x = AT u with AT ei , the i-th row of A.
This inner product is inexpensive to compute because AT ei is usually sparse. If an
acceleration parameter ω is used, we only need to change δi into ωδi . Therefore, a
forward SOR sweep would be as follows.
A LGORITHM 8.1 Forward NE-SOR Sweep

1.
2.
3.
4.
5.

Choose an initial x.
For i = 1, 2, . . . , n Do:
−(AT ei ,x)
δi = ω βi kA
T e k2
i 2
x := x + δi AT ei
EndDo

Note that AT ei is a vector equal to the transpose of the i-th row of A. All that is
needed is the row data structure for A to implement the above algorithm. Denoting
by nzi the number of nonzero elements in the i-th row of A, then each step of the
above sweep requires 2nzi + 2 operations in line 3, and another 2nzi operations in
line 4, bringing the total to 4nzi + 2. The total for a whole sweep becomes 4nz + 2n
operations, where nz represents the total number of nonzero elements of A. Twice as
many operations are required for the Symmetric Gauss-Seidel or the SSOR iteration.
Storage consists of the right-hand side, the vector x, and possibly an additional vector
to store the 2-norms of the rows of A. A better alternative would be to rescale each
row by its 2-norm at the start.
Similarly, Gauss-Seidel for (8.9) would consist of a sequence of steps of the form
xnew = x + δi ei .

(8.16)

Again, the scalar δi is to be selected so that the i-th component of the residual vector
for (8.9) becomes zero, which yields
(AT b − AT A(x + δi ei ), ei ) = 0.

(8.17)

With r ≡ b − Ax, this becomes (AT (r − δi Aei ), ei ) = 0, which yields
δi =

(r, Aei )
.
kAei k22

Then the following algorithm is obtained.

(8.18)

8.2. ROW PROJECTION METHODS

263

A LGORITHM 8.2 Forward NR-SOR Sweep

1.
2.
3.
4.
5.
6.

Choose an initial x, compute r := b − Ax.
For i = 1, 2, . . . , n Do:
(r,Aei )
δi = ω kAe
2
i k2
x := x + δi ei
r := r − δi Aei
EndDo

In contrast with Algorithm 8.1, the column data structure of A is now needed for
the implementation instead of its row data structure. Here, the right-hand side b can
be overwritten by the residual vector r, so the storage requirement is essentially the
same as in the previous case. In the NE version, the scalar βi − (x, ai ) is just the i-th
component of the current residual vector r = b − Ax. As a result, stopping criteria
can be built for both algorithms based on either the residual vector or the variation
in the solution. Note that the matrices AAT and AT A can be dense or generally
much less sparse than A, yet the cost of the above implementations depends only
on the nonzero structure of A. This is a significant advantage of relaxation-type
preconditioners over incomplete factorization preconditioners when using Conjugate
Gradient methods to solve the normal equations.
One question remains concerning the acceleration of the above relaxation schemes
by under- or over-relaxation. If the usual acceleration parameter ω is introduced, then
we only have to multiply the scalars δi in the previous algorithms by ω. One serious
difficulty here is to determine the optimal relaxation factor. If nothing in particular is known about the matrix AAT , then the method will converge for any ω lying
strictly between 0 and 2, as was seen in Chapter 4, because the matrix is positive definite. Moreover, another unanswered question is how convergence can be affected
by various reorderings of the rows. For general sparse matrices, the answer is not
known.

8.2.2

Cimmino’s Method

In a Jacobi iteration for the system (8.9), the components of the new iterate satisfy
the following condition:
(AT b − AT A(x + δi ei ), ei ) = 0.

(8.19)

This yields
(b − A(x + δi ei ), Aei ) = 0 or

(r − δi Aei , Aei ) = 0

in which r is the old residual b − Ax. As a result, the i-component of the new iterate
xnew is given by
xnew,i = xi + δi ei ,
(r, Aei )
.
δi =
kAei k22

(8.20)
(8.21)

264

CHAPTER 8. METHODS RELATED TO THE NORMAL EQUATIONS

Here, be aware that these equations do not result in the same approximation as that
produced by Algorithm 8.2, even though the modifications are given by the same
formula. Indeed, the vector x is not updated after each step and therefore the scalars
δi are different for the two algorithms. This algorithm is usually described with an
acceleration parameter ω, i.e., all δi ’s are multiplied uniformly by a certain ω. If d
denotes the vector with coordinates δi , i = 1, . . . , n, the following algorithm results.
A LGORITHM 8.3 Cimmino-NR

1.
2.
3.
4.
5.
6.
7.
8.

Choose initial guess x0 . Set x = x0 , r = b − Ax0
Until convergence Do:
For i = 1, . . . , n Do:
(r,Aei )
δi = ω kAe
2
i k2
EndDo
P
x := x + d where d = ni=1 δi ei
r := r − Ad
EndDo

Notice that all the coordinates will use the same residual vector r to compute
the updates δi . When ω = 1, each instance of the above formulas is mathematically
equivalent to performing a projection step for solving Ax = b with K = span{ei },
and L = AK. It is also mathematically equivalent to performing an orthogonal
projection step for solving AT Ax = AT b with K = span{ei }.
It is interesting to note that when each column Aei is normalized by its 2-norm,
i.e., if kAei k2 = 1, i = 1, . . . , n, then δi = ω(r, Aei ) = ω(AT r, ei ). In this situation,
d = ωAT r = ωAT (b − Ax)
and the main loop of the algorithm takes the vector form
d := ωAT r
x := x + d
r := r − Ad.
Each iteration is therefore equivalent to a step of the form

xnew = x + ω AT b − AT Ax

which is nothing but the Richardson iteration applied to the normal equations (8.1).
In particular, as was seen in Example 4.1, convergence is guaranteed for any ω which
satisfies,
2
(8.22)
0<ω<
λmax
where λmax is the largest eigenvalue of AT A. In addition, the best acceleration
parameter is given by
2
ωopt =
λmin + λmax

8.2. ROW PROJECTION METHODS

265

in which, similarly, λmin is the smallest eigenvalue of AT A. If the columns are not
normalized by their 2-norms, then the procedure is equivalent to a preconditioned
Richardson iteration with diagonal preconditioning. The theory regarding convergence is similar but involves the preconditioned matrix or, equivalently, the matrix
A′ obtained from A by normalizing its columns.
The algorithm can be expressed in terms of projectors. Observe that the new
residual satisfies
n
X
(r, Aei )
(8.23)
ω
rnew = r −
2 Aei .
kAe
k
i
2
i=1
Each of the operators

Pi :

r −→

(r, Aei )
Aei ≡ Pi r
kAei k22

(8.24)

is an orthogonal projector onto Aei , the i-th column of A. Hence, we can write
!
n
X
(8.25)
Pi r.
rnew = I − ω
i=1

There are two important variations to the above scheme. First, because the point
Jacobi iteration can be very slow, it may be preferable to work with sets of vectors
instead. Let π1 , π2 , . . . , πp be a partition of the set {1, 2, . . . , n} and, for each πj ,
let Ej be the matrix obtained by extracting the columns of the identity matrix whose
indices belong to πj . Going back to the projection framework, define Ai = AEi . If
an orthogonal projection method is used onto Ej to solve (8.1), then the new iterate
is given by
xnew = x + ω

p
X

Ei di

(8.26)

i

di = (EiT AT AEi )−1 EiT AT r = (ATi Ai )−1 ATi r.

(8.27)

Each individual block-component di can be obtained by solving a least-squares problem
min kr − Ai dk2 .
d

An interpretation of this indicates that each individual substep attempts to reduce the
residual as much as possible by taking linear combinations from specific columns of
Ai . Similar to the scalar iteration, we also have
!
n
X
Pi r
rnew = I − ω
i=1

where Pi now represents an orthogonal projector onto the span of Ai .
Note that A1 , A2 , . . . , Ap is a partition of the column-set {Aei }i=1,...,n and this
partition can be arbitrary. Another remark is that the original Cimmino method was
formulated for rows instead of columns, i.e., it was based on (8.1) instead of (8.3).
The alternative algorithm based on columns rather than rows is easy to derive.

266

CHAPTER 8. METHODS RELATED TO THE NORMAL EQUATIONS

8.3

Conjugate Gradient and Normal Equations

A popular combination to solve nonsymmetric linear systems applies the Conjugate
Gradient algorithm to solve either (8.1) or (8.3). As is shown next, the resulting algorithms can be rearranged because of the particular nature of the coefficient matrices.

8.3.1

CGNR

We begin with the Conjugate Gradient algorithm applied to (8.1). Applying CG
directly to the system and denoting by zi the residual vector at step i (instead of ri )
results in the following sequence of operations:
• αj := (zj , zj )/(AT Apj , pj ) = (zj , zj )/(Apj , Apj )
• xj+1 := xj + αj pj
• zj+1 := zj − αj AT Apj
• βj := (zj+1 , zj+1 )/(zj , zj )
• pj+1 := zj+1 + βj pj .
If the original residual ri = b− Axi must be available at every step, we may compute
the residual zi+1 in two parts: rj+1 := rj − αj Apj and then zi+1 = AT ri+1 which
is the residual for the normal equations (8.1). It is also convenient to introduce the
vector wi = Api . With these definitions, the algorithm can be cast in the following
form.
A LGORITHM 8.4 CGNR

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Compute r0 = b − Ax0 , z0 = AT r0 , p0 = z0 .
For i = 0, . . ., until convergence Do:
wi = Api
αi = kzi k2 /kwi k22
xi+1 = xi + αi pi
ri+1 = ri − αi wi
zi+1 = AT ri+1
βi = kzi+1 k22 /kzi k22 ,
pi+1 = zi+1 + βi pi
EndDo

In Chapter 6, the approximation xm produced at the m-th step of the Conjugate
Gradient algorithm was shown to minimize the energy norm of the error over an
affine Krylov subspace. In this case, xm minimizes the function
f (x) ≡ (AT A(x∗ − x), (x∗ − x))
over all vectors x in the affine Krylov subspace
x0 + Km (AT A, AT r0 ) = x0 + span{AT r0 , AT AAT r0 , . . . , (AT A)m−1 AT r0 },

8.3. CONJUGATE GRADIENT AND NORMAL EQUATIONS

267

in which r0 = b − Ax0 is the initial residual with respect to the original equations
Ax = b, and AT r0 is the residual with respect to the normal equations AT Ax =
AT b. However, observe that
f (x) = (A(x∗ − x), A(x∗ − x)) = kb − Axk22 .
Therefore, CGNR produces the approximate solution in the above subspace which
has the smallest residual norm with respect to the original linear system Ax = b. The
difference with the GMRES algorithm seen in Chapter 6, is the subspace in which
the residual norm is minimized.
Example 8.1. Table 8.1 shows the results of applying the CGNR algorithm with
no preconditioning to three of the test problems described in Section 3.7.
Matrix

Iters

Kflops

Residual

Error

F2DA

300

4847

0.23E+02

0.62E+00

F3D

300

23704

0.42E+00

0.15E+00

ORS

300

5981

0.30E+02

0.60E-02

Table 8.1: A test run of CGNR with no preconditioning.
See Example 6.1 for the meaning of the column headers in the table. The method
failed to converge in less than 300 steps for all three problems. Failures of this
type, characterized by very slow convergence, are rather common for CGNE and
CGNR applied to problems arising from partial differential equations. Preconditioning should improve performance somewhat but, as will be seen in Chapter 10, normal
equations are also difficult to precondition.

8.3.2

CGNE

A similar reorganization of the CG algorithm is possible for the system (8.3) as well.
Applying the CG algorithm directly to (8.3) and denoting by qi the conjugate directions, the actual CG iteration for the u variable would be as follows:
• αj := (rj , rj )/(AAT qj , qj ) = (rj , rj )/(AT qj , AT qj )
• uj+1 := uj + αj qj
• rj+1 := rj − αj AAT qj
• βj := (rj+1 , rj+1 )/(rj , rj )
• qj+1 := rj+1 + βj qj .

CHAPTER 8. METHODS RELATED TO THE NORMAL EQUATIONS

268

Notice that an iteration can be written with the original variable xi = x0 + AT (ui −
u0 ) by introducing the vector pi = AT qi . Then, the residual vectors for the vectors
xi and ui are the same. No longer are the qi vectors needed because the pi ’s can
be obtained as pj+1 := AT rj+1 + βj pj . The resulting algorithm described below,
the Conjugate Gradient for the normal equations (CGNE), is also known as Craig’s
method.
A LGORITHM 8.5 CGNE (Craig’s Method)

Compute r0 = b − Ax0 , p0 = AT r0 .
For i = 0, 1, . . . , until convergence Do:
αi = (ri , ri )/(pi , pi )
xi+1 = xi + αi pi
ri+1 = ri − αi Api
βi = (ri+1 , ri+1 )/(ri , ri )
pi+1 = AT ri+1 + βi pi
EndDo

1.
2.
3.
4.
5.
6.
7.
8.

We now explore the optimality properties of this algorithm, as was done for
CGNR. The approximation um related to the variable xm by xm = AT um is the
actual m-th CG approximation for the linear system (8.3). Therefore, it minimizes
the energy norm of the error on the Krylov subspace Km . In this case, um minimizes
the function
f (u) ≡ (AAT (u∗ − u), (u∗ − u))
over all vectors u in the affine Krylov subspace,
u0 + Km (AAT , r0 ) = u0 + span{r0 , AAT r0 , . . . , (AAT )m−1 r0 }.
Notice that r0 = b − AAT u0 = b − Ax0 . Also, observe that
f (u) = (AT (u∗ − u), AT (u∗ − u)) = kx∗ − xk22 ,
where x = AT u. Therefore, CGNE produces the approximate solution in the subspace
x0 + AT Km (AAT , r0 ) = x0 + Km (AT A, AT r0 )
which has the smallest 2-norm of the error. In addition, note that the subspace x0 +
Km (AT A, AT r0 ) is identical with the subspace found for CGNR. Therefore, the
two methods find approximations from the same subspace which achieve different
optimality properties: minimal residual for CGNR and minimal error for CGNE.

8.4

Saddle-Point Problems

Now consider the equivalent system

   
I
A
r
b
=
T
A
O
x
0

8.4. SADDLE-POINT PROBLEMS

269

with r = b − Ax. This system can be derived from the necessary conditions applied
to the constrained least-squares problem (8.6–8.7). Thus, the 2-norm of b − r = Ax
is minimized implicitly under the constraint AT r = 0. Note that A does not have to
be a square matrix.
This can be extended into a more general constrained quadratic optimization
problem as follows:
1
(Ax, x) − (x, b)
2
subject to B T x = c.
minimize f (x) ≡

The necessary conditions for optimality yield the linear system
   

A B
x
b
=
T
B
O
y
c

(8.28)
(8.29)

(8.30)

in which the names of the variables r, x are changed into x, y for notational convenience. It is assumed that the column dimension of B does not exceed its row
dimension. The Lagrangian for the above optimization problem is
L(x, y) =

1
(Ax, x) − (x, b) + (y, (B T x − c))
2

and the solution of (8.30) is the saddle point of the above Lagrangian. Optimization
problems of the form (8.28–8.29) and the corresponding linear systems (8.30) are
important and arise in many applications. Because they are intimately related to the
normal equations, we discuss them briefly here.
In the context of fluid dynamics, a well known iteration technique for solving
the linear system (8.30) is Uzawa’s method, which resembles a relaxed block SOR
iteration.
A LGORITHM 8.6 Uzawa’s Method

1.
2.
3.
4.
5.

Choose x0 , y0
For k = 0, 1, . . . , until convergence Do:
xk+1 = A−1 (b − Byk )
yk+1 = yk + ω(B T xk+1 − c)
EndDo
The algorithm requires the solution of the linear system
Axk+1 = b − Byk

(8.31)

at each iteration. By substituting the result of line 3 into line 4, the xk iterates can be
eliminated to obtain the following relation for the yk ’s,

yk+1 = yk + ω B T A−1 (b − Byk ) − c

270

CHAPTER 8. METHODS RELATED TO THE NORMAL EQUATIONS

which is nothing but a Richardson iteration for solving the linear system
B T A−1 By = B T A−1 b − c.

(8.32)

Apart from a sign, this system is the reduced system resulting from eliminating the
x variable from (8.30). Convergence results can be derived from the analysis of the
Richardson iteration.
Corollary 8.1 Let A be a Symmetric Positive Definite matrix and B a matrix of
full rank. Then S = B T A−1 B is also Symmetric Positive Definite and Uzawa’s
algorithm converges, if and only if
0<ω<

2
λmax (S)

.

(8.33)

In addition, the optimal convergence parameter ω is given by
ωopt =

2
.
λmin (S) + λmax (S)

Proof. The proof of this result is straightforward and is based on the results seen in
Example 4.1.
It is interesting to observe that when c = 0 and A is Symmetric Positive Definite, then the system (8.32) can be regarded as the normal equations for minimizing
the A−1 -norm of b − By. Indeed, the optimality conditions are equivalent to the
orthogonality conditions
(b − By, Bw)A−1 = 0,

∀ w,

which translate into the linear system B T A−1 By = B T A−1 b. As a consequence,
the problem will tend to be easier to solve if the columns of B are almost orthogonal
with respect to the A−1 inner product. This is true when solving the Stokes problem
where B represents the discretization of the gradient operator while B T discretizes
the divergence operator, and A is the discretization of a Laplacian. In this case, if
it were not for the boundary conditions, the matrix B T A−1 B would be the identity.
This feature can be exploited in developing preconditioners for solving problems
of the form (8.30). Another particular case is when A is the identity matrix and
c = 0. Then, the linear system (8.32) becomes the system of the normal equations for
minimizing the 2-norm of b − By. These relations provide insight in understanding
that the block form (8.30) is actually a form of normal equations for solving By = b
in the least-squares sense. However, a different inner product is used.
In Uzawa’s method, a linear system at each step must be solved, namely, the system (8.31). Solving this system is equivalent to finding the minimum of the quadratic
function
1
(8.34)
minimize fk (x) ≡ (Ax, x) − (x, b − Byk ).
2

8.4. SADDLE-POINT PROBLEMS

271

Apart from constants, fk (x) is the Lagrangian evaluated at the previous y iterate.
The solution of (8.31), or the equivalent optimization problem (8.34), is expensive.
A common alternative replaces the x-variable update (8.31) by taking one step in the
gradient direction for the quadratic function (8.34), usually with fixed step-length ǫ.
The gradient of fk (x) at the current iterate is Axk − (b − Byk ). This results in the
Arrow-Hurwicz Algorithm.
A LGORITHM 8.7 The Arrow-Hurwicz algorithm

1.
2.
3.
4.
5.

Select an initial guess x0 , y0 to the system (8.30)
For k = 0, 1, . . . , until convergence Do:
Compute xk+1 = xk + ǫ(b − Axk − Byk )
Compute yk+1 = yk + ω(B T xk+1 − c)
EndDo

The above algorithm is a block-iteration of the form


 
  

I
O
xk+1
I − ǫA −ǫB
xk
ǫb
=
+
.
−ωB T I
yk+1
O
I
yk
−ωc
Uzawa’s method, and many similar techniques for solving (8.30), are based on
solving the reduced system (8.32). An important observation here is that the Schur
complement matrix S ≡ B T A−1 B need not be formed explicitly. This can be useful
if this reduced system is to be solved by an iterative method. The matrix A is typically
factored by a Cholesky-type factorization. The linear systems with the coefficient
matrix A can also be solved by a preconditioned Conjugate Gradient method. Of
course these systems must then be solved accurately.
Sometimes it is useful to “regularize” the least-squares problem (8.28) by solving
the following problem in its place:
1
(Ax, x) − (x, b) + ρ(Cy, y)
2
subject to B T x = c
minimize f (x) ≡

in which ρ is a scalar parameter. For example, C can be the identity matrix or the
matrix B T B. The matrix resulting from the Lagrange multipliers approach then
becomes


A
B
.
B T ρC

The new Schur complement matrix is

S = ρC − B T A−1 B.
Example 8.2. In the case where C = B T B, the above matrix takes the form
S = B T (ρI − A−1 )B.

272

CHAPTER 8. METHODS RELATED TO THE NORMAL EQUATIONS

Assuming that A is SPD, S is also positive definite when
ρ≥

1
.
λmin (A)

However, it is also negative definite for
ρ≤

1
(A),
λmax

a condition which may be easier to satisfy on practice.

P ROBLEMS
P-8.1 Derive the linear system (8.5) by expressing the standard necessary conditions for the
problem (8.6–8.7).
P-8.2 It was stated in Section 8.2.2 that when kAT ei k2 = 1 for i = 1, . . . , n, the vector d
defined in Algorithm 8.3 is equal to ωAT r.
a. What does this become in the general situation when kAT ei k2 6= 1?

b. Is Cimmino’s method still equivalent to a Richardson iteration?
c. Show convergence results similar to those of the scaled case.

P-8.3 In Section 8.2.2, Cimmino’s algorithm was derived based on the Normal Residual
formulation, i.e., on (8.1). Derive an “NE” formulation, i.e., an algorithm based on Jacobi’s
method for (8.3).
P-8.4 What are the eigenvalues of the matrix (8.5)? Derive a system whose coefficient
matrix has the form


2αI A
B(α) =
.
AT O

and which is also equivalent to the original system Ax = b. What are the eigenvalues of
B(α)? Plot the spectral norm of B(α) as a function of α.

P-8.5 It was argued in Section 8.4 that when c = 0 the system (8.32) is nothing but the
normal equations for minimizing the A−1 -norm of the residual r = b − By.

a. Write the associated CGNR approach for solving this problem. Find a variant that
requires only one linear system solution with the matrix A at each CG step [Hint:
Write the CG algorithm for the associated normal equations and see how the resulting
procedure can be reorganized to save operations]. Find also a variant that is suitable
for the case where the Cholesky factorization of A is available.

b. Derive a method for solving the equivalent system (8.30) for the case when c = 0 and
then for the general case wjen c 6= 0. How does this technique compare with Uzawa’s
method?
P-8.6 Consider the linear system (8.30) in which c = 0 and B is of full rank. Define the
matrix
P = I − B(B T B)−1 B T .

8.4. SADDLE-POINT PROBLEMS

273

a. Show that P is a projector. Is it an orthogonal projector? What are the range and null
spaces of P ?
b. Show that the unknown x can be found by solving the linear system
P AP x = P b,

(8.35)

in which the coefficient matrix is singular but the system is consistent, i.e., there is a
nontrivial solution because the right-hand side is in the range of the matrix (see Chapter
1).
c. What must be done toadapt the Conjugate Gradient Algorithm for solving the above
linear system (which is symmetric, but not positive definite)? In which subspace are
the iterates generated from the CG algorithm applied to (8.35)?
d. Assume that the QR factorization of the matrix B is computed. Write an algorithm
based on the approach of the previous questions for solving the linear system (8.30).
P-8.7 Show that Uzawa’s iteration can be formulated as a fixed-point iteration associated
with the splitting C = M − N with




A
O
O −B
M=
,
N
=
.
−ωB T I
O
I
Derive the convergence result of Corollary 8.1 .
P-8.8 Show that each new vector iterate in Cimmino’s method is such that
X
Pi r,
xnew = x + ωA−1
i

where Pi is defined by (8.24).
P-8.9 In Uzawa’s method a linear system with the matrix A must be solved at each step.
Assume that these systems are solved inaccurately by an iterative process. For each linear
system the iterative process is applied until the norm of the residual rk+1 = (b − Byk ) −
Axk+1 is less than a certain threshold ǫk+1 .
a. Assume that ω is chosen so that (8.33) is satisfied and that ǫk converges to zero as k
tends to infinity. Show that the resulting algorithm converges to the solution.
b. Give an explicit upper bound of the error on yk in the case when ǫi is chosen of the
form ǫ = αi , where α < 1.
P-8.10 Assume kb − Axk2 is to be minimized, in which A is n × m with n > m. Let x∗
be the minimizer and r = b − Ax∗ . What is the minimizer of k(b + αr) − Axk2 , where α is
an arbitrary scalar?
P-8.11
P-8.12 Consider a saddle-point linear system of the form Ax = b, where


 
 
B C
u
f
A=
;
x
=
;
b
=
CT 0
p
0
in which B is symmetric positive definite. It is assumed that A is nonsingular (which is
equivalent to assuming that C is of full rank).
1. Prove that A has
 both negative and positive eigenvalues by showing how to select
u
vectors x = p so that (Ax, x) > 0 and vectors x so that (Ax, x) < 0.

274

CHAPTER 8. METHODS RELATED TO THE NORMAL EQUATIONS


2. Show how to select an initial guess of the form x0 = u00 if we want its corresponding
residual vector r0 = b−Ax0 to be of the form r0 = s00 . What happens if we attempt
to use the steepest descent algorithm with this initial guess?

3. What happens if the Minimal Residual iteration is applied using the same initial guess
as in the previous question?
4. By eliminating the unknown u find a linear system Sp = g that must be satisfied by
the variable p Is the coefficient matrix of this system Symmetric Positive Definite (or
Symmetric Negative Definite)?
5. We now want to solve the linear system by the following iteration:
uk+1

=

pk+1

=

B −1 (f − Cpk )

pk + αk C T uk+1

Show that pk+1 is of the form pk+1 = pk + αk sk where sk is the residual relative
to pk for the reduced linear system found in the previous question. How should αk
be selected if we want pk+1 to correspond to the iterate of steepest descent for this
reduced system.
N OTES AND R EFERENCES . Methods based on the normal equations have been among the first to
be used for solving nonsymmetric linear systems by iterative methods [181, 85]. The work by Bjork
and Elfing [39], and Sameh et al. [182, 53, 52] revived these techniques by showing that they have
some advantages from the implementation point of view, and that they can offer good performance for
a broad class of problems. In addition, they are also attractive for parallel computers. In [240], a few
preconditioning ideas for normal equations were described and these will be covered in Chapter 10. It
would be helpful to be able to determine whether or not it is preferable to use the normal equations approach rather than the “direct equations” for a given system, but this may require an eigenvalue/singular
value analysis.
It is sometimes argued that the normal equations approach is always better than the standard
approach, because it has a quality of robustness which outweighs the additional cost due to the slowness
of the method in the generic elliptic case. Unfortunately, this is not true. Although variants of the
Kaczmarz and Cimmino algorithms deserve a place in any robust iterative solution package, they cannot
be viewed as a panacea. In most realistic examples arising from Partial Differential Equations, the
normal equations route gives rise to much slower convergence than the Krylov subspace approach for
the direct equations. For ill-conditioned problems, these methods will simply fail to converge, unless a
good preconditioner is available.

Chapter 9

PRECONDITIONED ITERATIONS

Although the methods seen in previous chapters are well founded theoretically, they are all likely
to suffer from slow convergence for problems which arise from typical applications such as fluid
dynamics or electronic device simulation. Preconditioning is a key ingredient for the success
of Krylov subspace methods in these applications. This chapter discusses the preconditioned
versions of the iterative methods already seen, but without being specific about the particular preconditioners used. The standard preconditioning techniques will be covered in the next
chapter.

9.1

Introduction

Lack of robustness is a widely recognized weakness of iterative solvers, relative to
direct solvers. This drawback hampers the acceptance of iterative methods in industrial applications despite their intrinsic appeal for very large linear systems. Both
the efficiency and robustness of iterative techniques can be improved by using preconditioning. A term introduced in Chapter 4, preconditioning is simply a means
of transforming the original linear system into one which has the same solution, but
which is likely to be easier to solve with an iterative solver. In general, the reliability of iterative techniques, when dealing with various applications, depends much
more on the quality of the preconditioner than on the particular Krylov subspace accelerators used. We will cover some of these preconditioners in detail in the next
chapter. This chapter discusses the preconditioned versions of the Krylov subspace
algorithms already seen, using a generic preconditioner.
To begin with, it is worthwhile to consider the options available for preconditioning a system. The first step in preconditioning is to find a preconditioning matrix
M . The matrix M can be defined in many different ways but it must satisfy a few
minimal requirements. From a practical point of view, the most requirement for M is
that it is inexpensive to solve linear systems M x = b. This is because the preconditioned algorithms will all require a linear system solution with the matrix M at each
step. Also M should close to A in some sense and it should clearly be nonsingular.
Chapter 10 explores in detail the problem of finding preconditioners M for a given
matrix S, while this chapter considers only the ways in which the preconditioner is
applied to solve the original system.
Once a preconditioning matrix M is available there are three known ways of ap275

276

CHAPTER 9. PRECONDITIONED ITERATIONS

plying the preconditioner. The precondiotioner can be applied from the left, leading
to the preconditioned system
M −1 Ax = M −1 b

(9.1)

Alternatively, it can also be applied to the right:
AM −1 u = b,

x ≡ M −1 u .

(9.2)

Note that the above formulation amounts to making the change of variables u = M x,
and solving the system with respect to the unknown u. Finally, a common situation
is when the preconditioner is available in the factored form
M = ML MR
where, typically ML and MR are triangular matrices. In this situation, the preconditioning can be split:
ML−1 AMR−1 u = ML−1 b,

x ≡ MR−1 u .

(9.3)

It is imperative to preserve symmetry when the original matrix is symmetric, so the
split preconditioner seems mandatory this case. However, there are other ways of preserving symmetry, or rather to take advantage of symmetry, even if M is not available
in a factored form. This is discussed next for the Conjugate Gradient method.

9.2

Preconditioned Conjugate Gradient

Consider a matrix A that is symmetric and positive definite and assume that a preconditioner M is available. The preconditioner M is a matrix which approximates
A in some yet-undefined sense. It is assumed that M is also Symmetric Positive
Definite. Then, one can precondition the system in the three ways shown in the previous section, i.e., as in (9.1), (9.2), or (9.3). Note that the first two systems are no
longer symmetric in general. The next section considers strategies for preserving
symmetry. Then, efficient implementations will be described for particular forms of
the preconditioners.

9.2.1

Preserving Symmetry

When M is available in the form of an incomplete Cholesky factorization, i.e., when
M = LLT ,
then a simple way to preserve symmetry is to use the “split” the preconditioning
option (9.3) which yields the Symmetric Positive Definite matrix,
L−1 AL−T u = L−1 b,

x = L−T u.

(9.4)

9.2. PRECONDITIONED CONJUGATE GRADIENT

277

However, it is not necessary to split the preconditioner in this manner in order to
preserve symmetry. Observe that M −1 A is self-adjoint for the M -inner product,
(x, y)M ≡ (M x, y) = (x, M y)
since
(M −1 Ax, y)M = (Ax, y) = (x, Ay) = (x, M (M −1 A)y) = (x, M −1 Ay)M .
Therefore, an alternative is to replace the usual Euclidean inner product in the Conjugate Gradient algorithm by the M -inner product.
If the CG algorithm is rewritten for this new inner product, denoting by rj =
b − Axj the original residual and by zj = M −1 rj the residual for the preconditioned
system, the following sequence of operations is obtained, ignoring the initial step:
1. αj := (zj , zj )M /(M −1 Apj , pj )M
2. xj+1 := xj + αj pj
3. rj+1 := rj − αj Apj and zj+1 := M −1 rj+1
4. βj := (zj+1 , zj+1 )M /(zj , zj )M
5. pj+1 := zj+1 + βj pj
Since (zj , zj )M = (rj , zj ) and (M −1 Apj , pj )M = (Apj , pj ), the M -inner products
do not have to be computed explicitly. With this observation, the following algorithm
is obtained.
A LGORITHM 9.1 Preconditioned Conjugate Gradient

1.
2.
3.
4.
5.
6.
7.
8.
9.

Compute r0 := b − Ax0 , z0 = M −1 r0 , and p0 := z0
For j = 0, 1, . . . , until convergence Do:
αj := (rj , zj )/(Apj , pj )
xj+1 := xj + αj pj
rj+1 := rj − αj Apj
zj+1 := M −1 rj+1
βj := (rj+1 , zj+1 )/(rj , zj )
pj+1 := zj+1 + βj pj
EndDo

It is interesting to observe that M −1 A is also self-adjoint with respect to the A
inner-product. Indeed,
(M −1 Ax, y)A = (AM −1 Ax, y) = (x, AM −1 Ay) = (x, M −1 Ay)A
and a similar algorithm can be written for this dot product (see Exercise 2).
In the case where M is a Cholesky product M = LLT , two options are available,
namely, the split preconditioning option (9.4), or the above algorithm. An immediate

CHAPTER 9. PRECONDITIONED ITERATIONS

278

question arises about the iterates produced by these two options: Is one better than
the other? Surprisingly, the answer is that the iterates are identical. To see this, start
from Algorithm 9.1 and define the following auxiliary vectors and matrix from it:
p̂j

= LT p j

uj

= L T xj

r̂j

= LT zj = L−1 rj

Â = L−1 AL−T .
Observe that
(rj , zj ) = (rj , L−T L−1 rj ) = (L−1 rj , L−1 rj ) = (r̂j , r̂j ).
Similarly,
(Apj , pj ) = (AL−T p̂j , L−T p̂j )(L−1 AL−T p̂j , p̂j ) = (Âp̂j , p̂j ).
All the steps of the algorithm can be rewritten with the new variables, yielding the
following sequence of operations:
1. αj := (r̂j , r̂j )/(Âp̂j , p̂j )
2. uj+1 := uj + αj p̂j
3. r̂j+1 := r̂j − αj Âp̂j
4. βj := (r̂j+1 , r̂j+1 )/(r̂j , r̂j )
5. p̂j+1 := r̂j+1 + βj p̂j .
This is precisely the Conjugate Gradient algorithm applied to the preconditioned
system
Âu = L−1 b
where u = LT x. It is common when implementing algorithms which involve a right
preconditioner to avoid the use of the u variable, since the iteration can be written
with the original x variable. If the above steps are rewritten with the original x and p
variables, the following algorithm results.
A LGORITHM 9.2 Split Preconditioner Conjugate Gradient

1.
2.
3.
4.
5.
6.
7.
8.

Compute r0 := b − Ax0 ; r̂0 = L−1 r0 ; and p0 := L−T r̂0 .
For j = 0, 1, . . . , until convergence Do:
αj := (r̂j , r̂j )/(Apj , pj )
xj+1 := xj + αj pj
r̂j+1 := r̂j − αj L−1 Apj
βj := (r̂j+1 , r̂j+1 )/(r̂j , r̂j )
pj+1 := L−T r̂j+1 + βj pj
EndDo

9.2. PRECONDITIONED CONJUGATE GRADIENT

279

The iterates xj produced by the above algorithm and Algorithm 9.1 are identical,
provided the same initial guess is used.
Consider now the right preconditioned system (9.2). The matrix AM −1 is not
Hermitian with either the Standard inner product or the M -inner product. However,
it is Hermitian with respect to the M −1 -inner product. If the CG-algorithm is written
with respect to the u-variable and for this new inner product, the following sequence
of operations would be obtained, ignoring again the initial step:
1. αj := (rj , rj )M −1 /(AM −1 pj , pj )M −1
2. uj+1 := uj + αj pj
3. rj+1 := rj − αj AM −1 pj
4. βj := (rj+1 , rj+1 )M −1 /(rj , rj )M −1
5. pj+1 := rj+1 + βj pj .
Recall that the u vectors and the x vectors are related by x = M −1 u. Since the
u vectors are not actually needed, the update for uj+1 in the second step can be
replaced by xj+1 := xj + αj M −1 pj . Then observe that the whole algorithm can be
recast in terms of qj = M −1 pj and zj = M −1 rj .
1. αj := (zj , rj )/(Aqj , qj )
2. xj+1 := xj + αj qj
3. rj+1 := rj − αj Aqj and zj+1 = M −1 rj+1
4. βj := (zj+1 , rj+1 )/(zj , rj )
5. qj+1 := zj+1 + βj qj .
Notice that the same sequence of computations is obtained as with Algorithm
9.1, the left preconditioned Conjugate Gradient. The implication is that the left preconditioned CG algorithm with the M -inner product is mathematically equivalent to
the right preconditioned CG algorithm with the M −1 -inner product.

9.2.2

Efficient Implementations

When applying a Krylov subspace procedure to a preconditioned linear system, an
operation of the form
v → w = M −1 Av
or some similar operation is performed at each step. The most natural way to perform
this operation is to multiply the vector v by A and then apply M −1 to the result.
However, since A and M are related, it is sometimes possible to devise procedures
that are more economical than this straightforward approach. For example, it is often
the case that
M = A−R

280

CHAPTER 9. PRECONDITIONED ITERATIONS

in which the number of nonzero elements in R is much smaller than in A. In this
case, the simplest scheme would be to compute w = M −1 Av as
w = M −1 Av = M −1 (M + R)v = v + M −1 Rv.
This requires that R be stored explicitly. In approximate LU factorization techniques, R is the matrix of the elements that are dropped during the incomplete factorization. An even more efficient variation of the preconditioned Conjugate Gradient
algorithm can be derived for some common forms of the preconditioner in the special
situation where A is symmetric. Write A in the form
A = D0 − E − E T

(9.5)

in which −E is the strict lower triangular part of A and D0 its diagonal. In many
cases, the preconditioner M can be written in the form
M = (D − E)D −1 (D − E T )

(9.6)

in which E is the same as above and D is some diagonal, not necessarily equal to D0 .
For example, in the SSOR preconditioner with ω = 1, D ≡ D0 . Also, for certain
types of matrices, the IC(0) preconditioner can be expressed in this manner, where
D can be obtained by a recurrence formula.
Eisenstat’s implementation consists of applying the Conjugate Gradient algorithm to the linear system
Âu = (D − E)−1 b
(9.7)
with
Â ≡ (D − E)−1 A(D − E T )−1 ,

x = (D − E T )−1 u.

(9.8)

This does not quite correspond to a preconditioning with the matrix (9.6). In order
to produce the same iterates as Algorithm 9.1, the matrix Â must be further preconditioned with the diagonal matrix D −1 . Thus, the preconditioned CG algorithm,
Algorithm 9.1, is actually applied to the system (9.7) in which the preconditioning
operation is M −1 = D. Alternatively, we can initially scale the rows and columns of
the linear system and preconditioning to transform the diagonal to the identity. See
Exercise 7.
Now note that
Â = (D − E)−1 A(D − E T )−1

= (D − E)−1 (D0 − E − E T )(D − E T )−1


= (D − E)−1 D0 − 2D + (D − E) + (D − E T ) (D − E T )−1

≡ (D − E)−1 D1 (D − E T )−1 + (D − E)−1 + (D − E T )−1 ,
in which D1 ≡ D0 − 2D. As a result,


Âv = (D − E)−1 v + D1 (D − E T )−1 v + (D − E T )−1 v.

Thus, the vector w = Âv can be computed by the following procedure:

9.2. PRECONDITIONED CONJUGATE GRADIENT

281

z := (D − E T )−1 v
w := (D − E)−1 (v + D1 z)
w := w + z.
One product with the diagonal D can be saved if the matrices D −1 E and D −1 E T
are stored. Indeed, by setting D̂1 = D −1 D1 and v̂ = D −1 v, the above procedure
can be reformulated as follows.
A LGORITHM 9.3 Computation of w = Âv

1.
2.
3.
4.

v̂ := D −1 v
z := (I − D −1 E T )−1 v̂
w := (I − D −1 E)−1 (v̂ + D̂1 z)
w := w + z .

Note that the matrices D −1 E and D −1 E T are not the transpose of one another, so
we actually need to increase the storage requirement for this formulation if these
matrices are stored. However, there is a more economical variant which works with
the matrix D −1/2 ED −1/2 and its transpose. This is left as Exercise 8.
Denoting by Nz (X) the number of nonzero elements of a sparse matrix X, the
total number of operations (additions and multiplications) of this procedure is n for
(1), 2Nz (E T ) for (2), 2Nz (E) + 2n for (3), and n for (4). The cost of the preconditioning operation by D −1 , i.e., n operations, must be added to this, yielding the total
number of operations:
Nop = n + 2Nz (E) + 2Nz (E T ) + 2n + n + n
= 3n + 2(Nz (E) + Nz (E T ) + n)
= 3n + 2Nz (A).
For the straightforward approach, 2Nz (A) operations are needed for the product with
A, 2Nz (E) for the forward solve, and n + 2Nz (E T ) for the backward solve giving
a total of
2Nz (A) + 2Nz (E) + n + 2Nz (E T ) = 4Nz (A) − n.
Thus, Eisenstat’s scheme is always more economical, when Nz is large enough, although the relative gains depend on the total number of nonzero elements in A. One
disadvantage of this scheme is that it is limited to a special form of the preconditioner.
Example 9.1. For a 5-point finite difference matrix, Nz (A) is roughly 5n, so that
with the standard implementation 19n operations are performed, while with Eisenstat’s implementation only 13n operations would be performed, a savings of about 13 .
However, if the other operations of the Conjugate Gradient algorithm are included,
for a total of about 10n operations, the relative savings become smaller. Now the
original scheme will require 29n operations, versus 23n operations for Eisenstat’s
implementation.

282

9.3

CHAPTER 9. PRECONDITIONED ITERATIONS

Preconditioned GMRES

In the case of GMRES, or other nonsymmetric iterative solvers, the same three
options for applying the preconditioning operation as for the Conjugate Gradient
(namely, left, split, and right preconditioning) are available. However, there will be
one fundamental difference – the right preconditioning versions will give rise to what
is called a flexible variant, i.e., a variant in which the preconditioner can change at
each step. This capability can be very useful in some applications.

9.3.1

Left-Preconditioned GMRES

As before, define the left preconditioned GMRES algorithm, as the GMRES algorithm applied to the system,
M −1 Ax = M −1 b.

(9.9)

The straightforward application of GMRES to the above linear system yields the
following preconditioned version of GMRES.
A LGORITHM 9.4 GMRES with Left Preconditioning

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.

Compute r0 = M −1 (b − Ax0 ), β = kr0 k2 and v1 = r0 /β
For j = 1, . . . , m Do:
Compute w := M −1 Avj
For i = 1, . . . , j , Do:
hi,j := (w, vi )
w := w − hi,j vi
EndDo
Compute hj+1,j = kwk2 and vj+1 = w/hj+1,j
EndDo
Define Vm := [v1 , . . . , vm ], H̄m = {hi,j }1≤i≤j+1;1≤j≤m
Compute ym = argminy kβe1 − H̄m yk2 , and xm = x0 + Vm ym
If satisfied Stop, else set x0 := xm and GoTo 1

The Arnoldi loop constructs an orthogonal basis of the left preconditioned Krylov
subspace
Span{r0 , M −1 Ar0 , . . . , (M −1 A)m−1 r0 }.
It uses a modified Gram-Schmidt process, in which the new vector to be orthogonalized is obtained from the previous vector in the process. All residual vectors and their
norms that are computed by the algorithm correspond to the preconditioned residuals,
namely, zm = M −1 (b − Axm ), instead of the original (unpreconditioned) residuals
b − Axm . In addition, there is no easy access to these unpreconditioned residuals,
unless they are computed explicitly, e.g., by multiplying the preconditioned residuals by M .This can cause some difficulties if a stopping criterion based on the actual
residuals, instead of the preconditioned ones, is desired.

9.3. PRECONDITIONED GMRES

283

Sometimes a Symmetric Positive Definite preconditioning M for the nonsymmetric matrix A may be available. For example, if A is almost SPD, then (9.9)
would not take advantage of this. It would be wiser to compute an approximate factorization to the symmetric part and use GMRES with split preconditioning. This
raises the question as to whether or not a version of the preconditioned GMRES can
be developed, which is similar to Algorithm 9.1, for the CG algorithm. This version
would consist of using GMRES with the M -inner product for the system (9.9).
At step j of the preconditioned GMRES algorithm, the previous vj is multiplied
by A to get a vector
wj = Avj .
(9.10)
Then this vector is preconditioned to get
zj = M −1 wj .

(9.11)

This vector must be M -orthogonalized against all previous vi ’s. If the standard
Gram-Schmidt process is used, we first compute the inner products
hij = (zj , vi )M = (M zj , vi ) = (wj , vi ), i = 1, . . . , j,

(9.12)

and then modify the vector zj into the new vector
ẑj

:= zj −

j
X

hij vi .

(9.13)

i=1

To complete the orthonormalization step, the final ẑj must be normalized. Because
of the orthogonality of ẑj versus all previous vi ’s, observe that
(ẑj , ẑj )M = (zj , ẑj )M = (M −1 wj , ẑj )M = (wj , ẑj ).

(9.14)

Thus, the desired M -norm could be obtained from (9.14), and then we would set
hj+1,j := (ẑj , wj )1/2

and

vj+1 = ẑj /hj+1,j .

(9.15)

One serious difficulty with the above procedure is that the inner product (ẑj , ẑj )M
as computed by (9.14) may be negative in the presence of round-off. There are two
remedies. First, this M -norm can be computed explicitly at the expense of an additional matrix-vector multiplication with M . Second, the set of vectors M vi can be
saved in order to accumulate inexpensively both the vector ẑj and the vector M ẑj ,
via the relation
j
X
hij M vi .
M ẑj = wj −
i=1

A modified Gram-Schmidt version of this second approach can be derived easily.
The details of the algorithm are left as Exercise 13.

284

9.3.2

CHAPTER 9. PRECONDITIONED ITERATIONS

Right-Preconditioned GMRES

The right preconditioned GMRES algorithm is based on solving
AM −1 u = b,

u = M x.

(9.16)

As we now show, the new variable u never needs to be invoked explicitly. Indeed,
once the initial residual b − Ax0 = b − AM −1 u0 is computed, all subsequent vectors
of the Krylov subspace can be obtained without any reference to the u-variables.
Note that u0 is not needed at all. The initial residual for the preconditioned system
can be computed from r0 = b − Ax0 , which is the same as b − AM −1 u0 . In practice,
it is usually x0 that is available, not u0 . At the end, the u-variable approximate
solution to (9.16) is given by,
um = u0 +

m
X

vi ηi

i=1

with u0 = M x0 . Multiplying through by M −1 yields the desired approximation in
terms of the x-variable,
#
"m
X
vi ηi .
xm = x0 + M −1
i=1

Thus, one preconditioning operation is needed at the end of the outer loop, instead
of at the beginning in the case of the left preconditioned version.
A LGORITHM 9.5 GMRES with Right Preconditioning

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.

Compute r0 = b − Ax0 , β = kr0 k2 , and v1 = r0 /β
For j = 1, . . . , m Do:
Compute w := AM −1 vj
For i = 1, . . . , j , Do:
hi,j := (w, vi )
w := w − hi,j vi
EndDo
Compute hj+1,j = kwk2 and vj+1 = w/hj+1,j
Define Vm := [v1 , . . . , vm ], H̄m = {hi,j }1≤i≤j+1;1≤j≤m
EndDo
Compute ym = argminy kβe1 − H̄m yk2 , and xm = x0 + M −1 Vm ym .
If satisfied Stop, else set x0 := xm and GoTo 1.

This time, the Arnoldi loop builds an orthogonal basis of the right preconditioned
Krylov subspace
Span{r0 , AM −1 r0 , . . . , (AM −1 )m−1 r0 }.
Note that the residual norm is now relative to the initial system, i.e., b − Axm , since
the algorithm obtains the residual b − Axm = b − AM −1 um , implicitly. This is an
essential difference with the left preconditioned GMRES algorithm.

9.3. PRECONDITIONED GMRES

9.3.3

285

Split Preconditioning

In many cases, M is the result of a factorization of the form
M = LU.
Then, there is the option of using GMRES on the split-preconditioned system
L−1 AU −1 u = L−1 b,

x = U −1 u.

In this situation, it is clear that we need to operate on the initial residual by L−1 at
the start of the algorithm and by U −1 on the linear combination Vm ym in forming
the approximate solution. The residual norm available is that of L−1 (b − Axm ).
A question arises on the differences between the right, left, and split preconditioning options. The fact that different versions of the residuals are available in each
case may affect the stopping criterion and may cause the algorithm to stop either
prematurely or with delay. This can be particularly damaging in case M is very
ill-conditioned. The degree of symmetry, and therefore performance, can also be
affected by the way in which the preconditioner is applied. For example, a split
preconditioner may be much better if A is nearly symmetric. Other than these two
situations, there is little difference generally between the three options. The next
section establishes a theoretical connection between left and right preconditioned
GMRES.

9.3.4

Comparison of Right and Left Preconditioning

When comparing the left, right, and split preconditioning options, a first observation to make is that the spectra of the three associated operators M −1 A, AM −1 , and
L−1 AU −1 are identical. Therefore, in principle one should expect convergence to
be similar, although, as is known, eigenvalues do not always govern convergence. In
this section, we compare the optimality properties achieved by left- and right preconditioned GMRES.
For the left preconditioning option, GMRES minimizes the residual norm
kM −1 b − M −1 Axk2 ,
among all vectors from the affine subspace
L
x0 + Km
= x0 + Span {z0 , M −1 Az0 , . . . , (M −1 A)m−1 z0 }

(9.17)

in which z0 is the initial preconditioned residual z0 = M −1 r0 . Thus, the approximate solution can be expressed as
xm = x0 + M −1 sm−1 (M −1 A)z0
where sm−1 is the polynomial of degree m − 1 which minimizes the norm
kz0 − M −1 A s(M −1 A)z0 k2

286

CHAPTER 9. PRECONDITIONED ITERATIONS

among all polynomials s of degree ≤ m − 1. It is also possible to express this
optimality condition with respect to the original residual vector r0 . Indeed,


z0 − M −1 A s(M −1 A)z0 = M −1 r0 − A s(M −1 A)M −1 r0 .
A simple algebraic manipulation shows that for any polynomial s,
s(M −1 A)M −1 r = M −1 s(AM −1 )r,

(9.18)

from which we obtain the relation


z0 − M −1 As(M −1 A)z0 = M −1 r0 − AM −1 s(AM −1 )r0 .

(9.19)

Consider now the situation with the right preconditioned GMRES. Here, it is
necessary to distinguish between the original x variable and the transformed variable
u related to x by x = M −1 u. For the u variable, the right preconditioned GMRES
process minimizes the 2-norm of r = b − AM −1 u where u belongs to
R
u0 + Km
= u0 + Span {r0 , AM −1 r0 , . . . , (AM −1 )m−1 r0 }

(9.20)

in which r0 is the residual r0 = b − AM −1 u0 . This residual is identical to the residual associated with the original x variable since M −1 u0 = x0 . Multiplying (9.20)
through to the left by M −1 and exploiting again (9.18), observe that the generic variable x associated with a vector of the subspace (9.20) belongs to the affine subspace
R
M −1 u0 + M −1 Km
= x0 + Span {z0 , M −1 Az0 . . . , (M −1 A)m−1 z0 }.

This is identical to the affine subspace (9.17) invoked in the left preconditioned variant. In other words, for the right preconditioned GMRES, the approximate x-solution
can also be expressed as
xm = x0 + sm−1 (AM −1 )r0 .
However, now sm−1 is a polynomial of degree m − 1 which minimizes the norm
kr0 − AM −1 s(AM −1 )r0 k2

(9.21)

among all polynomials s of degree ≤ m − 1. What is surprising is that the two
quantities which are minimized, namely, (9.19) and (9.21), differ only by a multiplication by M −1 . Specifically, the left preconditioned GMRES minimizes M −1 r,
whereas the right preconditioned variant minimizes r, where r is taken over the same
subspace in both cases.
Proposition 9.1 The approximate solution obtained by left or right preconditioned
GMRES is of the form
xm = x0 + sm−1 (M −1 A)z0 = x0 + M −1 sm−1 (AM −1 )r0
where z0 = M −1 r0 and sm−1 is a polynomial of degree m − 1. The polynomial
sm−1 minimizes the residual norm kb − Axm k2 in the right preconditioning case,
and the preconditioned residual norm kM −1 (b − Axm )k2 in the left preconditioning
case.

9.4. FLEXIBLE VARIANTS

287

In most practical situations, the difference in the convergence behavior of the
two approaches is not significant. The only exception is when M is ill-conditioned
which could lead to substantial differences.

9.4

Flexible Variants

In the discussion of preconditioning techniques so far, it is implicitly assumed that
the preconditioning matrix M is fixed, i.e., it does not change from step to step.
However, in some cases, no matrix M is available. Instead, the operation M −1 x is
the result of some unspecified computation, possibly another iterative process. In
such cases, it may well happen that M −1 is not a constant operator. The previous
preconditioned iterative procedures will not converge if M is not constant. There
are a number of variants of iterative procedures developed in the literature that can
accommodate variations in the preconditioner, i.e., that allow the preconditioner to
vary from step to step. Such iterative procedures are called “flexible” iterations. One
of these iterations, a flexible variant of the GMRES algorithm, is described next.

9.4.1

Flexible GMRES

We begin by examining the right preconditioned GMRES algorithm. In line 11 of
Algorithm 9.5 the approximate solution xm is expressed as a linear combination
of the preconditioned vectors zi = M −1 vi , i = 1, . . . , m. These vectors are also
computed in line 3, prior to their multiplication by A to obtain the vector w. They
are all obtained by applying the same preconditioning matrix M −1 to the vi ’s. As a
result it is not necessary to save them. Instead, we only need to apply M −1 to the
linear combination of the vi ’s, i.e., to Vm ym in line 11.
Suppose now that the preconditioner could change at every step, i.e., that zj is
given by
zj = Mj−1 vj .
Then it would be natural to compute the approximate solution as
x m = x 0 + Zm y m
in which Zm = [z1 , . . . , zm ], and ym is computed as before, as the solution to the
least-squares problem in line 11. These are the only changes that lead from the right
preconditioned algorithm to the flexible variant, described below.
A LGORITHM 9.6 Flexible GMRES (FGMRES)

1.
2.
3.
4.
5.
6.
7.

Compute r0 = b − Ax0 , β = kr0 k2 , and v1 = r0 /β
For j = 1, . . . , m Do:
Compute zj := Mj−1 vj
Compute w := Azj
For i = 1, . . . , j , Do:
hi,j := (w, vi )
w := w − hi,j vi

CHAPTER 9. PRECONDITIONED ITERATIONS

288

8.
9.
10.
11.
12.
13.

EndDo
Compute hj+1,j = kwk2 and vj+1 = w/hj+1,j
Define Zm := [z1 , . . . , zm ], H̄m = {hi,j }1≤i≤j+1;1≤j≤m
EndDo
Compute ym = argminy kβe1 − H̄m yk2 , and xm = x0 + Zm ym .
If satisfied Stop, else set x0 ← xm and GoTo 1.

As can be seen, the main difference with the right preconditioned version, Algorithm 9.5, is that the preconditioned vectors zj = Mj−1 vj must be saved and the
solution updated using these vectors. It is clear that when Mj = M for j = 1, . . . , m,
then this method is equivalent mathematically to Algorithm 9.5. It is important to observe that zj can be defined in line 3 without reference to any preconditioner. That
is, any given new vector zj can be chosen. This added flexibility may cause the algorithm some problems. Indeed, zj may be so poorly selected that a breakdown could
occur, as in the worst-case scenario when zj is zero.
One difference between FGMRES and the usual GMRES algorithm is that the
action of AMj−1 on a vector v of the Krylov subspace is no longer in the span of
Vm+1 . Instead, it is easy to show that
AZm = Vm+1 H̄m

(9.22)

in replacement of the simpler relation (AM −1 )Vm = Vm+1 H̄m which holds for
the standard preconditioned GMRES; see (6.7). As before, Hm denotes the m × m
matrix obtained from H̄m by deleting its last row and v̂j+1 is the vector w which is
normalized in line 9 of Algorithm 9.6 to obtain vj+1 . Then, the following alternative
formulation of (9.22) is valid, even when hm+1,m = 0:
AZm = Vm Hm + v̂m+1 eTm .

(9.23)

An optimality property similar to the one which defines GMRES can be proved.
Consider the residual vector for an arbitrary vector z = x0 + Zm y in the affine space
x0 + span{Zm }. This optimality property is based on the relations
b − Az = b − A(x0 + Zm y)
= r0 − AZm y

(9.24)

= Vm+1 [βe1 − H̄m y].

(9.25)

= βv1 − Vm+1 H̄m y
If Jm (y) denotes the function

Jm (y) = kb − A[x0 + Zm y]k2 ,
observe that by (9.25) and the fact that Vm+1 is unitary,
Jm (y) = kβe1 − H̄m yk2 .

(9.26)

Since the algorithm minimizes this norm over all vectors u in Rm to yield ym , it is
clear that the approximate solution xm = x0 + Zm ym has the smallest residual norm
in x0 + Span{Zm }. Thus, the following result is proved.

9.4. FLEXIBLE VARIANTS

289

Proposition 9.2 The approximate solution xm obtained at step m of FGMRES minimizes the residual norm kb − Axm k2 over x0 + Span{Zm }.
Next, consider the possibility of breakdown in FGMRES. A breakdown occurs when the vector vj+1 cannot be computed in line 9 of Algorithm 9.6 because
hj+1,j = 0. For the standard GMRES algorithm, this is not a problem because when
this happens then the approximate solution xj is exact. The situation for FGMRES
is slightly different.
Proposition 9.3 Assume that β = kr0 k2 6= 0 and that j − 1 steps of FGMRES have
been successfully performed, i.e., that hi+1,i 6= 0 for i < j. In addition, assume that
the matrix Hj is nonsingular. Then xj is exact, if and only if hj+1,j = 0.
Proof. If hj+1,j = 0, then AZj = Vj Hj , and as a result
Jj (y) = kβv1 − AZj yj k2 = kβv1 − Vj Hj yj k2 = kβe1 − Hj yj k2 .
If Hj is nonsingular, then the above function is minimized for yj = Hj−1 (βe1 ) and
the corresponding minimum norm reached is zero, i.e., xj is exact.
Conversely, if xj is exact, then from (9.23) and (9.24),
0 = b − Axj = Vj [βe1 − Hj yj ] + v̂j+1 eTj yj .

(9.27)

We must show, by contraction, that v̂j+1 = 0. Assume that v̂j+1 6= 0. Since v̂j+1 ,
v1 , v2 , . . ., vm , form an orthogonal system, then it follows from (9.27) that βe1 −
Hj yj = 0 and eTj yj = 0. The last component of yj is equal to zero. A simple backsubstitution for the system Hj yj = βe1 , starting from the last equation, will show
that all components of yj are zero. Because Hm is nonsingular, this would imply that
β = 0 and contradict the assumption.
The only difference between this result and that of Proposition 6.10 for the GMRES algorithm is that the additional assumption must be made that Hj is nonsingular
since it is no longer implied by the nonsingularity of A. However, Hm is guaranteed
to be nonsingular when all the zj ’s are linearly independent and A is nonsingular.
This is a consequence of a modification of the first part of Proposition 6.9. That same
proof shows that the rank of AZm is equal to the rank of the matrix Rm therein. If
Rm is nonsingular and hm+1,m = 0, then Hm is also nonsingular.
A consequence of the above proposition is that if Azj = vj , at a certain step, i.e.,
if the preconditioning is “exact,” then the approximation xj will be exact provided
that Hj is nonsingular. This is because w = Azj would depend linearly on the
previous vi ’s (it is equal to vj ), and as a result the orthogonalization process would
yield v̂j+1 = 0.
A difficulty with the theory of the new algorithm is that general convergence
results, such as those seen in earlier chapters, cannot be proved. That is because the
subspace of approximants is no longer a standard Krylov subspace. However, the

CHAPTER 9. PRECONDITIONED ITERATIONS

290

optimality property of Proposition 9.2 can be exploited in some specific situations.
For example, if within each outer iteration at least one of the vectors zj is chosen to
be a steepest descent direction vector, e.g., for the function F (x) = kb − Axk22 , then
FGMRES is guaranteed to converge independently of m.
The additional cost of the flexible variant over the standard algorithm is only in
the extra memory required to save the set of vectors {zj }j=1,...,m . Yet, the added
advantage of flexibility may be worth this extra cost. A few applications can benefit
from this flexibility, especially in developing robust iterative methods or preconditioners on parallel computers. Thus, any iterative technique can be used as a preconditioner: block-SOR, SSOR, ADI, Multi-grid, etc. More interestingly, iterative
procedures such as GMRES, CGNR, or CGS can also be used as preconditioners.
Also, it may be useful to mix two or more preconditioners to solve a given problem.
For example, two types of preconditioners can be applied alternatively at each FGMRES step to mix the effects of “local” and “global” couplings in the PDE context.

9.4.2

DQGMRES

Recall that the DQGMRES algorithm presented in Chapter 6 uses an incomplete
orthogonalization process instead of the full Arnoldi orthogonalization. At each step,
the current vector is orthogonalized only against the k previous ones. The vectors
thus generated are “locally” orthogonal to each other, in that (vi , vj ) = δij for |i −
j| < k. The matrix H̄m becomes banded and upper Hessenberg. Therefore, the
approximate solution can be updated at step j from the approximate solution at step
j − 1 via the recurrence


j−1
X
1 
vj −
rij pi  , xj = xj−1 + γj pj
(9.28)
pj =
rjj
i=j−k+1

in which the scalars γj and rij are obtained recursively from the Hessenberg matrix
H̄j .
An advantage of DQGMRES is that it is also flexible. The principle is the same
as in FGMRES. In both cases the vectors zj = Mj−1 vj must be computed. In the
case of FGMRES, these vectors must be saved and this requires extra storage. For
DQGMRES, it can be observed that the preconditioned vectors zj only affect the
update of the vector pj in the preconditioned version of the update formula (9.28),
yielding


j−1
X
1  −1
rij pi  .
pj =
Mj vj −
rjj
i=j−k+1

As a result, Mj−1 vj can be discarded immediately after it is used to update pj . The
same memory locations can store this vector and the vector pj . This contrasts with
FGMRES which requires additional vectors of storage.

9.5. PRECONDITIONED CG FOR THE NORMAL EQUATIONS

9.5

291

Preconditioned CG for the Normal Equations

There are several versions of the preconditioned Conjugate Gradient method applied
to the normal equations. Two versions come from the NR/NE options, and three other
variations from the right, left, or split preconditioning options. Here, we consider
only the left preconditioned variants.
The left preconditioned CGNR algorithm is easily derived from Algorithm 9.1.
Denote by rj the residual for the original system, i.e., rj = b − Axj , and by r̃j =
AT rj the residual for the normal equations system. The preconditioned residual zj
is zj = M −1 r̃j . The scalar αj in Algorithm 9.1 is now given by
αj =

(r̃j , zj )
(r̃j , zj )
=
.
T
(A Apj , pj )
(Apj , Apj )

This suggests employing the auxiliary vector wj = Apj in the algorithm which takes
the following form.
A LGORITHM 9.7 Left-Preconditioned CGNR

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

Compute r0 = b − Ax0 , r̃0 = AT r0 , z0 = M −1 r̃0 , p0 = z0 .
For j = 0, . . ., until convergence Do:
wj = Apj
αj = (zj , r̃j )/kwj k22
xj+1 = xj + αj pj
rj+1 = rj − αj wj
r̃j+1 = AT rj+1
zj+1 = M −1 r̃j+1
βj = (zj+1 , r̃j+1 )/(zj , r̃j )
pj+1 = zj+1 + βj pj
EndDo

Similarly, the linear system AAT u = b, with x = AT u, can also be preconditioned from the left, and solved with the preconditioned Conjugate Gradient algorithm. Here, it is observed that the update of the u variable, the associated x variable,
and two residuals take the form
(rj , zj )
(rj , zj )
=
αj =
T
T
(AA pj , pj )
(A pj , AT pj )
uj+1 = uj + αj pj ↔ xj+1 = xj + αj AT pj
rj+1 = rj − αj AAT pj

zj+1 = M −1 rj+1

Thus, if the algorithm for the unknown x is to be written, then the vectors AT pj can
be used instead of the vectors pj , which are not needed. To update these vectors at
the end of the algorithm the relation pj+1 = zj+1 + βj+1 pj in line 8 of Algorithm
9.1 must be multiplied through by AT . This leads to the left preconditioned version
of CGNE, in which the notation has been changed to denote by pj the vector AT pj
invoked in the above derivation.

292

CHAPTER 9. PRECONDITIONED ITERATIONS

A LGORITHM 9.8 Left-Preconditioned CGNE

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Compute r0 = b − Ax0 , z0 = M −1 r0 , p0 = AT z0 .
For j = 0, 1, . . . , until convergence Do:
wj = Apj
αj = (zj , rj )/(pj , pj )
xj+1 = xj + αj pj
rj+1 = rj − αj wj
zj+1 = M −1 rj+1
βj = (zj+1 , rj+1 )/(zj , rj )
pj+1 = AT zj+1 + βj pj
EndDo

Not shown here are the right and split preconditioned versions which are considered
in Exercise 4.

9.6

The Concus, Golub, and Widlund Algorithm

When the matrix is nearly symmetric, we can think of preconditioning the system
with the symmetric part of A. This gives rise to a few variants of a method known as
the CGW method, from the names of the three authors Concus and Golub [88], and
Widlund [313] who proposed this technique in the middle of the 1970s. Originally,
the algorithm was not viewed from the angle of preconditioning. Writing A = M −
N , with M = 21 (A + AH ), the authors observed that the preconditioned matrix
M −1 A = I − M −1 N
is equal to the identity matrix, plus a matrix which is skew-Hermitian with respect
to the M -inner product. It is not too difficult to show that the tridiagonal matrix
corresponding to the Lanczos algorithm, applied to A with the M -inner product, has
the form


1 −η2
 η2

1
−η3


.
Tm = 
.
.
.
(9.29)




ηm−1 1 −ηm
ηm
1
As a result, a three-term recurrence in the Arnoldi process is obtained, which results
in a solution algorithm that resembles the standard preconditioned CG algorithm
(Algorithm 9.1).
A version of the algorithm can be derived easily. The developments in Section
6.7 relating the Lanczos algorithm to the Conjugate Gradient algorithm, show that
the vector xj+1 can be expressed as
xj+1 = xj + αj pj .
The preconditioned residual vectors must then satisfy the recurrence
zj+1 = zj − αj M −1 Apj

9.6. THE CONCUS, GOLUB, AND WIDLUND ALGORITHM

293

and if the zj ’s are to be M -orthogonal, then we must have (zj −αj M −1 Apj , zj )M =
0. As a result,
(rj , zj )
(zj , zj )M
=
.
αj =
−1
(M Apj , zj )M
(Apj , zj )
Also, the next search direction pj+1 is a linear combination of zj+1 and pj ,
pj+1 = zj+1 + βj pj .
Since M −1 Apj is orthogonal to all vectors in Kj−1 , a first consequence is that
(Apj , zj ) = (M −1 Apj , pj − βj−1 pj−1 )M = (M −1 Apj , pj )M = (Apj , pj ).
In addition, M −1 Apj+1 must be M -orthogonal to pj , so that
βj = −(M −1 Azj+1 , pj )M /(M −1 Apj , pj )M .
The relation M −1 A = I − M −1 N , the fact that N H = −N , and that (zj+1 , pj )M =
0 yield,
(M −1 Azj+1 , pj )M

= −(M −1 N zj+1 , pj )M = (zj+1 , M −1 N pj )M
= −(zj+1 , M −1 Apj )M .

Finally, note that M −1 Apj = − α1j (zj+1 − zj ) and therefore we have (note the sign
difference with the standard PCG algorithm)
βj = −

(zj+1 , rj+1 )
(zj+1 , zj+1 )M
.
=−
(zj , zj )M
(zj , rj )

P ROBLEMS
P-9.1 Show that the preconditioned matrix has the same eigenvalues for all three preconditioning options (left, right, and split) described in Section 9.1
P-9.2 Let a matrix A and its preconditioner M be SPD. Observing that M −1 A is selfadjoint with respect to the A inner-product, write an algorithm similar to Algorithm 9.1 for
solving the preconditioned linear system M −1 Ax = M −1 b, using the A-inner product. The
algorithm should employ only one matrix-by-vector product per CG step.
P-9.3 In Section 9.2.1, the split-preconditioned Conjugate Gradient algorithm, Algorithm
9.2, was derived from the Preconditioned Conjugate Gradient Algorithm 9.1. The opposite
can also be done. Derive Algorithm 9.1 starting from Algorithm 9.2, providing a different
proof of the equivalence of the two algorithms.
P-9.4 Six versions of the CG algorithm applied to the normal equations can be defined. Two
versions come from the NR/NE options, each of which can be preconditioned from left, right,
or on two sides. The left preconditioned variants have been given in Section 9.5. Describe the
four other versions: Right P-CGNR, Right P-CGNE, Split P-CGNR, Split P-CGNE. Suitable
inner products may be used to preserve symmetry.

CHAPTER 9. PRECONDITIONED ITERATIONS

294

P-9.5 When preconditioning the normal equations, whether the NE or NR form, two options
are available in addition to the left, right and split preconditioners. These are “centered”
versions:
AM −1 AT u = b, x = M −1 AT u
for the NE form, and
AT M −1 Ax = AT M −1 b
for the NR form. The coefficient matrices in the above systems are all symmetric. Write
down the adapted versions of the CG algorithm for these options.
P-9.6 Let a matrix A and its preconditioner M be SPD. The standard result about the rate
of convergence of the CG algorithm is not valid for the Preconditioned Conjugate Gradient
algorithm, Algorithm 9.1. Show how to adapt this result by exploiting the M -inner product.
Show how to derive the same result by using the equivalence between Algorithm 9.1 and
Algorithm 9.2.
P-9.7 In Eisenstat’s implementation of the PCG algorithm, the operation with the diagonal
D causes some difficulties when describing the algorithm. This can be avoided.
a. Assume that the diagonal D of the preconditioning (9.6) is equal to the identity matrix. How many operations are needed to perform one step of the PCG algorithm with
Eisenstat’s implementation? Formulate the PCG scheme for this case carefully.
b. The rows and columns of the preconditioning matrix M can be scaled so that the matrix
D of the transformed preconditioner, written in the form (9.6), is equal to the identity
matrix. What scaling should be used (the resulting M should also be SPD)?
c. Assume that the same scaling of question b is also applied to the original matrix A.
Is the resulting iteration mathematically equivalent to using Algorithm 9.1 to solve the
system (9.7) preconditioned with the diagonal D?
P-9.8 In order to save operations, the two matrices D−1 E and D−1 E T must be stored when
computing Âv by Algorithm 9.3. This exercise considers alternatives.
a. Consider the matrix B ≡ DÂD. Show how to implement an algorithm similar to 9.3
for multiplying a vector v by B. The requirement is that only ED−1 must be stored.
b. The matrix B in the previous question is not the proper preconditioned version of A by
the preconditioning (9.6). CG is used on an equivalent system involving B but a further
preconditioning by a diagonal must be applied. Which one? How does the resulting
algorithm compare in terms of cost and storage with an Algorithm based on 9.3?
c. It was mentioned in Section 9.2.2 that Â needed to be further preconditioned by D−1 .
Consider the split-preconditioning option: CG is to be applied to the preconditioned
system associated with C = D1/2 ÂD1/2 . Defining Ê = D−1/2 ED−1/2 show that,
C = (I − Ê)−1 D2 (I − Ê)−T + (I − Ê)−1 + (I − Ê)−T
where D2 is a certain matrix to be determined. Then write an analogue of Algorithm 9.3 using this formulation. How does the operation count compare with that
of Algorithm 9.3?
P-9.9 Assume that the number of nonzero elements of a matrix A is parameterized by
N z(Z) = αn. How small should α be before it does not pay to use Eisenstat’s implementation for the PCG algorithm? What if the matrix A is initially scaled so that D is the
identity matrix?

9.6. THE CONCUS, GOLUB, AND WIDLUND ALGORITHM

295

P-9.10 Let M = LU be a preconditioner for a matrix A. Show that the left, right, and
split preconditioned matrices all have the same eigenvalues. Does this mean that the corresponding preconditioned iterations will converge in (a) exactly the same number of steps?
(b) roughly the same number of steps for any matrix? (c) roughly the same number of steps,
except for ill-conditioned matrices?
P-9.11 Show that the relation (9.18) holds for any polynomial s and any vector r.
P-9.12 Write the equivalent of Algorithm 9.1 for the Conjugate Residual method.
P-9.13 Assume that a Symmetric Positive Definite matrix M is used to precondition GMRES for solving a nonsymmetric linear system. The main features of the P-GMRES algorithm exploiting this were given in Section 9.2.1. Give a formal description of the algorithm.
In particular give a Modified Gram-Schimdt implementation. [Hint: The vectors M vi ’s must
be saved in addition to the vi ’s.] What optimality property does the approximate solution satisfy? What happens if the original matrix A is also symmetric? What is a potential advantage
of the resulting algorithm?
N OTES AND R EFERENCES . The preconditioned version of CG described in Algorithm 9.1 is due to
Meijerink and van der Vorst [208]. Eisenstat’s implementation was developed in [114] and is often
referred to as Eisenstat’s trick. A number of other similar ideas are described in [217].
Several flexible variants of nonsymmetric Krylov subspace methods have been developed by several authors simultaneously; see, e.g., [22], [247], and [291]. There does not seem to exist a similar
technique for left preconditioned variants of the Krylov subspace methods. This is because the righthand side Mj−1 b of the preconditioned system now changes at each step. A rigorous flexible variant
of the BCG methods cannot be developed because the short recurrences of these algorithms rely on the
preconditioned operator being constant. However, it is possible to develop an analogue of DQGMRES
for QMR (or other quasi-minimization methods) using identical arguments, see e.g., [282], though,
as is expected, the global biorthogonality of the Lanczos basis vectors is sacrificed. Similarly, flexible variants of the CG method have been developed by sacrificing global optimality properties but
by tightening the flexibilty of the preconditioner, in an attempt to preserve good, possibly superlinear,
convergence; see [214] and [153].
The CGW algorithm can be useful in some instances, such as when the symmetric part of A can
be inverted easily, e.g., using fast Poisson solvers. Otherwise, its weakness is that linear systems with
the symmetric part must be solved exactly. Inner-outer variations that do not require exact solutions
have been described by Golub and Overton [150].

296

CHAPTER 9. PRECONDITIONED ITERATIONS

Chapter 10

PRECONDITIONING TECHNIQUES

Finding a good preconditioner to solve a given sparse linear system is often viewed as a combination of art and science. Theoretical results are rare and some methods work surprisingly
well, often despite expectations. A preconditioner can be defined as any subsidiary approximate
solver which is combined with an outer iteration technique, typically one of the Krylov subspace
iterations seen in previous chapters. This chapter covers some of the most successful techniques
used to precondition a general sparse linear system. Note at the outset that there are virtually
no limits to available options for obtaining good preconditioners. For example, preconditioners
can be derived from knowledge of the original physical problems from which the linear system
arises. However, a common feature of the preconditioners discussed in this chapter is that they
are built from the original coefficient matrix.

10.1

Introduction

Roughly speaking, a preconditioner is any form of implicit or explicit modification of
an original linear system which makes it “easier” to solve by a given iterative method.
For example, scaling all rows of a linear system to make the diagonal elements equal
to one is an explicit form of preconditioning. The resulting system can be solved by
a Krylov subspace method and may require fewer steps to converge than with the
original system (although this is not guaranteed). As another example, solving the
linear system
M −1 Ax = M −1 b
where M −1 is some complicated mapping that may involve FFT transforms, integral calculations, and subsidiary linear system solutions, may be another form of
preconditioning. Here, it is unlikely that the matrix M and M −1 A can be computed
explicitly. Instead, the iterative processes operate with A and with M −1 whenever
needed. In practice, the preconditioning operation M −1 should be inexpensive to
apply to an arbitrary vector.
One of the simplest ways of defining a preconditioner is to perform an incomplete
factorization of the original matrix A. This entails a decomposition of the form
A = LU − R where L and U have the same nonzero structure as the lower and
upper parts of A respectively, and R is the residual or error of the factorization. This
incomplete factorization known as ILU(0) is rather easy and inexpensive to compute.
On the other hand, it often leads to a crude approximation which may result in the
297

CHAPTER 10. PRECONDITIONING TECHNIQUES

298

Krylov subspace accelerator requiring
many iterations to converge. To remedy this, several alternative incomplete factorizations have been developed by allowing more fill-in in L and U . In general, the
more accurate ILU factorizations require fewer iterations to converge, but the preprocessing cost to compute the factors is higher. However, if only because of the
improved robustness, these trade-offs generally favor the more accurate factorizations. This is especially true when several systems with the same matrix must be
solved because the preprocessing cost can be amortized.
This chapter considers the most common preconditioners used for solving large
sparse matrices and compares their performance. It begins with the simplest preconditioners (SOR and SSOR) and then discusses the more accurate variants such as
ILUT.

10.2

Jacobi, SOR, and SSOR Preconditioners

As was seen in Chapter 4, a fixed-point iteration for solving a linear system
Ax = b
takes the general form
xk+1 = M −1 N xk + M −1 b

(10.1)

where M and N realize the splitting of A into
A = M − N.

(10.2)

xk+1 = Gxk + f

(10.3)

The above iteration is of the form

where f = M −1 b and
G = M −1 N = M −1 (M − A)
= I − M −1 A.

(10.4)

Thus, for Jacobi and Gauss Seidel it has been shown that
GJA (A) = I − D −1 A

(10.5)
−1

GGS (A) = I − (D − E)

A,

(10.6)

where A = D − E − F is the splitting defined in Chapter 4.
The iteration (10.3) is attempting to solve
(I − G)x = f

(10.7)

which, because of the expression (10.4) for G, can be rewritten as
M −1 Ax = M −1 b.

(10.8)

10.2. JACOBI, SOR, AND SSOR PRECONDITIONERS

299

The above system is the preconditioned system associated with the splitting A =
M − N , and the iteration (10.3) is nothing but a fixed-point iteration on this preconditioned system.
Similarly, a Krylov subspace method, e.g., GMRES, can be used to solve (10.8),
leading to a preconditioned version of the Krylov subspace method, e.g., preconditioned GMRES. The preconditioned versions of some Krylov subspace methods
have been discussed in the previous chapter with a generic preconditioner M . In
theory, any general splitting in which M is nonsingular can be used. Ideally, M
should be close to A in some sense. However, note that a linear system with the matrix M must be solved at each step of the iterative procedure. Therefore, a practical
and admittedly somewhat vague requirement is that these solutions steps should be
inexpensive.
As was seen in Chapter 4, the SSOR preconditioner is defined by
MSSOR = (D − ωE)D −1 (D − ωF ).
Typically, when this matrix is used as a preconditioner, it is not necessary to choose
ω as carefully as for the underlying fixed-point iteration. Taking ω = 1 leads to the
Symmetric Gauss-Seidel (SGS) iteration,
MSGS = (D − E)D −1 (D − F ).

(10.9)

An interesting observation is that D−E is the lower part of A, including the diagonal,
and D − F is, similarly, the upper part of A. Thus,
MSGS = LU,
with
L ≡ (D − E)D −1 = I − ED −1 ,

U = D − F.

The matrix L is unit lower triangular and U is upper triangular. One question that
may arise concerns the implementation of the preconditioning operation. To compute
−1
x, proceed as follows:
w = MSGS
solve
solve

(I − ED −1 )z = x,

(D − F )w = z.

A FORTRAN implementation of this preconditioning operation is illustrated in the
following code, for matrices stored in the MSR format described in Chapter 3.
FORTRAN CODE
subroutine lusol (n,rhs,sol,luval,lucol,luptr,uptr)
real*8 sol(n), rhs(n), luval(*)
integer n, luptr(*), uptr(n)
c----------------------------------------------------------c Performs a forward and a backward solve for an ILU or
c SSOR factorization, i.e., solves (LU) sol = rhs where LU
c is the ILU or the SSOR factorization. For SSOR, L and U
c should contain the matrices L = I - omega E inv(D), and U

300

CHAPTER 10. PRECONDITIONING TECHNIQUES

c = D - omega F, respectively with -E = strict lower
c triangular part of A, -F = strict upper triangular part
c of A, and D = diagonal of A.
c----------------------------------------------------------c PARAMETERS:
c n
= Dimension of problem
c rhs
= Right hand side; rhs is unchanged on return
c sol
= Solution of (LU) sol = rhs.
c luval = Values of the LU matrix. L and U are stored
c
together in CSR format. The diagonal elements of
c
U are inverted. In each row, the L values are
c
followed by the diagonal element (inverted) and
c
then the other U values.
c lucol = Column indices of corresponding elements in luval
c luptr = Contains pointers to the beginning of each row in
c
the LU matrix.
c uptr = pointer to the diagonal elements in luval, lucol
c-----------------------------------------------------------integer i,k
c
c
FORWARD SOLVE. Solve
L . sol = rhs
c
do i = 1, n
c
c
compute sol(i) := rhs(i) - sum L(i,j) x sol(j)
c
sol(i) = rhs(i)
do k=luptr(i),uptr(i)-1
sol(i) = sol(i) - luval(k)* sol(lucol(k))
enddo
enddo
c
c
BACKWARD SOLVE. Compute sol := inv(U) sol
c
do i = n, 1, -1
c
c
compute sol(i) := sol(i) - sum U(i,j) x sol(j)
c
do k=uptr(i)+1, luptr(i+1)-1
sol(i) = sol(i) - luval(k)*sol(lucol(k))
enddo
c
c
compute sol(i) := sol(i)/ U(i,i)
c
sol(i) = luval(uptr(i))*sol(i)
enddo
return
end

As was seen above, the SSOR or SGS preconditioning matrix is of the form
M = LU where L and U have the same pattern as the L-part and the U -part of A,
respectively. Here, L-part means lower triangular part and, similarly, the U -part is
the upper triangular part. If the error matrix A − LU is computed, then for SGS, for
example, we would find
A − LU = D − E − F − (I − ED −1 )(D − F ) = −ED −1 F.
If L is restricted to have the same structure as the L-part of A and U is to have the
same structure as the U -part of A, the question is whether or not it is possible to find

10.3. ILU FACTORIZATION PRECONDITIONERS

301

L and U that yield an error that is smaller in some sense than the one above. We can,
for example, try to find such an incomplete factorization in which the residual matrix
A − LU has zero elements in locations where A has nonzero entries.
This turns out to be possible in general and yields the ILU(0) factorization to be
discussed later. Generally, a pattern for L and U can be specified and L and U may
be sought so that they satisfy certain conditions. This leads to the general class of
incomplete factorization techniques which are discussed in the next section.
Example 10.1. Table 10.1 shows the results of applying the GMRES algorithm
with SGS (SSOR with ω = 1) preconditioning to the five test problems described
in Section 3.7. See Example 6.1 for the meaning of the column headers in the table.
Matrix

Iters

Kflops

Residual

Error

F2DA

38

1986

0.76E-03

0.82E-04

F3D

20

4870

0.14E-02

0.30E-03

ORS

110

6755

0.31E+00

0.68E-04

F2DB

300

15907

0.23E+02

0.66E+00

FID

300

99070

0.26E+02

0.51E-01

Table 10.1: A test run of GMRES with SGS preconditioning.
Notice here that the method did not converge in 300 steps for the last two problems.
The number of iterations for the first three problems is reduced substantially from
those required by GMRES without preconditioning shown in Table 6.2. The total
number of operations required is also reduced, but not proportionally because each
step now costs more due to the preconditioning operation.

10.3

ILU Factorization Preconditioners

Consider a general sparse matrix A whose elements are aij , i, j = 1, . . . , n. A
general Incomplete LU (ILU) factorization process computes a sparse lower triangular matrix L and a sparse upper triangular matrix U so that the residual matrix
R = LU − A satisfies certain constraints, such as having zero entries in some locations. We first describe a general ILU preconditioner geared toward M -matrices.
Then we discuss the ILU(0) factorization, the simplest form of the ILU preconditioners. Finally, we will show how to obtain more accurate factorizations.

10.3.1

Incomplete LU Factorizations

A general algorithm for building Incomplete LU factorizations can be derived by performing Gaussian elimination and dropping some elements in predetermined nondi-

302

CHAPTER 10. PRECONDITIONING TECHNIQUES

agonal positions. To analyze this process and establish existence for M -matrices, the
following result of Ky Fan [122] is needed.
Theorem 10.1 Let A be an M -matrix and let A1 be the matrix obtained from the
first step of Gaussian elimination. Then A1 is an M -matrix.
Proof. Theorem 1.32 will be used to establish that properties 1, 2, and 3 therein are
satisfied. First, consider the off-diagonal elements of A1 :
a1ij = aij −

ai1 a1j
.
a11

Since aij , ai1 , a1j are nonpositive and a11 is positive, it follows that a1ij ≤ 0 for
i 6= j.
Second, the fact that A1 is nonsingular is a trivial consequence of the following
standard relation of Gaussian elimination


A∗,1
, e2 , e3 , . . . en .
A = L1 A1 where L1 =
(10.10)
a11
−1
Finally, we establish that A−1
1 is nonnegative by examining A1 ej for j =
1
1, . . . , n. For j = 1, it is clear that A−1
1 e1 = a11 e1 because of the structure of
A1 . For the case j 6= 1, (10.10) can be exploited to yield
−1 −1
−1
A−1
1 ej = A L1 ej = A ej ≥ 0.

Therefore, all the columns of A−1
1 are nonnegative by assumption and this completes
the proof.
Clearly, the (n − 1) × (n − 1) matrix obtained from A1 by removing its first row and
first column is also an M -matrix.
Assume now that some elements are dropped from the result of Gaussian Elimination outside of the main diagonal. Any element that is dropped is a nonpositive
entry which is transformed into a zero. Therefore, the resulting matrix Ã1 is such
that
Ã1 = A1 + R,
where the elements of R are such that rii = 0, rij ≥ 0. Thus,
A1 ≤ Ã1
and the off-diagonal elements of Ã1 are nonpositive. Since A1 is an M -matrix,
theorem 1.33 shows that Ã1 is also an M -matrix. The process can now be repeated
on the matrix Ã(2 : n, 2 : n), and then continued until the incomplete factorization
of A is obtained. The above arguments shows that at each step of this construction,
we obtain an M -matrix and that the process does not break down.
The elements to drop at each step have not yet been specified. This can be done
statically, by choosing some non-zero pattern in advance. The only restriction on the

10.3. ILU FACTORIZATION PRECONDITIONERS

303

zero pattern is that it should exclude diagonal elements because this assumption was
used in the above proof. Therefore, for any zero pattern set P , such that
P ⊂ {(i, j) | i 6= j; 1 ≤ i, j ≤ n},

(10.11)

an Incomplete LU factorization, ILUP , can be computed as follows.
A LGORITHM 10.1 General Static Pattern ILU

0.
1.
2.
3.
4.
5.
6.
7.
8.

For each (i, j) ∈ P set aij = 0
For k = 1, . . . , n − 1 Do:
For i = k + 1, n and if (i, k) ∈
/ P Do:
aik := aik /akk
For j = k + 1, . . . , n and for (i, j) ∈
/ P Do:
aij := aij − aik ∗ akj
EndDo
EndDo
EndDo

The initial step (step 0) is necessary for the case, rare in practice, when the zero
pattern of A does not include the zero pattern defined by P . The For loop in line 4
should be interpreted as follows: For j = k + 1, . . . , n and only for those indices j
that are not in P execute the next line. In practice, it is wasteful to scan j from k + 1
to n because there is an inexpensive mechanism for identifying those indices j that
are in the complement of P . Using the above arguments, the following result can be
proved.
Theorem 10.2 Let A be an M -matrix and P a given zero pattern defined as in
(10.11). Then Algorithm 10.1 does not break down and produces an incomplete
factorization,
A = LU − R
which is a regular splitting of A.
Proof. At each step of the process, we have
Ãk = Ak + Rk ,

Ak = Lk Ãk−1

where, using Ok to denote a zero vector of dimension k, and Am:n,j to denote the
vector of components ai,j , i = m, . . . , n,


1
Ok
eTk .
Lk = I − (k)
A(k
+
1
:
n,
k)
akk
From this follow the relations
Ãk = Ak + Rk = Lk Ãk−1 + Rk .

CHAPTER 10. PRECONDITIONING TECHNIQUES

304

Applying this relation recursively, starting from k = n − 1 up to k = 1, it is found
that
Ãn−1 = Ln−1 . . . L1 A + Ln−1 . . . L2 R1 + . . . + Ln−1 Rn−2 + Rn−1 .

(10.12)

Now define
L = (Ln−1 . . . L1 )−1 ,

U = Ãn−1 .

Then, U = L−1 A + S with
S = Ln−1 . . . L2 R1 + . . . + Ln−1 Rn−2 + Rn−1 .
Observe that at stage k, elements are dropped only in the (n − k) × (n − k) lower
part of Ak . Hence, the first k rows and columns of Rk are zero and as a result
Ln−1 . . . Lk+1 Rk = Ln−1 . . . L1 Rk
so that S can be rewritten as
S = Ln−1 . . . L2 (R1 + R2 + . . . + Rn−1 ).
If R denotes the matrix
R = R1 + R2 + . . . + Rn−1 ,
then we obtain the factorization A = LU − R, where (LU )−1 = U −1 L−1 is a
nonnegative matrix, R is nonnegative. This completes the proof.

Accessed but not
modified

Accessed and
modified

Not accessed

Figure 10.1: IKJvariant of the LU factorization.
Now consider a few practical aspects. An ILU factorization based on Algorithm 10.1 is difficult to implement because at each step k, all rows k + 1 to n are
being modified. However, ILU factorizations depend on the implementation of Gaussian elimination which is used. Several variants of Gaussian elimination are known

10.3. ILU FACTORIZATION PRECONDITIONERS

305

which depend on the order of the three loops associated with the control variables i,
j, and k in the algorithm. Thus, Algorithm 10.1 is derived from what is known as the
k, i, j variant. In the context of Incomplete LU factorization, the variant that is most
commonly used for a row-contiguous data structure is the i, k, j variant, described
next for dense matrices.
A LGORITHM 10.2 Gaussian Elimination – IKJ Variant

1.
2.
3.
4.
5.
6.
7.
8.

For i = 2, . . . , n Do:
For k = 1, . . . , i − 1 Do:
aik := aik /akk
For j = k + 1, . . . , n Do:
aij := aij − aik ∗ akj
EndDo
EndDo
EndDo

The above algorithm is in place in the sense that the i-th row of A can be overwritten by the i-th rows of the L and U matrices of the factorization (since L is unit
lower triangular, its diagonal entries need not be stored). Step i of the algorithm generates the i-th row of L and the i-th row of U at the same time. The previous rows
1, 2, . . . , i − 1 of L and U are accessed at step i but they are not modified. This is
illustrated in Figure 10.1.
Adapting this version for sparse matrices is easy because the rows of L and U
are generated in succession. These rows can be computed one at a time and accumulated in a row-oriented data structure such as the CSR format. This constitutes an
important advantage. Based on this, the general ILU factorization takes the following
form.
A LGORITHM 10.3 General ILU Factorization, IKJVersion

1.
2.
3.
4.
5.
6.
7.
8.

For i = 2, . . . , n Do:
/ P Do:
For k = 1, . . . , i − 1 and if (i, k) ∈
aik := aik /akk
For j = k + 1, . . . , n and for (i, j) ∈
/ P , Do:
aij := aij − aik akj .
EndDo
EndDo
EndDo

It is not difficult to see that this more practical IKJvariant of ILU is equivalent to the
KIJversion which can be defined from Algorithm 10.1.
Proposition 10.3 Let P be a zero pattern satisfying the condition (10.11). Then the
ILU factors produced by the KIJ-based Algorithm 10.1 and the IKJ-based Algorithm 10.3 are identical if they can both be computed.

CHAPTER 10. PRECONDITIONING TECHNIQUES

306

Proof. Algorithm 10.3 is obtained from Algorithm 10.1 by switching the order of the
loops k and i. To see that this gives indeed the same result, reformulate the first two
loops of Algorithm 10.1 as

For k = 1, n Do:
For i = 1, n Do:
if k < i and for (i, k) ∈
/ P Do:
ope(row(i),row(k))
......
in which ope(row(i),row(k)) is the operation represented by lines 3 through 6 of both
Algorithm 10.1 and Algorithm 10.3. In this form, it is clear that the k and i loops
can be safely permuted. Then the resulting algorithm can be reformulated to yield
exactly Algorithm 10.3.
Note that this is only true for a static pattern ILU. If the pattern is dynamically determined as the Gaussian elimination algorithm proceeds, then the patterns obtained
with different versions of GE may be different.
It is helpful to interpret the result of one incomplete elimination step. Denoting
by li∗ , ui∗ , and ai∗ the i-th rows of L, U , and A, respectively, then the k-loop starting
at line 2 of Algorithm 10.3 can be interpreted as follows. Initially, we have ui∗ = ai∗ .
Then, each elimination step is an operation of the form
ui∗ := ui∗ − lik uk∗ .
However, this operation is performed only on the nonzero pattern, i.e., the complement of P . This means that, in reality, the elimination step takes the form
(k)

ui∗ := ui∗ − lik uk∗ + ri∗ ,
(k)

in which rij is zero when (i, j) ∈
/ P and equals lik ukj when (i, j) ∈ P . Thus,
(k)

the row ri∗ cancels out the terms lik ukj that would otherwise be introduced in the
zero pattern. In the end the following relation is obtained:
ui∗ = ai∗ −

i−1 
X
k=1

(k)

lik uk∗ − ri∗



.
(k)

Note that lik = 0 for (i, k) ∈ P . We now sum up all the ri∗ ’s and define
i−1
X
(k)
ri∗ =
ri∗ .

(10.13)

k=1

The row ri∗ contains the elements that fall inside the P pattern at the completion of
the k-loop. Using the fact that lii = 1, we obtain the relation,
ai∗ =

i
X
k=1

lik uk∗ − ri∗ .

Therefore, the following simple property can be stated.

(10.14)

10.3. ILU FACTORIZATION PRECONDITIONERS

307

Proposition 10.4 Algorithm 10.3 produces factors L and U such that
A = LU − R
in which −R is the matrix of the elements that are dropped during the incomplete
elimination process. When (i, j) ∈ P , an entry rij of R is equal to the value of
−aij obtained at the completion of the k loop in Algorithm 10.3. Otherwise, rij is
zero.

10.3.2

Zero Fill-in ILU (ILU(0))

The Incomplete LU factorization technique with no fill-in, denoted by ILU(0), takes
the zero pattern P to be precisely the zero pattern of A. In the following, we denote
by bi,∗ the i-th row of a given matrix B, and by N Z(B), the set of pairs (i, j), 1 ≤
i, j ≤ n such that bi,j 6= 0. The ILU(0) factorization is best illustrated by the case for
which it was discovered originally, namely, for 5-point and 7-point matrices related
to finite difference discretization of elliptic PDEs. Consider one such matrix A as
illustrated in the bottom left corner of Figure 10.2.
The A matrix represented in this figure is a 5-point matrix of size n = 32 corresponding to an nx × ny = 8 × 4 mesh. Consider now any lower triangular matrix L
which has the same structure as the lower part of A, and any matrix U which has the
same structure as that of the upper part of A. Two such matrices are shown at the top
of Figure 10.2. If the product LU were performed, the resulting matrix would have
the pattern shown in the bottom right part of the figure. It is impossible in general
to match A with this product for any L and U . This is due to the extra diagonals in
the product, namely, the diagonals with offsets nx − 1 and −nx + 1. The entries in
these extra diagonals are called fill-in elements. However, if these fill-in elements are
ignored, then it is possible to find L and U so that their product is equal to A in the
other diagonals.
The ILU(0) factorization has just been defined in general terms: Any pair of
matrices L (unit lower triangular) and U (upper triangular) so that the elements of
A − LU are zero in the locations of N Z(A). These constraints do not define the
ILU(0) factors uniquely since there are, in general, infinitely many pairs of matrices
L and U which satisfy these requirements. However, the standard ILU(0) is defined
constructively using Algorithm 10.3 with the pattern P equal to the zero pattern of
A.
A LGORITHM 10.4 ILU(0)

1.
2.
3.
4.
5.
6.
7.

For i = 2, . . . , n Do:
For k = 1, . . . , i − 1 and for (i, k) ∈ N Z(A) Do:
Compute aik = aik /akk
For j = k + 1, . . . , n and for (i, j) ∈ N Z(A), Do:
Compute aij := aij − aik akj .
EndDo
EndDo

CHAPTER 10. PRECONDITIONING TECHNIQUES

308
L

U

A

LU

Figure 10.2: The ILU(0) factorization for a five-point matrix.

8.

EndDo

In some cases, it is possible to write the ILU(0) factorization in the form
M = (D − E)D −1 (D − F ),

(10.15)

where −E and −F are the strict lower and strict upper triangular parts of A, and D
is a certain diagonal matrix, different from the diagonal of A, in general. In these
cases it is sufficient to find a recursive formula for determining the elements in D.
A clear advantage is that only an extra diagonal of storage is required. This form of
the ILU(0) factorization is equivalent to the incomplete factorizations obtained from
Algorithm 10.4 when the product of the strict-lower part and the strict-upper part of
A consists only of diagonal elements and fill-in elements. This is true, for example,
for standard 5-point difference approximations to second order partial differential
operators; see Exercise 4. In these instances, both the SSOR preconditioner with
ω = 1 and the ILU(0) preconditioner can be cast in the form (10.15), but they differ
in the way the diagonal matrix D is defined. For SSOR(ω = 1), D is the diagonal of
the matrix A itself. For ILU(0), it is defined by a recursion so that the diagonal of the
product of matrices (10.15) equals the diagonal of A. By definition, together the L
and U matrices in ILU(0) have the same number of nonzero elements as the original
matrix A.

10.3. ILU FACTORIZATION PRECONDITIONERS

309

Example 10.2. Table 10.2 shows the results of applying the GMRES algorithm
with ILU(0) preconditioning to the five test problems described in Section 3.7. See
Example 6.1 for the meaning of the column headers in the table.
Matrix

Iters

Kflops

Residual

Error

F2DA

28

1456

0.12E-02

0.12E-03

F3D

17

4004

0.52E-03

0.30E-03

ORS

20

1228

0.18E+00

0.67E-04

F2DB

300

15907

0.23E+02

0.67E+00

FID

206

67970

0.19E+00

0.11E-03

Table 10.2: A test run of GMRES with ILU(0) preconditioning.
Observe that for the first two problems, the gains relative to the performance of
the SSOR preconditioner in Table 10.1 are rather small. For the other three problems,
which are a little harder, the gains are more substantial. For the last problem, the
algorithm achieves convergence in 205 steps whereas SSOR did not convergence in
the 300 steps allowed. The fourth problem (F2DB) is still not solvable by ILU(0)
within the maximum number of steps allowed.
For the purpose of illustration, below is a sample FORTRAN code for computing
the incomplete L and U factors for general sparse matrices stored in the usual CSR
format. The real values of the resulting L, U factors are stored in the array luval,
except that entries of ones of the main diagonal of the unit lower triangular matrix
L are not stored. Thus, one matrix is needed to store these factors together. This
matrix is denoted by L/U . Note that since the pattern of L/U is identical with that
of A, the other integer arrays of the CSR representation for the LU factors are not
needed. Thus, ja(k), which is the column position of the element a(k) in the input
matrix, is also the column position of the element luval(k) in the L/U matrix. The
code below assumes that the nonzero elements in the input matrix A are sorted by
increasing column numbers in each row.
FORTRAN CODE
subroutine ilu0 (n, a, ja, ia, luval, uptr, iw, icode)
integer n, ja(*), ia(n+1), uptr(n), iw(n)
real*8 a(*), luval(*)
c----------------------------------------------------------c Set-up routine for ILU(0) preconditioner. This routine
c computes the L and U factors of the ILU(0) factorization
c of a general sparse matrix A stored in CSR format. Since
c L is unit triangular, the L and U factors can be stored
c as a single matrix which occupies the same storage as A.
c The ja and ia arrays are not needed for the LU matrix
c since
the pattern of the LU matrix is identical with
c that of A.
c-----------------------------------------------------------

310

CHAPTER 10. PRECONDITIONING TECHNIQUES

c INPUT:
c -----c n
= dimension of matrix
c a, ja, ia = sparse matrix in general sparse storage format
c iw
= integer work array of length n
c OUTPUT:
c ------c luval
= L/U matrices stored together. On return luval,
c
ja, ia is the combined CSR data structure for
c
the LU factors
c uptr
= pointer to the diagonal elements in the CSR
c
data structure luval, ja, ia
c icode
= integer indicating error code on return
c
icode = 0: normal return
c
icode = k: encountered a zero pivot at step k
c
c----------------------------------------------------------c
initialize work array iw to zero and luval array to a
do 30 i = 1, ia(n+1)-1
luval(i) = a(i)
30
continue
do 31 i=1, n
iw(i) = 0
31
continue
c----------------------- Main loop
do 500 k = 1, n
j1 = ia(k)
j2 = ia(k+1)-1
do 100 j=j1, j2
iw(ja(j)) = j
100
continue
j=j1
150
jrow = ja(j)
c----------------------- Exit if diagonal element is reached
if (jrow .ge. k) goto 200
c----------------------- Compute the multiplier for jrow.
tl = luval(j)*luval(uptr(jrow))
luval(j) = tl
c----------------------- Perform linear combination
do 140 jj = uptr(jrow)+1, ia(jrow+1)-1
jw = iw(ja(jj))
if (jw .ne. 0) luval(jw)=luval(jw)-tl*luval(jj)
140
continue
j=j+1
if (j .le. j2) goto 150
c----------------------- Store pointer to diagonal element
200
uptr(k) = j
if (jrow .ne. k .or. luval(j) .eq. 0.0d0) goto 600
luval(j) = 1.0d0/luval(j)
c----------------------- Refresh all entries of iw to zero.
do 201 i = j1, j2
iw(ja(i)) = 0
201
continue
500 continue
c----------------------- Normal return
icode = 0
return
c----------------------- Error: zero pivot
600 icode = k
return
end

10.3. ILU FACTORIZATION PRECONDITIONERS

10.3.3

311

Level of Fill and ILU(p)

The accuracy of the ILU(0) incomplete factorization may be insufficient to yield an
adequate rate of convergence as shown in Example 10.2. More accurate Incomplete
LU factorizations are often more efficient as well as more reliable. These more accurate factorizations will differ from ILU(0) by allowing some fill-in. Thus, ILU(1)
keeps the “first order fill-ins,” a term which will be explained shortly.
To illustrate ILU(p) with the same example as before, the ILU(1) factorization
results from taking P to be the zero pattern of the product LU of the factors L, U
obtained from ILU(0). This pattern is shown at the bottom right of Figure 10.2. Pretend that the original matrix has this “augmented” pattern N Z1 (A). In other words,
the fill-in positions created in this product belong to the augmented pattern N Z1 (A),
but their actual values are zero. The new pattern of the matrix A is shown at the
bottom left part of Figure 10.3. The factors L1 and U1 of the ILU(1) factorization are
obtained by performing an ILU(0) factorization on this “augmented pattern” matrix.
The patterns of L1 and U1 are illustrated at the top of Figure 10.3. The new LU
matrix shown at the bottom right of the figure has now two additional diagonals in
the lower and upper parts.
One problem with the construction defined in this illustration is that it does not
extend to general sparse matrices. It can be generalized by introducing the concept of
level of fill. A level of fill is attributed to each element that is processed by Gaussian
elimination, and dropping will be based on the value of the level of fill. Algorithm
10.2 will be used as a model, although any other form of GE can be used.
The rationale is that the level of fill should be indicative of the size: the higher
the level, the smaller the elements. A very simple model is employed to justify the
definition: A size of ǫk is attributed to any element whose level of fill is k, where
ǫ < 1. Initially, a nonzero element has a level of fill of one (this will be changed
later) and a zero element has a level of fill of ∞. An element aij is updated in line 5
of Algorithm 10.2 by the formula
aij = aij − aik × akj .

(10.16)

If levij is the current level of the element aij , then our model tells us that the size of
the updated element should be
size(aij ) := ǫlevij − ǫlevik × ǫlevkj = ǫlevij − ǫlevik +levkj .
Therefore, roughly speaking, the size of aij will be the maximum of the two
sizes ǫlevij and ǫlevik +levkj , and it is natural to define the new level of fill as,
levij := min{levij , levik + levkj }.
In the common definition used in the literature, all the levels of fill are actually shifted
by −1 from the definition used above. This is purely for convenience of notation and
to conform with the definition used for ILU(0). Thus, initially levij = 0 if aij 6= 0,
and levij = ∞ otherwise. Thereafter, define recursively
levij = min{levij , levik + levkj + 1}.

CHAPTER 10. PRECONDITIONING TECHNIQUES

312
L1

U1

Augmented A

L1 U1

Figure 10.3: The ILU(1) factorization for a five-point matrix.
Definition 10.5 The initial level of fill of an element aij of a sparse matrix A is
defined by

0 if aij 6= 0, or i = j
levij =
∞ otherwise.

Each time this element is modified in line 5 of Algorithm 10.2, its level of fill must be
updated by
levij = min{levij , levik + levkj + 1}.
(10.17)
Observe that the level of fill of an element will never increase during the elimination.
Thus, if aij 6= 0 in the original matrix A, then the element in location i, j will have a
level of fill equal to zero throughout the elimination process.
An alternative way of interpreting the above definition of fill-level can be drawn
from the graph model of Gaussian elimination, which is a standard tool used in sparse
direct solvers. Consider the adjacency graph G(A) = (V, E) of the matrix A. At
the completion of step k − 1 of Gaussian elimination, nodes 1, 2, . . . , k − 1 have
been eliminated. Let Vk−1 the set of the k − 1 vertices that are eliminated so far and
let vi , vj two vertices not in Vk , i.e., such that i, j > k. The vertex vi is said to be
reachable from the vertex vj through Vk−1 if there is a path in the (original) graph
G(A) which connects vi to vj , in which all intermediate vertices are in Vk−1 . The set
of all nodes v that are reachable from u through Vk−1 is denoted by Reach(u, Vk−1 ).

10.3. ILU FACTORIZATION PRECONDITIONERS

313

V k-1

k
i

j

Figure 10.4: Shortest path from i to j when k is added to Vk−1 .
The fill-level of (i, j) at step k − 1 is simply the length of the shortest path through
Vk−1 between vi and vj , minus 1. The initial fill-levels are defined as before, to be
zero when (i, j) ∈ V0 and infinity otherwise. At the next step (k), node k will be
added to Vk−1 to get Vk . Now more paths are available and so the path lengths may
be shortened by taking paths that go through the new node vk .
If we use the shifted levels (all levels are increased by one, so that the lev(i, j) is
the actual minimum path length) then, the shortest path is now the shortest of the old
shortest path and new possible paths through vk . A path through vk is a path from
i to vk continued by a path from vk to j. Therefore, the new pathlength is indeed
min{levij , levik + levkj }. This is illustrated in Figure 10.4.
Another useful concept in sparse direct solution methods is that of fill-path,
which is a path between two vertices i and j, such that all the vertices in the path,
except the end points i and j, are numbered less than i and j. The following result is
well-known in sparse direct solution methods.
Theorem 10.6 There is a fill-in in entry (i, j) at the completion of the Gaussian
elimination process if and only if, there exists a fill-path between i and j.
For a proof see [144, 233]. As it turns out, a fill-in entry which has level-of-fill value
p corresponds to fill-paths whose length is p + 1.
Theorem 10.7 At the completion of the ILU process, a fill-in entry in position (i, j)
has level-of-fill value p if and only if there exists a fill-path of length p + 1 between i
and j.
Proof. If there is a fill-path of length p, then from what said above on reachable sets,
it is clear that lev(aij ) ≤ p. However, lev(aij ) cannot be < p, otherwise at some step
k we would have a path between i and j that is of length < p. Since path lengths do
not increase, this would lead to a contradiction. The converse is also true. If lev(aij )
is equal to p then at the last step k when lev(aij ) was modified there was a path of
length p between i and j.
The above systematic definition gives rise to a natural strategy for discarding elements. In ILU(p), all fill-in elements whose level of fill does not exceed p are kept.

CHAPTER 10. PRECONDITIONING TECHNIQUES

314

So using the definition of zero patterns introduced earlier, the zero pattern for ILU(p)
is the set
Pp = {(i, j) | levij > p},
where levij is the level of fill value after all updates (10.17) have been performed.
The case p = 0 coincides with the ILU(0) factorization and is consistent with the
earlier definition.
Since fill levels are is essentially path-lengths in the graph, they are bounded
from above by δ(G) + 1 where the diameter δ(G) of a graph G is maximum possible
distance d(x, y) between two vertices x and y of the graph
δ(G) = max{d(x, y) | x ∈ V, y ∈ V }.
Recall that the distance d(x, y) between vertices x and y in the graph is the length of
the shortest path between x and y.
Definition 10.5 of fill levels is not the only one used in practice. An alternative
definition replaces the updating formula (10.17) by
levij = min{levij , max{levik , levkj } + 1}.

(10.18)

In practical implementations of the ILU(p) factorization it is common to separate
the symbolic phase (where the structure of the L and U factors are determined) from
the numerical factorization, when the numerical values are computed. Here, a variant
is described which does not separate these two phases. In the following description,
ai∗ denotes the i-th row of the matrix A, and aij the (i, j)-th entry of A.
A LGORITHM 10.5 ILU(p)

1.
2.
3.
4.
5.
6.
7.
8.
9.

For all nonzero elements aij define lev(aij ) = 0
For i = 2, . . . , n Do:
For each k = 1, . . . , i − 1 and for lev(aik ) ≤ p Do:
Compute aik := aik /akk
Compute ai∗ := ai∗ − aik ak∗ .
Update the levels of fill of the nonzero ai,j ’s using (10.17)
EndDo
Replace any element in row i with lev(aij ) > p by zero
EndDo

There are a number of drawbacks to the above algorithm. First, the amount of fill-in
and computational work for obtaining the ILU(p) factorization is not predictable for
p > 0. Second, the cost of updating the levels can be high. Most importantly, the
level of fill-in for indefinite matrices may not be a good indicator of the size of the
elements that are being dropped. Thus, the algorithm may drop large elements and
result in an inaccurate incomplete factorization, in that R = LU − A is not small.
Experience reveals that on the average this will lead to a larger number of iterations
to achieve convergence. The techniques which will be described in Section 10.4 have
been developed to remedy these difficulties by producing incomplete factorizations
with small error R and controlled fill-in.

10.3. ILU FACTORIZATION PRECONDITIONERS

10.3.4

315

Matrices with Regular Structure

Often, the original matrix has a regular structure which can be exploited to formulate the ILU preconditioners in a simpler way. Historically, incomplete factorization
preconditioners were developed first for such matrices, rather than for general sparse
matrices. Here, we call a regularly structured matrix a matrix consisting of a small
number of diagonals. As an example, consider the diffusion-convection equation,
with Dirichlet boundary conditions
−∆u + ~b.∇u = f in Ω

u = 0 on ∂Ω

where Ω is simply a rectangle. As seen in Chapter 2, if the above problem is discretized using centered differences, a linear system is obtained whose coefficient
matrix has the structure shown in Figure 10.5. In terms of the stencils seen in Chapter 4, the representation of this matrix is rather simple. Each row expresses the
coupling between unknown i and unknowns i + 1, i − 1 which are in the horizontal,
or x direction, and the unknowns i + m and i − m which are in the vertical, or y
direction. This stencil is represented in Figure 10.7. The desired L and U matrices
in the ILU(0) factorization are shown in Figure 10.6. Now the respective stencils of
these L and U matrices can be represented at a mesh point i as shown in Figure 10.8.
The stencil of the product LU can be obtained easily by manipulating stencils
directly rather than working with the matrices they represent.
ϕm+1
δ1 γ2
β2 δ2 γ3
β3 δ3
ηm+1
ηi

βi δi γi+1

ϕi+m
ϕn

ηn

γn
βn δn

Figure 10.5: Matrix resulting from the discretization of an elliptic problem on a
rectangle.
Indeed, the i-th row of LU is obtained by performing the following operation:
rowi (LU ) = 1 × rowi (U ) + bi × rowi−1 (U ) + ei × rowi−m (U ).
This translates into a combination of the stencils associated with the rows:
stencili (LU ) = 1 × stencili (U ) + bi × stencili−1 (U ) + ei × stencili−m (U )

CHAPTER 10. PRECONDITIONING TECHNIQUES

316
L

U
d1 g2

1
b2

fm+1

em+1
fn

en

gn
dn

bn 1

Figure 10.6: L and U factors of the ILU(0) factorization for the 5-point matrix shown
in Figure 10.5.
in which stencilj (X) represents the stencil of the matrix X based at the mesh point
labeled j.
This gives the stencil for the LU matrix
represented in Figure 10.9.
ϕ
i+m

βi

δi

γi+1

ηi
Figure 10.7: Stencil associated with the 5-point matrix shown in Figure 10.5.
In the figure, the fill-in elements are represented by squares and all other nonzero
elements of the stencil are filled circles. The ILU(0) process consists of identifying
LU with A in locations where the original aij ’s are nonzero. In the Gaussian elimination process, this is done from i = 1 to i = n. This provides the following equations
obtained directly from comparing the stencils of LU and A (going from lowest to
highest indices)
ei di−m = ηi
bi di−1 = βi
di + bi gi + ei fi = δi
gi+1 = γi+1
fi+m = ϕi+m .

10.3. ILU FACTORIZATION PRECONDITIONERS

317
fi+m

bi

di

1

gi+1

ei
Figure 10.8: Stencils associated with the L and U factors shown in Figure 10.6.
bi fi+m−1

fi+m

di + bi gi + ei fi
gi+1

✠

bi di−1

ei di−m

ei gi−m+1

Figure 10.9: Stencil associated with the product of the L and U factors shown in
Figure 10.6.
Observe that the elements gi+1 and fi+m are identical with the corresponding elements of the A matrix. The other values are obtained from the following recurrence:
ηi
ei =
di−m
βi
bi =
di−1
di = δi − bi gi − ei fi .
The above recurrence can be simplified further by making the observation that the
quantities ηi /di−m and βi /di−1 need not be saved since they are scaled versions of
the corresponding elements in A. With this observation, only a recurrence for the
diagonal elements di is needed. This recurrence is:
di = δi −

ηi ϕi
βi γi
−
,
di−1 di−m

i = 1, . . . , n,

(10.19)

with the convention that any dj with a non-positive index j is replaced by 1, the
entries βi , i ≤ 1, γi , i ≤ 1, φi , i ≤ m, and ηi , i ≤ m, are zero. The factorization

CHAPTER 10. PRECONDITIONING TECHNIQUES

318
obtained takes the form

M = (D − E)D −1 (D − F )

(10.20)

in which −E is the strict lower diagonal of A, −F is the strict upper triangular part
of A, and D is the diagonal obtained with the above recurrence. Note that an ILU(0)
based on the IKJversion of Gaussian elimination would give the same result.
For a general sparse matrix A with irregular structure, one can also determine
a preconditioner in the form (10.20) by requiring only that the diagonal elements
of M match those of A (see Exercise 10). However, this will not give the same
ILU factorization as the one based on the IKJvariant of Gaussian elimination seen
earlier. Why the ILU(0) factorization gives rise to the same factorization as that of
(10.20) is simple to understand: The product of L and U does not change the values
of the existing elements in the upper part, except for the diagonal. This also can be
interpreted on the adjacency graph of the matrix.
This approach can now be extended to determine the ILU(1) factorization as well
as factorizations with higher levels of fill. The stencils of the L and U matrices in
the ILU(1) factorization are the stencils of the lower part and upper parts of the LU
matrix obtained from ILU(0). These are shown in Figure 10.10. In the illustration,
the meaning of a given stencil is not in the usual graph theory sense. Instead, all
the marked nodes at a stencil based at node i represent those nodes coupled with
unknown i by an equation. Thus, all the filled circles in the picture are adjacent to
the central node. Proceeding as before and combining stencils to form the stencil
associated with the LU matrix, we obtain the stencil shown in Figure 10.11.
hi+m−1

bi

di

1

ei

fi+m

gi+1

ci

Figure 10.10: Stencils of the L and U factors for the ILU(0) factorization of the
matrix represented by the stencil of Figure 10.9.
As before, the fill-in elements are represented by squares and all other elements
are filled circles. A typical row of the matrix associated with the above stencil has
nine nonzero elements. Two of these are fill-ins, i.e., elements that fall outside the
original structure of the L and U matrices. It is now possible to determine a recurrence relation for obtaining the entries of L and U . There are seven equations in all
which, starting from the bottom, are
ei di−m = ηi

10.3. ILU FACTORIZATION PRECONDITIONERS

319

hi+m−1 + bi fi+m−1
bi hi+m−2
fi+m
❄
di + bi gi + ei fi + ci hi
gi+1 + ci fi+1
☛
bi di−1 + ei hi−1

ci gi−m+1
ei di−m
✻
ei gi−m+1 + ci di−m+1
Figure 10.11: Stencil associated with the product of the L and U matrices whose
stencils are shown in Figure 10.10.
ei gi−m+1 + ci di−m+1 = 0
bi di−1 + ei hi−1 = βi
di + bi gi + ei fi + ci hi = δi
gi+1 + ci fi+1 = γi+1
hi+m−1 + bi fi+m−1 = 0
fi+m = ϕi+m .
This immediately yields the following recurrence relation for the entries of the L and
U factors:
ei = ηi /di−m
ci = −ei gi−m+1 /di−m+1
bi = (βi − ei hi−1 ) /di−1

di = δi − bi gi − ei fi − ci hi

gi+1 = γi+1 − ci fi+1

hi+m−1 = −bi fi+m−1
fi+m = ϕi+m .

In proceeding from the nodes of smallest index to those of largest index, we are in
effect performing implicitly the IKJversion of Gaussian elimination. The result of
the ILU(1) obtained in this manner is therefore identical with that obtained by using
Algorithms 10.1 and 10.3.

10.3.5

Modified ILU (MILU)

In all the techniques thus far, the elements that were dropped out during the incomplete elimination process are simply discarded. There are also techniques which at-

CHAPTER 10. PRECONDITIONING TECHNIQUES

320

tempt to reduce the effect of dropping by compensating for the discarded entries. For
example, a popular strategy is to add up all the elements that have been dropped at
the completion of the k-loop of Algorithm 10.3. Then this sum is subtracted from the
diagonal entry in U . This diagonal compensation strategy gives rise to the Modified
ILU (MILU) factorization.
Thus, in equation (10.13), the final row ui∗ obtained after completion of the kloop of Algorithm 10.3 undergoes one more modification, namely,
uii := uii − (ri∗ e)
in which e ≡ (1, 1, . . . , 1)T . Note that ri∗ is a row and ri∗ e is the sum of the elements
in this row, i.e., its row sum. The above equation can be rewritten in row form as
ui∗ := ui∗ − (ri∗ e)eTi and equation (10.14) becomes
ai∗ =

i
X
k=1

lik uk∗ + (ri∗ e)eTi − ri∗ .

(10.21)

Observe that
ai∗ e =

i
X
k=1

lik uk∗ e + (ri∗ e)eTi e − ri∗ e =

i−1
X

lik uk∗ e = LU e.

k=1

This establishes that Ae = LU e. As a result, this strategy guarantees that the row
sums of A are equal to those of LU . For PDEs, the vector of all ones represents
the discretization of a constant function. This additional constraint forces the ILU
factorization to be exact for constant functions in some sense. Therefore, it is not
surprising that often the algorithm does well for such problems. For other problems
or problems with discontinuous coefficients, MILU algorithms usually are not better
than their ILU counterparts, in general.
Example 10.3. For regularly structured matrices there are two elements dropped
at the i-th step of ILU(0). These are bi fi+m−1 and ei gi−m+1 located on the northwest and south-east corners of the stencil, respectively. Thus, the row sum ri,∗ e
associated with step i is
si =

βi φi+m−1 ηi γm−i+1
+
di−1
di−m

and the MILU variant of the recurrence (10.19) is
βi φi+m−1 ηi γm−i+1
+
di−1
di−m
βi γi
ηi ϕi
= δi −
−
− si .
di−1 di−m

si =
di

10.4. THRESHOLD STRATEGIES AND ILUT

321

The new ILU factorization is now such that A = LU − R in which according to
(10.21) the i-th row of the new remainder matrix R is given by
(new)

ri,∗

= (ri∗ e)eTi − ri∗

whose row sum is zero.
This generic idea of lumping together all the elements dropped in the elimination
process and adding them to the diagonal of U can be used for any form of ILU
factorization. In addition, there are variants of diagonal compensation in which only
a fraction of the dropped elements are added to the diagonal. Thus, the term si in
the above example would be replaced by ωsi before being added to uii , where ω
is typically between 0 and 1. Other strategies distribute the sum si among nonzero
elements of L and U , other than the diagonal.

10.4

Threshold Strategies and ILUT

Incomplete factorizations which rely on the levels of fill are blind to numerical values
because elements that are dropped depend only on the structure of A. This can cause
some difficulties for realistic problems that arise in many applications. A few alternative methods are available which are based on dropping elements in the Gaussian
elimination process according to their magnitude rather than their locations. With
these techniques, the zero pattern P is determined dynamically. The simplest way
to obtain an incomplete factorization of this type is to take a sparse direct solver
and modify it by adding lines of code which will ignore “small” elements. However, most direct solvers have a complex implementation involving several layers of
data structures that may make this approach ineffective. It is desirable to develop a
strategy which is more akin to the ILU(0) approach. This section describes one such
technique.

10.4.1

The ILUT Approach

A generic ILU algorithm with threshold can be derived from the IKJversion of Gaussian elimination, Algorithm 10.2, by including a set of rules for dropping small elements. In what follows, applying a dropping rule to an element will only mean
replacing the element by zero if it satisfies a set of criteria. A dropping rule can be
applied to a whole row by applying the same rule to all the elements of the row. In
the following algorithm, w is a full-length working row which is used to accumulate
linear combinations of sparse rows in the elimination and wk is the k-th entry of this
row. As usual, ai∗ denotes the i-th row of A.
A LGORITHM 10.6 ILUT

1.
2.
3.
4.

For i = 1, . . . , n Do:
w := ai∗
For k = 1, . . . , i − 1 and when wk 6= 0 Do:
wk := wk /akk

322

5.
6.
7.
8.
9.
10.
11.
12.
13.
14.

CHAPTER 10. PRECONDITIONING TECHNIQUES
Apply a dropping rule to wk
If wk 6= 0 then
w := w − wk ∗ uk∗
EndIf
EndDo
Apply a dropping rule to row w
li,j := wj for j = 1, . . . , i − 1
ui,j := wj for j = i, . . . , n
w := 0
EndDo

Now consider the operations involved in the above algorithm. Line 7 is a sparse
update operation. A common implementation of this is to use a full vector for w and
a companion pointer which points to the positions of its nonzero elements. Similarly,
lines 11 and 12 are sparse-vector copy operations. The vector w is filled with a few
nonzero elements after the
completion of each outer loop i, and therefore it is necessary to zero out those
elements at the end of the Gaussian elimination loop as is done in line 13. This is a
sparse set-to-zero operation.
ILU(0) can be viewed as a particular case of the above algorithm. The dropping
rule for ILU(0) is to drop elements that are in positions not belonging to the original
structure of the matrix.
In the factorization ILUT(p, τ ), the following rule is used.
1. In line 5, an element wk is dropped (i.e., replaced by zero) if it is less than the
relative tolerance τi obtained by multiplying τ by the original norm of the i-th
row (e.g., the 2-norm).
2. In line 10, a dropping rule of a different type is applied. First, drop again
any element in the row with a magnitude that is below the relative tolerance
τi . Then, keep only the p largest elements in the L part of the row and the p
largest elements in the U part of the row in addition to the diagonal element,
which is always kept.
The goal of the second dropping step is to control the number of elements per row.
Roughly speaking, p can be viewed as a parameter that helps control memory usage,
while τ helps to reduce computational cost. There are several possible variations
on the implementation of dropping step 2. For example we can keep a number of
elements equal to nu(i) + p in the upper part and nl(i) + p in the lower part of the
row, where nl(i) and nu(i) are the number of nonzero elements in the L part and the
U part of the i-th row of A, respectively. This variant is adopted in the ILUT code
used in the examples.
Note that no pivoting is performed. Partial (column) pivoting may be incorporated at little extra cost and will be discussed later. It is also possible to combine
ILUT with one of the many standard reorderings, such as the nested dissection ordering or the reverse Cuthill-McKee ordering. Reordering in the context of incomplete

10.4. THRESHOLD STRATEGIES AND ILUT

323

factorizations can also be helpful for improving robustness, provided enough accuracy is used. For example, when a red-black ordering is used, ILU(0) may lead to
poor performance compared with the natural ordering ILU(0). On the other hand,
if ILUT is used by allowing gradually more fill-in, then the performance starts improving again. In fact, in some examples, the performance of ILUT for the red-black
ordering eventually outperforms that of ILUT for the natural ordering using the same
parameters p and τ .

10.4.2

Analysis

Existence theorems for the ILUT factorization are similar to those of other incomplete factorizations. If the diagonal elements of the original matrix are positive while
the off-diagonal elements are negative, then under certain conditions of diagonal
dominance the matrices generated during the elimination will have the same property. If the original matrix is diagonally dominant, then the transformed matrices will
also have the property of being diagonally dominant under certain conditions. These
properties are analyzed in detail in this section.
The row vector w resulting from line 4 of Algorithm 10.6 will be denoted by
k+1
ui,∗ . Note that uk+1
= 0 for j ≤ k. Lines 3 to 10 in the algorithm involve a
i,j
sequence of operations of the form
lik := ukik /ukk
if |lik |

(10.22)

small enough set

lik = 0

else:

k
k
uk+1
i,j := ui,j − lik uk,j − rij

j = k + 1, . . . , n

(10.23)

k is an element
for k = 1, . . . , i − 1, in which initially u1i,∗ := ai,∗ and where rij
subtracted from a fill-in element which is being dropped. It should be equal either to
zero (no dropping) or to ukij − lik ukj when the element uk+1
i,j is being dropped. At
the end of the i-th step of Gaussian elimination (outer loop in Algorithm 10.6), we
obtain the i-th row of U ,
ui,∗ ≡ uii−1,∗
(10.24)

and the following relation is satisfied:
ai,∗ =

i
X

lk,j uki,∗ + ri,∗ ,

k=1

where ri,∗ is the row containing all the fill-ins.
The existence result which will be proved is valid only for certain modifications
of the basic ILUT(p, τ ) strategy. We consider an ILUT strategy which uses the following modification:
• Drop Strategy Modification. For any i < n, let ai,ji be the element of largest
modulus among the elements ai,j , j = i + 1, . . . n, in the original matrix.

CHAPTER 10. PRECONDITIONING TECHNIQUES

324

Then elements generated in position (i, ji ) during the ILUT procedure are not
subject to the dropping rule.
This modification prevents elements generated in position (i, ji ) from ever being
dropped. Of course, there are many alternative strategies that can lead to the same
effect.
A matrix H whose entries hij satisfy the following three conditions:
hii > 0 for

1≤i<n

and

hnn ≥ 0

hij ≤ 0 for i, j = 1, . . . , n and
n
X
hij < 0, for 1 ≤ i < n

i 6= j;

(10.25)
(10.26)
(10.27)

j=i+1

will be referred to as an M̂ matrix. The third condition is a requirement that there be
at least one nonzero element to the right of the diagonal element, in each row except
the last. The row sum for the i-th row is defined by
rs(hi,∗ ) = hi,∗ e =

n
X

hi,j .

j=1

A given row of an M̂ matrix H is diagonally dominant, if its row sum is nonnegative.
An M̂ matrix H is said to be diagonally dominant if all its rows are diagonally
dominant. The following theorem is an existence result for ILUT. The underlying
assumption is that an ILUT strategy is used with the modification mentioned above.
Theorem 10.8 If the matrix A is a diagonally dominant M̂ matrix, then the rows
uki,∗ , k = 0, 1, 2, . . . , i defined by (10.23) starting with u0i,∗ = 0 and u1i,∗ = ai,∗
satisfy the following relations for k = 1, . . . , l
ukij ≤ 0 j 6= i

(10.28)

k−1
rs(uki,∗ ) ≥ rs(ui,∗
) ≥ 0,

ukii > 0

when

i<n

and

(10.29)
uknn ≥ 0.

(10.30)

Proof. The result can be proved by induction on k. It is trivially true for k = 0. To
prove that the relation (10.28) is satisfied, start from the relation
k
k
uk+1
i,∗ := ui,∗ − lik uk,∗ − ri∗
k is zero which yields uk+1 ≤ uk ≤ 0, or
in which lik ≤ 0, uk,j ≤ 0. Either rij
ij
ij
k+1
k is nonzero which means that u
rij
is being dropped, i.e., replaced by zero, and
ij
therefore again uk+1
≤ 0. This establishes (10.28). Note that by this argument
ij
k
rij = 0 except when the j-th element in the row is dropped, in which case uk+1
=0
ij

10.4. THRESHOLD STRATEGIES AND ILUT

325

k = uk − l u
k
and rij
ik k,j ≤ 0. Therefore, rij ≤ 0, always. Moreover, when an element
ij
in position (i, j) is not dropped, then
k
k
uk+1
i,j := ui,j − lik uk,j ≤ ui,j

and in particular by the rule in the modification of the basic scheme described above,
for i < n, we will always have for j = ji ,
k
uk+1
i,ji ≤ ui,ji

(10.31)

in which ji is defined in the statement of the modification.
Consider the row sum of uk+1
i∗ . We have
k
rs(uk+1
i,∗ ) = rs(ui,∗ ) − lik

≥ rs(uki,∗ ) − lik
≥

k
rs(uk,∗ ) − rs(ri∗
)

rs(uk,∗ )

rs(uki,∗ )

which establishes (10.29) for k + 1.
It remains to prove (10.30). From (10.29) we have, for i < n,
X
X
k+1
uk+1
≥
−
u
=
|uk+1
ii
i,j
i,j |
≥

≥

j=k+1,n
j=k+1,n
k+1
k
|ui,ji | ≥ |ui,ji | ≥ . . .
|u1i,ji | = |ai,ji |.

(10.32)
(10.33)

(10.34)
(10.35)
(10.36)

Note that the inequalities in (10.35) are true because uki,ji is never dropped by assumption and, as a result, (10.31) applies. By the condition (10.27), which defines
M̂ matrices, |ai,ji | is positive for i < n. Clearly, when i = n, we have by (10.34)
unn ≥ 0. This completes the proof.
The theorem does not mean that the factorization is effective only when its conditions are satisfied. In practice, the preconditioner is efficient under fairly general
conditions.

10.4.3

Implementation Details

A poor implementation of ILUT may well lead to an expensive factorization phase,
and possibly an impractical algorithm. The following is a list of the potential difficulties that may cause inefficiencies in the implementation of ILUT.
1. Generation of the linear combination of rows of A (Line 7 in Algorithm 10.6).
2. Selection of the p largest elements in L and U .
3. Need to access the elements of L in increasing order of columns (in line 3 of
Algorithm 10.6).

CHAPTER 10. PRECONDITIONING TECHNIQUES

326

For (1), the usual technique is to generate a full row and accumulate the linear combination of the previous rows in it. The row is zeroed again after the whole loop is
finished using a sparse set-to-zero operation. A variation on this technique uses only
a full integer array jr(1 : n), the values of which are zero except when there is a
nonzero element. With this full row, a short real vector w(1 : maxw) must be maintained which contains the real values of the row, as well as a corresponding short
integer array jw(1 : maxw) which points to the column position of the real values
in the row. When a nonzero element resides in position j of the row, then jr(j) is set
to the address k in w, jw where the nonzero element is stored. Thus, jw(k) points
to jr(j), and jr(j) points to jw(k) and w(k). This is illustrated in Figure 10.12.
0

1

0

2

0

2

4

7

9

jw: pointer to nonzero elements

x

x

x

x

w: real values

0

3

0

4

0

0

0

0

jr: nonzero
indicator

Figure 10.12: Illustration of data structure used for the working row in ILUT.
Note that jr holds the information on the row consisting of both the L part and
the U part of the LU factorization. When the linear combinations of the rows are
performed, first determine the pivot. Then, unless it is small enough to be dropped
according to the dropping rule being used, proceed with the elimination. If a new
element in the linear combination is not a fill-in, i.e., if jr(j) = k 6= 0, then update
the real value w(k). If it is a fill-in (jr(j) = 0), then append an element to the arrays
w, jw and update jr accordingly.
For (2), the natural technique is to employ a heap-sort strategy. The cost of this
implementation would be O(m + p × log2 m), i.e., O(m) for the heap construction
and O(log2 m) for each extraction. Another implementation is to use a modified
quick-sort strategy based on the fact that sorting the array is not necessary.
Only the largest p elements must be extracted. This is a quick-split technique to
distinguish it from the full quick-sort. The method consists of choosing an element,
e.g., x = w(1), in the array w(1 : m), then permuting the data so that |w(k)| ≤ |x| if
k ≤ mid and |w(k)| ≥ |x| if k ≥ mid, where mid is some split point. If mid = p,
then exit. Otherwise, split one of the left or right sub-arrays recursively, depending
on whether mid is smaller or larger than p. The cost of this strategy on the average
is O(m). The savings relative to the simpler bubble sort or insertion sort schemes
are small for small values of p, but they become rather significant for large p and m.
The next implementation difficulty is that the elements in the L part of the row
being built are not in an increasing order of columns. Since these elements must be
accessed from left to right in the elimination process, all elements in the row after
those already eliminated must be scanned. The one with smallest column number

10.4. THRESHOLD STRATEGIES AND ILUT

327

is then picked as the next element to eliminate. This operation can be efficiently
organized as a binary search tree which allows easy insertions and searches. This
improvement can bring substantial gains in the case when accurate factorizations are
computed.
Example 10.4. Tables 10.3 and 10.4 show the results of applying GMRES(10)
preconditioned with ILUT(1, 10−4 ) and ILUT(5, 10−4 ), respectively, to the five test
problems described in Section 3.7. See Example 6.1 for the meaning of the column
headers in the table. As shown, all linear systems are now solved in a relatively
small number of iterations, with the exception of F2DB which still takes 130 steps
to converge with lfil = 1 (but only 10 with lfil = 5.) In addition, observe a marked
improvement in the operation count and error norms. Note that the operation counts
shown in the column Kflops do not account for the operations required in the set-up
phase to build the preconditioners. For large values of lfil , this may be large.
Matrix

Iters

Kflops

Residual

Error

F2DA

18

964

0.47E-03

0.41E-04

F3D

14

3414

0.11E-02

0.39E-03

ORS

6

341

0.13E+00

0.60E-04

F2DB

130

7167

0.45E-02

0.51E-03

FID

59

19112

0.19E+00

0.11E-03

Table 10.3: A test run of GMRES(10)-ILUT(1, 10−4 ) preconditioning.
If the total time to solve one linear system with A is considered, a typical curve
of the total time required to solve a linear system when the lfil parameter varies would
look like the plot shown in Figure 10.13. As lfil increases, a critical value is reached
where the preprocessing time and the iteration time are equal. Beyond this critical
point, the preprocessing time dominates the total time. If there are several linear
systems to solve with the same matrix A, then it is advantageous to use a more accurate factorization, since the cost of the factorization will be amortized. Otherwise, a
smaller value of lfil will result in a more efficient, albeit also less reliable, run.

10.4.4

The ILUTP Approach

The ILUT approach may fail for many of the matrices that arise from real applications, for one of the following reasons.
1. The ILUT procedure encounters a zero pivot;
2. The ILUT procedure encounters an overflow or underflow condition, because
of an exponential growth of the entries of the factors;

CHAPTER 10. PRECONDITIONING TECHNIQUES

328
Matrix

Iters

Kflops

Residual

Error

F2DA

7

478

0.13E-02

0.90E-04

F3D

9

2855

0.58E-03

0.35E-03

ORS

4

270

0.92E-01

0.43E-04

F2DB

10

724

0.62E-03

0.26E-03

FID

40

14862

0.11E+00

0.11E-03

Table 10.4: A test run of GMRES(10)-ILUT(5, 10−4 ) preconditioning.
12.
10.
C 8.0
P
U
6.0
T
i
m 4.0
e
2.0
0.
3.0

5.0

7.0

9.0

11.

13.

15.

level of fill-in

Figure 10.13: Typical CPU time as a function of lfil. Dashed line: ILUT. Dotted line:
GMRES. Solid line: total.
3. The ILUT preconditioner terminates normally but the incomplete factorization
preconditioner which is computed is unstable.
An unstable ILU factorization is one for which M −1 = U −1 L−1 has a very large
norm leading to poor convergence or divergence of the outer iteration. The case (1)
can be overcome to a certain degree by assigning an arbitrary nonzero value to a zero
diagonal element that is
encountered. Clearly, this is not a satisfactory remedy because of the loss in
accuracy in the preconditioner. The ideal solution in this case is to use pivoting.
However, a form of pivoting is desired which leads to an algorithm with similar cost
and complexity to ILUT. Because of the data structure used in ILUT, row pivoting is
not practical. Instead, column pivoting can be implemented rather easily.
Here are a few of the features that characterize the new algorithm which is termed
ILUTP (“P” stands for pivoting). ILUTP uses a permutation array perm to hold the
new orderings of the variables, along with the reverse permutation array. At step i
of the elimination process the largest entry in a row is selected and is defined to be

10.4. THRESHOLD STRATEGIES AND ILUT

329

the new i-th variable. The two permutation arrays are then updated accordingly. The
matrix elements of L and U are kept in their original numbering. However, when
expanding the L-U row which corresponds to the i-th outer step of Gaussian elimination, the elements are loaded with respect to the new labeling, using the array
perm for the translation. At the end of the process, there are two options. The first
is to leave all elements labeled with respect to the original labeling. No additional
work is required since the variables are already in this form in the algorithm, but the
variables must then be permuted at each preconditioning step. The second solution
is to apply the permutation to all elements of A as well as L/U . This does not require applying a permutation at each step, but rather produces a permuted solution
which must be permuted back at the end of the iteration phase. The complexity of
the ILUTP procedure is virtually identical to that of ILUT. A few additional options
can be provided. A tolerance parameter called permtol may be included to help
determine whether or not to permute variables: A nondiagonal element aij is candidate for a permutation only when tol × |aij | > |aii |. Furthermore, pivoting may be
restricted to take place only within diagonal blocks of a fixed size. The size mbloc
of these blocks must be provided. A value of mbloc ≥ n indicates that there are no
restrictions on the pivoting.
For difficult matrices, the following strategy seems to work well:
1. Apply a scaling to all the rows (or columns) e.g., so that their 1-norms are all
equal to 1; then apply a scaling of the columns (or rows).
2. Use a small drop tolerance (e.g., ǫ = 10−4 or ǫ = 10−5 ) and take a large fill-in
parameter (e.g., lf il = 20).
3. Do not take a small value for permtol. Reasonable values are between 0.5 and
0.01, with 0.5 being the best in many cases.
Matrix

Iters

Kflops

Residual

Error

F2DA

18

964

0.47E-03

0.41E-04

F3D

14

3414

0.11E-02

0.39E-03

ORS

6

341

0.13E+00

0.61E-04

F2DB

130

7167

0.45E-02

0.51E-03

FID

50

16224

0.17E+00

0.18E-03

Table 10.5: A test run of GMRES with ILUTP preconditioning.

Example 10.5. Table 10.5 shows the results of applying the GMRES algorithm
with ILUTP(1, 10−4 ) preconditioning to the five test problems described in Section 3.7. The permtol parameter is set to 1.0 in this case. See Example 6.1 for

CHAPTER 10. PRECONDITIONING TECHNIQUES

330

the meaning of the column headers in the table. The results are identical with those
of ILUT(1, 10−4 ) shown in Table 10.3, for the first four problems, but there is an
improvement for the fifth problem.

10.4.5

The ILUS Approach

The ILU preconditioners discussed so far are based mainly on the the IKJvariant
of Gaussian elimination. Different types of ILUs can be derived using other forms
of Gaussian elimination. The main motivation for the version to be described next
is that ILUT does not take advantage of symmetry. If A is symmetric, then the
resulting M = LU is nonsymmetric in general. Another motivation is that in many
applications including computational fluid dynamics and structural engineering, the
resulting matrices are stored in a sparse skyline (SSK) format rather than the standard
Compressed Sparse Row format.
← sparse column

sparse row →

Figure 10.14: Illustration of the sparse skyline format.
In this format, the matrix A is decomposed as
A = D + L1 + LT2
in which D is a diagonal of A and L1 , L2 are strictly lower triangular matrices. Then
a sparse representation of L1 and L2 is used in which, typically, L1 and L2 are stored
in the CSR format and D is stored separately.
Incomplete Factorization techniques may be developed for matrices in this format without having to convert them into the CSR format. Two notable advantages of
this approach are (1) the savings in storage for structurally symmetric matrices, and
(2) the fact that the algorithm gives a symmetric preconditioner when the original
matrix is symmetric.

10.4. THRESHOLD STRATEGIES AND ILUT
Consider the sequence of matrices

Ak
Ak+1 =
wk

vk
αk+1

331



,

where An = A. If Ak is nonsingular and its LDU factorization
Ak = Lk Dk Uk
is already available, then the LDU factorization of Ak+1 is



Lk 0
Dk
0
Uk
Ak+1 =
yk 1
0 dk+1
0

zk
1



in which
zk = Dk−1 L−1
k vk

(10.37)

wk Uk−1 Dk−1

(10.38)

yk =

dk+1 = αk+1 − yk Dk zk .

(10.39)

Hence, the last row/column pairs of the factorization can be obtained by solving
two unit lower triangular systems and computing a scaled dot product. This can be
exploited for sparse matrices provided an appropriate data structure is used to take
advantage of the sparsity of the matrices Lk , Uk as well as the vectors vk , wk , yk ,
and zk . A convenient data structure for this is to store the rows/columns pairs wk , vkT
as a single row in sparse mode. All these pairs are stored in sequence. The diagonal
elements are stored separately. This is called the Unsymmetric Sparse Skyline (USS)
format. Each step of the ILU factorization based on this approach will consist of two
approximate sparse linear system solutions and a sparse dot product. The question
that arises is: How can a sparse triangular system be solved inexpensively? It would
seem natural to solve the triangular systems (10.37) and (10.38) exactly and then
drop small terms at the end, using a numerical dropping strategy. However, the total
cost of computing the ILU factorization with this strategy would be O(n2 ) operations
at least, which is not acceptable for very large problems. Since only an approximate
solution is required, the first idea that comes to mind is the truncated Neumann series,
p
−1
2
zk = Dk−1 L−1
k vk = Dk (I + Ek + Ek + . . . + Ek )vk

(10.40)

in which Ek ≡ I − Lk . In fact, by analogy with ILU(p), it is interesting to note that
the powers of Ek will also tend to become smaller as p increases. A close look at the
structure of Ekp vk shows that there is indeed a strong relation between this approach
and ILU(p) in the symmetric case. Now we make another important observation,
namely, that the vector Ekj vk can be computed in sparse-sparse mode, i.e., in terms
of operations involving products of sparse matrices by sparse vectors. Without exploiting this, the total cost would still be O(n2 ). When multiplying a sparse matrix
A by a sparse vector v, the operation can best be done by accumulating the linear
combinations of the columns of A. A sketch of the resulting ILUS algorithm is as
follows.

332

CHAPTER 10. PRECONDITIONING TECHNIQUES

A LGORITHM 10.7 ILUS(ǫ, p)

1.
2.
3.
4.
5.
6.
7.

Set A1 = D1 = a11 , L1 = U1 = 1
For i = 1, . . . , n − 1 Do:
Compute zk by (10.40) in sparse-sparse mode
Compute yk in a similar way
Apply numerical dropping to yk and zk
Compute dk+1 via (10.39)
EndDo

If there are only i nonzero components in the vector v and an average of ν nonzero
elements per column, then the total cost per step will be 2 × i × ν on the average.
Note that the computation of dk via (10.39) involves the inner product of two sparse
vectors which is often implemented by expanding one of the vectors into a full vector
and computing the inner product of a sparse vector by this full vector. As mentioned
before, in the symmetric case ILUS yields the Incomplete Cholesky factorization.
Here, the work can be halved since the generation of yk is not necessary.
Also note that a simple iterative procedure such as MR or GMRES(m) can be
used to solve the triangular systems in sparse-sparse mode. Similar techniques will
be seen in Section 10.5. Experience shows that these alternatives are not much better
than the Neumann series approach [79].

10.4.6

The Crout ILU Approach

A notable disadvantage of the standard delayed-update IKJ factorization is that
it requires access to the entries in the k-th row of L in sorted order of columns.
This is further complicated by the fact that the working row (denoted by w in Algorithm 10.6), is dynamically modified by fill-in as the elimination proceeds. Searching
for the leftmost entry in the k-th row of L is usually not a problem when the fill-in
allowed is small. Otherwise, when an accurate factorization is sought, it can become
a significant burden and may ultimately even dominate the cost of the factorization.
Sparse direct solution methods that are based on the IKJ form of Gaussian elimination obviate this difficulty by a technique known as the Gilbert-Peierls method [146].
Because of dropping, this technique cannot, however, be used as is. Another possible
option is to reduce the cost of the searches through the use of clever data structures
and algorithms, such as binary search trees or heaps [90].
The Crout formulation provides the most elegant solution to the problem. In fact
the Crout version of Gaussian elimination has other advantages which make it one of
the most appealing ways of implementing incomplete LU factorizations.
The Crout form of Gaussian elimination consists of computing, at step k, the
entries ak+1:n,k (in the unit lower triangular factor, L) and ak,k:n (in the upper triangular factor, U ). This is done by post-poning the rank-one update in a way similar
to the IKJ variant. In Figure 10.15 the parts of the factors being computed at the
k-th step are shown in black and those being accessed are in the shaded areas. At the
k-th step, all the updates of the previous steps are applied to the entries ak+1:n,k and
ak,k:n and it is therefore convenient to store L by columns and U by rows.

10.4. THRESHOLD STRATEGIES AND ILUT

333

Figure 10.15: Computational pattern of the Crout algorithm.
A LGORITHM 10.8 Crout LU Factorization

1.
2.
3.
4.
5.
6.
7.
8.
9.

For k = 1 : n Do :
For i = 1 : k − 1 and if aki 6= 0 Do :
ak,k:n = ak,k:n − aki ∗ ai,k:n
EndDo
For i = 1 : k − 1 and if aik 6= 0 Do :
ak+1:n.k = ak+1:n,k − aik ∗ ak+1:n,i
EndDo
aik = aik /akk for i = k + 1, ..., n
EndDo

The k-th step of the algorithm generates the k-th row of U and the k-th column of
L. This step is schematically represented in Figure 10.16. The above Algorithm will
now be adapted to the sparse case. Sparsity is taken into account and a dropping
strategy is included, resulting in the following Crout version of ILU (termed ILUC).
A LGORITHM 10.9 ILUC - Crout version of ILU

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

For k = 1 : n Do :
Initialize row z : z1:k−1 = 0, zk:n = ak,k:n
For {i | 1 ≤ i ≤ k − 1 and lki 6= 0} Do :
zk:n = zk:n − lki ∗ ui,k:n
EndDo
Initialize column w: w1:k = 0, wk+1:n = ak+1:n,k
For {i | 1 ≤ i ≤ k − 1 and uik 6= 0} Do :
wk+1:n = wk+1:n − uik ∗ lk+1:n,i
EndDo
Apply a dropping rule to row z
Apply a dropping rule to column w

CHAPTER 10. PRECONDITIONING TECHNIQUES

334

12.
13.
14.

uk,: = z
l:,k = w/ukk ,
Enddo

lkk = 1

Two potential sources of difficulty will require a careful and somewhat complex
implementation. First, looking at Lines 4 and 8, only the section (k : n) of the i-th
row of U is required, and similarly, only the section (k + 1 : n) of the i-th column of
L is needed. Second, Line 3 requires access to the k-th row of L which is stored by
columns while Line 7 requires access to the k-th column of U which is accessed by
rows.
The first issue can be easily handled by keeping pointers that indicate where the
relevant part of each row of U (resp. column of L) starts. An array Ufirst is used
to store for each row i of U the index of the first column that will used next. If k is
the current step number, this means that Ufirst(i) holds the first column index > k
of all nonzero entries in the the i-th row of U . These pointers are easily updated after
each elimination step, assuming that column indices (resp. column indices for L) are
in increasing order.

Figure 10.16: Computing the k-th row of U (left side) and the k-column of L (right
side).
For the second issue, consider the situation with the U factor. The problem is
that the k-th column of U is required for the update of L, but U is stored row-wise.
An elegant solution to this problem is known since the pioneering days of sparse direct methods [115, 144]. Before discussing this idea, consider the simpler solution
of including a linked list for each column of U . These linked lists would be easy
to update because the rows of U are computed one at a time. Each time a new row
is computed, the nonzero entries of this row are queued to the linked lists of their
corresponding columns. However, this scheme would entail nonnegligible additional
storage. A clever alternative is to exploit the array Ufirst mentioned above to form
incomplete linked lists of each column. Every time k is incremented the Ufirst

10.4. THRESHOLD STRATEGIES AND ILUT

335

array is updated. When Ufirst(i) is updated to point to a new nonzero with column
index j, then the row index i is added to the linked list for column i. What is interesting is that though the columns structures constructed in this manner are incomplete,
they become complete as soon as they are needed. A similar technique is used for
the rows of the L factor.
In addition to avoiding searches, the Crout version of ILU has another important
advantage. It enables some new dropping strategies which may be viewed as more
rigorous than the standard ones seen so far. The straightforward dropping rules used
in ILUT can be easily adapted for ILUC. In addition, the data structure of ILUC
allows options which are based on estimating the norms of the inverses of L and U .
For ILU preconditioners, the error made in the inverses of the factors is more
important to control than the errors in the factors themselves. This is because when
A = LU , and
L̃−1 = L−1 + X
Ũ −1 = U −1 + Y,
then the preconditioned matrix is given by
L̃−1 AŨ −1 = (L−1 + X)A(U −1 + Y ) = I + AY + XA + XY.
If the errors X and Y in the inverses of L and U are small, then the preconditioned
matrix will be close to the identity matrix. On the other hand, small errors in the
factors themselves may yield arbitrarily large errors in the preconditioned matrix.
Let Lk denote the matrix composed of the first k rows of L and the last n − k
rows of the identity matrix. Consider a term ljk with j > k that is dropped at step
k. Then, the resulting perturbed matrix L̃k differs from Lk by ljk ej eTk . Noticing that
Lk ej = ej then,
L̃k = Lk − ljk ej eTk = Lk (I − ljk ej eTk )
from which this relation between the inverses follows:
T −1
−1
T −1 −1
L̃−1
k = (I − ljk ej ek ) Lk = Lk + ljk ej ek Lk .

Therefore, the inverse of Lk will be perturbed by ljk times the k-th row of L−1
k . This
.
Hence,
using
the
infinity
norm
for
examperturbation will affect the j-th row of L−1
k
ple, it is important to limit the norm of this perturbing row which is kljk ej eTk L−1
k k∞ .
It follows that it is a good strategy to drop a term in L when
|ljk | keTk L−1
k k∞ < ǫ.
A similar criterion can be used for the upper triangular factor U .
This strategy is not complete because the matrix L−1 is not available. However,
standard techniques used for estimating condition numbers [149] can be adapted for
estimating the norm of the k-th row of L−1 (resp. k-th column of U −1 ). The idea
is to construct a vector b one component at a time, by following a greedy strategy
to make L−1 b large at each step. This is possible because the first k − 1 columns
of L are available at the k-th step. The simplest method constructs a vector b of
components βk = ±1 at each step k, in such a way as to maximize the norm of the

336

CHAPTER 10. PRECONDITIONING TECHNIQUES

k-th component of L−1 b. Since the first k − 1 columns of L are available at step k,
the k-th component of the solution x is given by
ξk = βk − eTk Lk−1 xk−1 .
This makes the choice clear: if ξk is to be large in modulus, then the sign of βk should
be opposite that of eTk Lk−1 xk−1 . If b is the current right-hand side at step k, then
keTk L−1 k∞ can be estimated by the k-th component of the solution x of the system
Lx = b:
−1
|eT
−1
k L b|
keT
.
k L k∞ ≈
kbk∞

Details, along with other strategies for dynamically building b, may be found in
[202].

10.5

Approximate Inverse Preconditioners

The Incomplete LU factorization techniques were developed originally for M -matrices
which arise from the discretization of Partial Differential Equations of elliptic type,
usually in one variable. For the common situation where A is indefinite, standard ILU
factorizations may face several difficulties, and the best known is the fatal breakdown
due to the encounter of a zero pivot. However, there are other problems that are just
as serious. Consider an incomplete factorization of the form
A = LU + E

(10.41)

where E is the error. The preconditioned matrices associated with the different forms
of preconditioning are similar to
L−1 AU −1 = I + L−1 EU −1 .

(10.42)

What is sometimes missed is the fact that the error matrix E in (10.41) is not as
important as the “preconditioned” error matrix L−1 EU −1 shown in (10.42) above.
When the matrix A is diagonally dominant, then L and U are well conditioned, and
the size of L−1 EU −1 remains confined within reasonable limits, typically with a
nice clustering of its eigenvalues around the origin. On the other hand, when the
original matrix is not diagonally dominant, L−1 or U −1 may have very large norms,
causing the error L−1 EU −1 to be very large and thus adding large perturbations to
the identity matrix. It can be observed experimentally that ILU preconditioners can
be very poor in these situations which often arise when the matrices are indefinite, or
have large nonsymmetric parts.
One possible remedy is to try to find a preconditioner that does not require solving a linear system. For example, the original system can be preconditioned by a
matrix M which is a direct approximation to the inverse of A.

10.5. APPROXIMATE INVERSE PRECONDITIONERS

10.5.1

337

Approximating the Inverse of a Sparse Matrix

A simple technique for finding approximate inverses of arbitrary sparse matrices is
to attempt to find a sparse matrix M which minimizes the Frobenius norm of the
residual matrix I − AM ,
F (M ) = kI − AM k2F .
(10.43)
A matrix M whose value F (M ) is small would be a right-approximate inverse of A.
Similarly, a left-approximate inverse can be defined by using the objective function
kI − M Ak2F .

(10.44)

Finally, a left-right pair L, U can be sought to minimize
kI − LAU k2F .

(10.45)

In the following, only (10.43) and(10.45) are considered. The case (10.44) is
very similar to the right preconditioner case (10.43). The objective function (10.43)
decouples into the sum of the squares of the 2-norms of the individual columns of
the residual matrix I − AM ,
F (M ) = kI − AM k2F =

n
X
j=1

kej − Amj k22

(10.46)

in which ej and mj are the j-th columns of the identity matrix and of the matrix M ,
respectively. There are two different ways to proceed in order to minimize (10.46).
The function (10.43) can be minimized globally as a function of the sparse matrix
M , e.g., by a gradient-type method. Alternatively, the individual functions
fj (m) = kej − Amk22 ,

j = 1, 2, . . . , n

(10.47)

can be minimized. The second approach is appealing for parallel computers, although there is also parallelism to be exploited in the first approach. These two
approaches will be discussed in turn.

10.5.2

Global Iteration

The global iteration approach consists of treating M as an unknown sparse matrix
and using a descent-type method to minimize the objective function (10.43). This
function is a quadratic function on the space of n × n matrices, viewed as objects in
2
Rn . The proper inner product on the space of matrices, to which the squared norm
(10.46) is associated, is
hX, Y i = tr(Y T X).
(10.48)

In the following, an array representation of an n2 vector X means the n × n matrix
whose column vectors are the successive n-vectors of X.
In a descent algorithm, a new iterate Mnew is defined by taking a step along a
selected direction G, i.e.,
Mnew = M + αG

CHAPTER 10. PRECONDITIONING TECHNIQUES

338

in which α is selected to minimize the objective function F (Mnew ). From results
seen in Chapter 5, minimizing the residual norm is equivalent to imposing the condition that R − αAG be orthogonal to AG with respect to the h·, ·i inner product.
Thus, the optimal α is given by
α=

hR, AGi
tr(RT AG)
=
.
hAG, AGi
tr ((AG)T AG)

(10.49)

The denominator may be computed as kAGk2F . The resulting matrix M will tend to
become denser after each descent step and it is therefore essential to apply a numerical dropping strategy to the resulting M . However, the descent property of the step
is now lost, i.e., it is no longer guaranteed that F (Mnew ) ≤ F (M ). An alternative
would be to apply numerical dropping to the direction of search G before taking the
descent step. In this case, the amount of fill-in in the matrix M cannot be controlled.
The simplest choice for the descent direction G is to take it to be equal to the
residual matrix R = I − AM , where M is the new iterate. Except for the numerical dropping step, the corresponding descent algorithm is nothing but the Minimal Residual (MR) algorithm, seen in Section 5.3.2, on the n2 × n2 linear system
AM = I. The global Minimal Residual algorithm will have the following form.
A LGORITHM 10.10 Global Minimal Residual Descent Algorithm

1.
2.
3.
4.
5.
6.
7.

Select an initial M
Until convergence Do:
Compute C := AM and G := I − C
Compute α = tr(GT AG)/kAGk2F
Compute M := M + αG
Apply numerical dropping to M
EndDo

A second choice is to take G to be equal to the direction of steepest descent, i.e.,
the direction opposite to the gradient of the function (10.43) with respect to M . If
all vectors as represented as 2-dimensional n × n arrays, then the gradient can be
viewed as a matrix G, which satisfies the following relation for small perturbations
E,
F (M + E) = F (M ) + hG, Ei + o(kEk).
(10.50)
This provides a way of expressing the gradient as an operator on arrays, rather than
n2 vectors.
Proposition 10.9 The array representation of the gradient of F with respect to M is
the matrix
G = −2AT R
in which R is the residual matrix R = I − AM .

10.5. APPROXIMATE INVERSE PRECONDITIONERS

339

Proof. For any matrix E we have


F (M + E) − F (M ) = tr (I − A(M + E))T (I − A(M + E))


−tr (I − AM )T (I − AM )


= tr (R − AE)T (R − AE) − RT R


= −tr (AE)T R + RT AE − (AE)T (AE)


= −2tr(RT AE) + tr (AE)T (AE)
= −2 AT R, E + hAE, AEi .

Comparing this with (10.50) yields the desired result.
Thus, the steepest descent algorithm will consist of replacing G in line 3 of
Algorithm 10.10 by G = AT R = AT (I − AM ). As is expected with steepest
descent techniques, the algorithm can be slow.
A LGORITHM 10.11 Global Steepest Descent Algorithm

1.
2.
3.
4.
5.
6.
7.

Select an initial M
Until convergence Do:
Compute R = I − AM , and G := AT R ;
Compute α = kGk2F /kAGk2F
Compute M := M + αG
Apply numerical dropping to M
EndDo

In either steepest descent or minimal residual, the G matrix must be stored explicitly. The scalars kAGk2F and tr(GT AG) needed to obtain α in these algorithms
can be computed from the successive columns of AG, which can be generated, used,
and discarded. As a result, the matrix AG need not be stored.

10.5.3

Column-Oriented Algorithms

Column-oriented algorithms consist of minimizing the individual objective functions
(10.47) separately. Each minimization can be performed by taking a sparse initial
guess and solving approximately the n parallel linear subproblems
Amj = ej ,

j = 1, 2, . . . , n

(10.51)

with a few steps of a nonsymmetric descent-type method, such as MR or GMRES. If
these linear systems were solved (approximately) without taking advantage of sparsity, the cost of constructing the preconditioner would be of order n2 . That is because
each of the n columns would require O(n) operations. Such a cost would become
unacceptable for large linear systems. To avoid this, the iterations must be performed
in sparse-sparse mode, a term which was already introduced in Section 10.4.5. The
column mj and the subsequent iterates in the MR algorithm must be stored and operated on as sparse vectors. The Arnoldi basis in the GMRES algorithm are now to

340

CHAPTER 10. PRECONDITIONING TECHNIQUES

be kept in sparse format. Inner products and vector updates involve pairs of sparse
vectors.
In the following MR algorithm, ni iterations are used to solve (10.51) approximately for each column, giving an approximation to the j-th column of the inverse
of A. Each initial mj is taken from the columns of an initial guess, M0 .
A LGORITHM 10.12 Approximate Inverse via MR Iteration

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Start: set M = M0
For each column j = 1, . . . , n Do:
Define mj = M ej
For i = 1, . . . , nj Do:
rj := ej − Amj
(r ,Ar )
αj := (Arjj ,Arjj )
mj := mj + αj rj
Apply numerical dropping to mj
EndDo
EndDo

The algorithm computes the current residual rj and then minimizes the residual
norm kej − A(mj + αrj )k2 , with respect to α. The resulting column is then pruned
by applying the numerical dropping step in line 8.
In the sparse implementation of MR and GMRES, the matrix-vector product,
SAXPY, and dot product kernels now all involve sparse vectors. The matrix-vector
product is much more efficient if the sparse matrix is stored by columns, since all
the entries do not need to be traversed. Efficient codes for all these kernels may be
constructed which utilize a full n-length work vector.
Columns from an initial guess M0 for the approximate inverse are used as the
initial guesses for the iterative solution of the linear subproblems. There are two obvious choices: M0 = αI and M0 = αAT . The scale factor α is chosen to minimize
the norm of I − AM0 . Thus, the initial guess is of the form M0 = αG where G is
either the identity or AT . The optimal α can be computed using the formula (10.49),
in which R is to be replaced by the identity, so α = tr(AG)/tr(AG(AG)T ). The
identity initial guess is less expensive to use but M0 = αAT is sometimes a much
better initial guess. For this choice, the initial preconditioned system AM0 is SPD.
The linear systems needed to solve when generating each column of the approximate inverse may themselves be preconditioned with the most recent version of the
preconditioning matrix M . Thus, each system (10.51) for approximating column j
may be preconditioned with M0′ where the first j − 1 columns of M0′ are the mk that
already have been computed, 1 ≤ k < j, and the remaining columns are the initial
guesses for the mk , j ≤ k ≤ n. Thus, outer iterations can be defined which sweep
over the matrix, as well as inner iterations which compute each column. At each
outer iteration, the initial guess for each column is taken to be the previous result for
that column.

10.5. APPROXIMATE INVERSE PRECONDITIONERS

10.5.4

341

Theoretical Considerations

The first theoretical question which arises is whether or not the approximate inverses
obtained by the approximations described earlier can be singular. It cannot be proved
that M is nonsingular unless the approximation is accurate enough. This requirement
may be in conflict with the requirement of keeping the approximation sparse.
Proposition 10.10 Assume that A is nonsingular and that the residual of the approximate inverse M satisfies the relation
kI − AM k < 1

(10.52)

where k.k is any consistent matrix norm. Then M is nonsingular.
Proof. The result follows immediately from the equality
AM = I − (I − AM ) ≡ I − N.

(10.53)

Since kN k < 1, Theorem 1.11 seen in Chapter 1 implies that I − N is nonsingular.
The result is true in particular for the Frobenius norm which is consistent (see Chapter
1).
It may sometimes be the case that AM is poorly balanced and as a result R
can be large. Then balancing AM can yield a smaller norm and possibly a less
restrictive condition for the nonsingularity of M . It is easy to extend the previous
result as follows. If A is nonsingular and two nonsingular diagonal matrices D1 , D2
exist such that
kI − D1 AM D2 k < 1
(10.54)
where k.k is any consistent matrix norm, then M is nonsingular.
Each column is obtained independently by requiring a condition on the residual
norm of the form
kej − Amj k ≤ τ,
(10.55)
for some vector norm k.k. From a practical point of view the 2-norm is preferable
since it is related to the objective function which is used, namely, the Frobenius norm
of the residual I − AM . However, the 1-norm is of particular interest since it leads to
a number of simple theoretical results. In the following, it is assumed that a condition
of the form
kej − Amj k1 ≤ τj
(10.56)
is required for each column.
The above proposition does not reveal anything about the degree of sparsity of
the resulting approximate inverse M . It may well be the case that in order to guarantee nonsingularity, M must be dense, or nearly dense. In fact, in the particular case
where the norm in the proposition is the 1-norm, it is known that the approximate

342

CHAPTER 10. PRECONDITIONING TECHNIQUES

inverse may be structurally dense, in that it is always possible to find a sparse matrix
A for which M will be dense if kI − AM k1 < 1.
Next, we examine the sparsity of M and prove a simple result for the case where
an assumption of the form (10.56) is made.
Proposition 10.11 Assume that M is an approximate inverse of A computed by enforcing the condition (10.56). Let B = A−1 and assume that a given element bij of
B satisfies the inequality
|bij | > τj max |bik |,
(10.57)
k=1,n

then the element mij is nonzero.
Proof. From the equality AM = I − R we have M = A−1 − A−1 R, and hence
mij = bij −

n
X

bik rkj .

|mij | ≥ |bij | −

n
X

|bik rkj |

k=1

Therefore,

k=1

≥ |bij | − max |bik | krj k1
k=1,n

≥ |bij | − max |bik |τj .
k=1,n

Now the condition (10.57) implies that |mij | > 0.
The proposition implies that if R is small enough, then the nonzero elements of M
are located in positions corresponding to the larger elements in the inverse of A. The
following negative result is an immediate corollary.
Corollary 10.12 Assume that M is an approximate inverse of A computed by enforcing the condition (10.56) and let τ = maxj=1,...,n τj . If the nonzero elements of
B = A−1 are τ -equimodular in that
|bij | > τ

max

k=1,n, l=1,n

|blk |,

then the nonzero sparsity pattern of M includes the nonzero sparsity pattern of A−1 .
In particular, if A−1 is dense and its elements are τ -equimodular, then M is also
dense.
The smaller the value of τ , the more likely the condition of the corollary will be satisfied. Another way of stating the corollary is that accurate and sparse approximate
inverses may be computed only if the elements of the actual inverse have variations
in size. Unfortunately, this is difficult to verify in advance and it is known to be true
only for certain types of matrices.

10.5. APPROXIMATE INVERSE PRECONDITIONERS

10.5.5

343

Convergence of Self Preconditioned MR

We now examine the convergence of the MR algorithm in the case where self preconditioning is used, but no numerical dropping is applied. The column-oriented algorithm is considered first. Let M be the current approximate inverse at a given substep. The self preconditioned MR iteration for computing the j-th column of the next
approximate inverse is obtained by the following sequence of operations:
rj := ej − Amj = ej − AM ej
tj := M rj
(r ,At )
αj := (Atjj ,Atjj )
mj := mj + αj tj .

1.
2.
3.
4.

Note that αj can be written as
αj =

(rj , Crj )
(rj , AM rj )
≡
(AM rj , AM rj )
(Crj , Crj )

where
C = AM
is the preconditioned matrix at the given substep. The subscript j is now dropped to
simplify the notation. The new residual associated with the current column is given
by
r new = r − αAt = r − αAM r ≡ r − αCr.
The orthogonality of the new residual against AM r can be used to obtain
kr new k22 = krk22 − α2 kCrk22 .
Replacing α by its value defined above we get
"

2 #
(Cr,
r)
kr new k22 = krk22 1 −
.
kCrk2 krk2
Thus, at each inner iteration, the residual norm for the j-th column is reduced according to the formula
kr new k2 = krk2 sin ∠(r, Cr)

(10.58)

in which ∠(u, v) denotes the acute angle between the vectors u and v. Assume that
each column converges. Then, the preconditioned matrix C converges to the identity.
As a result of this, the angle ∠(r, Cr) will tend to ∠(r, r) = 0, and therefore the convergence ratio sin ∠(r, Cr) will also tend to zero, showing superlinear convergence.
Now consider equation (10.58) more carefully. Denote by R the residual matrix
R = I − AM and observe that
kr − α Crk2
sin ∠(r, Cr) = min
α
krk2
kRrk2
kr − Crk2
≡
≤
krk2
krk2
≤ kRk2 .

CHAPTER 10. PRECONDITIONING TECHNIQUES

344

This results in the following statement.
Proposition 10.13 Assume that the self preconditioned MR algorithm is employed
with one inner step per iteration and no numerical dropping. Then the 2-norm of each
residual ej − Amj of the j-th column is reduced by a factor of at least kI − AM k2 ,
where M is the approximate inverse before the current step, i.e.,
krjnew k2 ≤ kI − AM k2 krj k2 .

(10.59)

In addition, the residual matrices Rk = I − AMk obtained after each outer iteration
satisfy
kRk+1 kF ≤ kRk k2F .
(10.60)
As a result, when the algorithm converges, it does so quadratically.
Proof. Inequality (10.59) was proved above. To prove quadratic convergence, first
use the inequality kXk2 ≤ kXkF and (10.59) to obtain
krjnew k2 ≤ kRk,j kF krj k2 .
Here, the k index corresponds to the outer iteration and the j-index to the column.
Note that the Frobenius norm is reduced for each of the inner steps corresponding to
the columns, and therefore,
kRk,j kF ≤ kRk kF .
This yields
krjnew k22 ≤ kRk k2F krj k22
which, upon summation over j, gives
kRk+1 kF ≤ kRk k2F .
This completes the proof.
Note that the above theorem does not prove convergence. It only states that when
the algorithm converges, it does so quadratically at the limit. In addition, the result
ceases to be valid in the presence of dropping.
Consider now the case of the global iteration. When self preconditioning is incorporated into the global MR algorithm (Algorithm 10.10), the search direction
becomes Zk = Mk Rk , where Rk is the current residual matrix. Then, the main steps
of the algorithm (without dropping) are as follows.
1.
2.
3.
4.

Rk := I − AMk
Zk := Mk Rk
hRk ,AZk i
αk := hAZ
k ,AZk i
Mk+1 := Mk + αk Zk

10.5. APPROXIMATE INVERSE PRECONDITIONERS

345

At each step the new residual matrix Rk+1 satisfies the relation
Rk+1 = I − AMk+1 = I − A(Mk + αk Zk ) = Rk − αk AZk .
An important observation is that Rk is a polynomial in R0 . This is because, from the
above relation,
Rk+1 = Rk − αk AMk Rk = Rk − αk (I − Rk )Rk = (1 − αk )Rk + αk Rk2 . (10.61)
Therefore, induction shows that Rk+1 = p2k (R0 ) where pj is a polynomial of degree
j. Now define the preconditioned matrices,
Bk ≡ AMk = I − Rk .

(10.62)

Then, the following recurrence follows from (10.61),
Bk+1 = Bk + αk Bk (I − Bk )

(10.63)

and shows that Bk+1 is also a polynomial of degree 2k in B0 . In particular, if the
initial B0 is symmetric, then so are all subsequent Bk ’s. This is achieved when the
initial M is a multiple of AT , namely if M0 = α0 AT .
Similar to the column oriented case, when the algorithm converges it does so
quadratically.
Proposition 10.14 Assume that the self preconditioned global MR algorithm is used
without dropping. Then, the residual matrices obtained at each iteration satisfy
kRk+1 kF ≤ kRk2 kF .

(10.64)

As a result, when the algorithm converges, then it does so quadratically.
Proof. Define for any α,
R(α) = (1 − α)Rk + αRk2
Recall that αk achieves the minimum of kR(α)kF over all α’s. In particular,
kRk+1 kF

= min kR(α)kF
α

≤ kR(1)kF = kRk2 kF
≤

kRk k2F .

This proves quadratic convergence at the limit.
For further properties see Exercise 16.

(10.65)

346

10.5.6

CHAPTER 10. PRECONDITIONING TECHNIQUES

Approximate Inverses via bordering

A notable disadvantage of the right or left preconditioning approach method is that it
is difficult to assess in advance whether or not the resulting approximate inverse M is
nonsingular. An alternative would be to seek a two-sided approximation, i.e., a pair
L, U , with L lower triangular and U upper triangular, which attempts to minimize
the objective function (10.45). The techniques developed in the previous sections
can be exploited for this purpose.
In the factored approach, two matrices L and U which are unit lower and upper
triangular matrices are sought such that
LAU ≈ D
where D is some unknown diagonal matrix. When D is nonsingular and LAU = D,
then L, U are called inverse LU factors of A since in this case A−1 = U D −1 L.
Once more, the matrices are built one column or row at a time. Assume as in Section
10.4.5 that we have the sequence of matrices


Ak
vk
Ak+1 =
wk αk+1
in which An ≡ A. If the inverse factors Lk , Uk are available for Ak , i.e.,
Lk Ak Uk = Dk ,
then the inverse factors Lk+1 , Uk+1 for Ak+1 are easily obtained by writing



 

Lk 0
Ak
vk
Uk −zk
Dk
0
=
(10.66)
−yk 1
wk αk+1
0
1
0 δk+1
in which zk , yk , and δk+1 are such that
Ak zk = vk

(10.67)

yk Ak = wk

(10.68)

δk+1 = αk+1 − wk zk = αk+1 − yk vk .

(10.69)

Note that the formula (10.69) exploits the fact that either the system (10.67) is solved
exactly (middle expression) or the system (10.68) is solved exactly (second expression) or both systems are solved exactly (either expression). In the realistic situation
where neither of these two systems is solved exactly, then this formula should be
replaced by
δk+1 = αk+1 − wk zk − yk vk + yk Ak zk .
(10.70)
The last row/column pairs of the approximate factored inverse can be obtained by
solving two sparse systems and computing a few dot products. It is interesting to
note that the only difference with the ILUS factorization seen in Section 10.4.5 is
that the coefficient matrices for these systems are not the triangular factors of Ak ,
but the matrix Ak itself.

10.5. APPROXIMATE INVERSE PRECONDITIONERS

347

To obtain an approximate factorization, simply exploit the fact that the Ak matrices are sparse and then employ iterative solvers in sparse-sparse mode. In this
situation, formula (10.70) should be used for δk+1 . The algorithm would be as follows.
A LGORITHM 10.13 Approximate Inverse Factors Algorithm

1.
2.
3.
4.
5.

For k = 1, . . . , n Do:
Solve (10.67) approximately;
Solve (10.68) approximately;
Compute δk+1 = αk+1 − wk zk − yk vk + yk Ak zk
EndDo

A linear system must be solved with Ak in line 2 and a linear system with ATk in
line 3. This is a good scenario for the Biconjugate Gradient algorithm or its equivalent two-sided Lanczos algorithm. In addition, the most current approximate inverse
factors can be used to precondition the linear systems to be solved in steps 2 and 3.
This was termed “self preconditioning” earlier. All the linear systems in the above
algorithm can be solved in parallel since they are independent of one another. The
diagonal D can then be obtained at the end of the process.
This approach is particularly suitable in the symmetric case. Since there is only
one factor, the amount of work is halved. In addition, there is no problem with the
existence in the positive definite case as is shown in the following lemma which states
that δk+1 is always > 0 when A is SPD, independently of the accuracy with which
the system (10.67) is solved.
Lemma 10.15 Let A be SPD. Then, the scalar δk+1 as computed by (10.70) is positive.
Proof. In the symmetric case, wk = vkT . Note that δk+1 as computed by formula
(10.70) is the (k + 1, k + 1) element of the matrix Lk+1 Ak+1 LTk+1 . It is positive
because Ak+1 is SPD. This is independent of the accuracy for solving the system to
obtain zk .
In the general nonsymmetric case, there is no guarantee that δk+1 will be nonzero,
unless the systems (10.67) and (10.68) are solved accurately enough. There is no
practical problem here, since δk+1 is computable. The only question remaining is
a theoretical one: Can δk+1 be guaranteed to be nonzero if the systems are solved
with enough accuracy? Intuitively, if the system is solved exactly, then the D matrix
must be nonzero since it is equal to the D matrix of the exact inverse factors in this
∗
be
case. The minimal assumption to make is that each Ak is nonsingular. Let δk+1
the value that would be obtained if at least one of the systems (10.67) or (10.68) is
solved exactly. According to equation (10.69), in this situation this value is given by
∗
= αk+1 − wk A−1
δk+1
k vk .

(10.71)

CHAPTER 10. PRECONDITIONING TECHNIQUES

348

∗
6= 0. To see this refer to the defining equation
If Ak+1 is nonsingular, then δk+1
(10.66) and compute the product Lk+1 Ak+1 Uk+1 in the general case. Let rk and sk
be the residuals obtained for these linear systems, i.e.,

rk = vk − Ak zk ,

sk = wk − yk Ak .

(10.72)

Then a little calculation yields
Lk+1 Ak+1 Uk+1 =



Lk Ak Uk
s k Uk

L k rk
δk+1



.

(10.73)

If one of rk or sk is zero, then it is clear that the term δk+1 in the above relation be∗
comes δk+1
and it must be nonzero since the matrix on the left-hand side is nonsingular. Incidentally, this relation shows the structure of the last matrix Ln An Un ≡ LAU .
The components 1 to j − 1 of column j consist of the vector Lj rj , the components
1 to j − 1 of row i make up the vector sk Uk , and the diagonal elements are the δi ’s.
Consider now the expression for δk+1 from (10.70).
δk+1 = αk+1 − wk zk − yk vk + yk Ak zk

−1
−1
= αk+1 − wk A−1
k (vk − rk ) − (wk − sk )Ak vk + (vk − rk )Ak (wk − sk )
−1
= αk+1 − vk A−1
k wk + rk Ak sk
∗
= δk+1
+ rk A−1
k sk .

∗ | =
This perturbation formula is of a second order in the sense that |δk+1 − δk+1
∗
O(krk k ksk k). It guarantees that δk+1 is nonzero whenever |rk A−1
k sk | < |δk+1 |.

10.5.7

Factored inverses via orthogonalization: AINV

The approximate inverse technique (AINV) described in [34, 36] computes an approximate factorization of the form W T AZ = D, where W, Z are unit upper triangular matrices, and D is a diagonal. The matrices W and Z can be directly computed
by performing an approximate bi-orthogonalization of the Gram-Schmidt type. Indeed, when A = LDU is the exact LDU factorization of A, then W should be equal
to the inverse of L and we should have the equality
W T A = DU
which means that W T A is upper triangular. This translates into the result that any
column i of W is orthogonal to the first i − 1 columns of A. A procedure to compute
W is therefore to make the i-th column of W orthogonal to the columns 1, . . . , i − 1
of A by subtracting multiples of the first i − 1 columns of W . Alternatively, columns
i + 1, . . . , n of W can be made orthogonal to the first i columns of A. This will
produce columns that are orthogonal to each of the columns of A. During this procedure one can drop small entries, or entries outside a certain sparsity pattern. A
similar process can be applied to obtain the columns of Z. The resulting incomplete biorthogonalization process, which is sketched next, produces an approximate
factored inverse.

10.5. APPROXIMATE INVERSE PRECONDITIONERS

349

A LGORITHM 10.14 Right–looking factored AINV

Let p = q = (0, . . . , 0) ∈ Rn , Z = [z1 , . . . , zn ] = In , W = [w1 , . . . , wn ] = In .
For k = 1, . . . , n
pk = wkT Aek , qk = eTk Azk
For i = k + 1, . . ., n

pi = wiT Aek /pk , qi = eTk Azi /qk
Apply a dropping rule to pi , qi
wi = wi − wk pi , zi = zi − zk qi
Apply a dropping rule to wj,i and zj,i , for j = 1, . . . , i.
EndDo
EndDo
Choose diagonal entries of D as the components of p or q .

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

The above algorithm constitutes one of two options for computing factored approximate inverses via approximate orthogonalization. An alternative is based on the fact
that W T AZ should become approximately diagonal. Instead of orthogonalizing W
(resp. Z) with respect to the columns of A, a bi-orthogonalization process can be
applied to force the columns of W and Z to be conjugate with respect to A. For this
we must require that eTk W T AZej = 0 for all k 6= j, 1 ≤ k, j ≤ i. The result will be
a simple change to Algorithm 10.14. Specifically, the second option, which we label
with a (b), replaces lines (3) and (5) into the following lines:
3a.
5b.

pk = wkT Azk , qk = wkT Azk

pi = wiT Azk /pk , qi = wkT Azi /qk

If no entries are dropped and if an LDU factorization of A exists, then W = LT , Z =
U −1 . A little induction proof would then show that after step i, columns i + 1, . . . , n
of W are orthogonal to column 1, . . . , i of A and likewise columns i + 1, . . . , n of
Z are orthogonal to rows 1, . . . , i of A. Remarkably, the computations of Z and W
can be performed independently of each other for the original option represented by
Algorithm 10.14.
In the original version of AINV [34, 36], dropping is performed on the vectors wi
and zi only. Dropping entries from pi , qi seems to not yield as good approximations,
see [34].

10.5.8

Improving a Preconditioner

After a computed ILU factorization results in an unsatisfactory convergence, it is
difficult to improve it by modifying the L and U factors. One solution would be to
discard this factorization and attempt to recompute a fresh one possibly with more
fill-in. Clearly, this may be a wasteful process. A better alternative is to use approximate inverse techniques. Assume a (sparse) matrix M is a preconditioner to the
original matrix A, so the preconditioned matrix is
C = M −1 A.

350

CHAPTER 10. PRECONDITIONING TECHNIQUES

A sparse matrix S is sought to approximate the inverse of M −1 A. This matrix is
then to be used as a preconditioner to M −1 A. Unfortunately, the matrix C is usually
dense. However, observe that all that is needed is a matrix S such that
AS ≈ M.
Recall that the columns of A and M are sparse. One approach is to compute a
least-squares approximation in the Frobenius norm sense. This approach was used
already in Section 10.5.1 when M is the identity matrix. Then the columns of S were
obtained by approximately solving the linear systems Asi ≈ ei . The same idea can
be applied here. Now, the systems
Asi = mi
must be solved instead, where mi is the i-th column of M which is sparse. Thus, the
coefficient matrix and the right-hand side are sparse, as before.

10.6

Reordering for ILU

The primary goal of reordering techniques (see Chapter 3) is to reduce fill-in during
Gaussian elimination. A difficulty with such methods, whether in the context of direct or iterative solvers, is that a good ordering for reducing fill-in may lead to factors
of poor numerical quality. For example, very small diagonal entries may be encountered during the process. Two types of permutations are often used to enhance ILU
factorizations. First, fill-reducing symmetric permutations of the type seen in Chapter 3 have been advocated. The argument here is that since these permutations are
likely to produce fewer fill-ins, it is likely that the ILU factorizations resulting from
dropping small terms will be more accurate. A second category of reorderings consists of only permuting the rows of the matrix (or its columns). These unsymmetric
permutations address the other issue mentioned above, namely avoiding poor pivots
in Gaussian elimination.

10.6.1

Symmetric permutations

The Reverse Cuthill McKee ordering seen in Section 3.3.3 is among the most common techniques used to enhance the effectiveness of ILU factorizations. Recall that
this reordering is designed to reduce the envelope of a matrix. Other reorderings
that are geared specifically toward reducing fill-in, such as the minimum degree or
multiple minimum degree orderings, have also been advocated, though results reported in the literature are mixed. What is clear is that the results will depend on the
accuracy of the ILU being computed. If ILU(0), or some low-fill, incomplete factorization is being used, then it is often reported that it is generally not a good idea
to reorder the matrix. Among candidate permutations that can be applied, the RCM
is the most likely to yield an improvement. As the accuracy of the preconditioner
increases, i.e. as more fill-ins are allowed, then the beneficial effect of reordering

10.6. REORDERING FOR ILU

351

becomes compelling. In many test, see for example [35], a preconditioner built on
an RCM or Minimum Degree reordered matrix will work while the same preconditioner built from the original ordering fails. In addition, success is often achieved
with less memory than is required for the original ordering. This general observation
is illustrated in the following tests.
Example 10.6. The following experiments shows the performance of GMRES(20)
preconditioned with ILUT for the five test problems described in Section 3.7 of Chapter 3. The first experiment uses ILU T (5, 0.25). Prior to performing the ILUT factorization the coefficient matrix is reordered by three possible techniques: Reverse
Cuthill Mc Kee ordering (RCM), Minimum degree ordering (QMD), or Nested Dissection ordering (ND). The FORTRAN codes for these three techniques are those
available in the book [144]. It is now important to show the amount of memory
used by the factorization, which is measured here by the fill-factor, i.e., the ratio of
the number of nonzero elements required to store the LU factors over the original
number of nonzero elements. This is referred to as Fill in the tables. Along with
this measure, Table 10.6 shows the number of iterations required to reduce the initial
residual by a factor of 10−7 with GMRES(20). Notice that reordering does not help.
The RCM ordering is the best among the three orderings, with a performance that is
close to that of the original ordering, but it fails on the FIDAP matrix. In many other
instances we have tested, RCM does often help or its performance is close to that
achieved by the original ordering. The other reorderings, minimal degree and nested
dissection, rarely help when the factorization is inaccurate as is the case here.
None

RCM

QMD

ND

Martix

Iters

Fill

Iters

Fill

Iters

Fill

Iters

Fill

F2DA

15

1.471

16

1.448

19

1.588

20

1.592

F3D

12

1.583

13

1.391

16

1.522

15

1.527

ORS

20

0.391

20

0.391

20

0.477

20

0.480

F2DB

21

1.430

21

1.402

41

1.546

55

1.541

FID

66

1.138

300

1.131

300

0.978

300

1.032

Table 10.6: Iteration count and fill-factor for GMRES(20) – ILUT(5,0.25) with three
different reordering techniques.
We now turn to a more accurate preconditioner, namely ILUT(10, 0.01). The
results of Table 10.7 show a different picture from the one above. All reorderings
are now basically helpful. A slight exception is the minimum degree ordering which
fails on the FIDAP matrix. However, notice that this failure can be explained by the
low fill-factor, which is the smallest achieved by all the reorderings. What is more,
good convergence of GMRES is now achieved at a lesser cost of memory.

CHAPTER 10. PRECONDITIONING TECHNIQUES

352
None

RCM

QMD

ND

Martix

Iters

Fill

Iters

Fill

Iters

Fill

Iters

Fill

F2DA

7

3.382

6

3.085

8

2.456

9

2.555

F3D

8

3.438

7

3.641

11

2.383

10

2.669

ORS

9

0.708

9

0.699

9

0.779

9

0.807

F2DB

10

3.203

8

2.962

12

2.389

12

2.463

FID

197

1.798

38

1.747

300

1.388

36

1.485

Table 10.7: Iteration count and fill-factor for GMRES(20) – ILUT(10,0.01) with
three different reordering techniques.
If one ignores the fill-factor it may appear that RCM is best. QMD seems to be
good at reducing fill-in but results in a poor factorization. When memory cost is taken
into account the more sophisticated nested dissection ordering is the overall winner
in all cases except for the ORSIR matrix. This conclusion, namely that reordering is
most beneficial when relatively accurate factorizations are computed, is borne out by
other experiments in the literature, see, for example [35].

10.6.2

Nonsymmetric reorderings

Nonsymmetric permutations can be applied to enhance the performance of preconditioners for matrices with extremely poor structure. Such techniques do not perform
too well in other situations, such as for example, for linear systems arising from the
discretization of elliptic PDEs.
The original idea on which nonsymmetric reorderings are based is to find a permutation matrix Qπ , so that the matrix
B = Qπ A

(10.74)

has large entries in its diagonal. Here π is a permutation array and Qπ the corresponding permutation matrix as defined in Section 3.3. In contrast with standard
fill-reducing techniques, this is a one sided permutation which reorders the rows of
the matrix.
The first algorithm considered in this class attempts to find an ordering of the
form (10.74) which guarantees that the diagonal entries of B are nonzero. In this
case, the permutation matrix Qπ can be viewed from a new angle, that of bipartite
transverals.
A transversal or bipartite matching is a a set M of ordered pairs (i, j) such that
aij 6= 0 and the column indices j and row indices i appear only once. This corresponds to selecting one nonzero diagonal element per row/column. The usual repre-

10.6. REORDERING FOR ILU
Rows

Columns

1

1

353

★

Rows

Columns

1

1

2

2

3

3

4

4

5

5

6

6

★
★
★

2

2

★
★
★

★
3

3

4

4

Original matrix

★
★
5

5

★
★
★

6

★
★

6

Bipartite graph

★
Reordered matrix

Maximum transversal

Figure 10.17: Example of a maximum transversal. Left side: bipartite representation
of matrix. Right side: maximum transversal. Middle: matrix before and after row
reordering.
sentation uses a graph whose vertices are the rows of A (squares in Figure 10.17) and
columns of A (circle in Figure 10.17). There is an outgoing edge between a row i
and a column j when aij 6= 0. A transversal is simply a subgraph of G that is bipartite. The transversal is maximum when it has maximum cardinality. For example, in
Figure 10.17 the set
M = {(1, 2), (2, 1), (3, 3), (4, 5), (5, 6), (6, 4)}
is a maximum transversal. The corresponding row permutation is π = {2, 1, 3, 6, 4, 5}
and the reordered matrix is shown in the bottom middle part of the figure.
When A is structurally nonsingular, it can be shown that the maximum transversal has cardinality |M| = n. Finding the maximum transversal is a well-known
problem in management sciences and has received much attention by researchers in
graph theory. In particular, graph-traversal algorithms based on depth-first search
and breadth-first searches, have been developed to find maximum transversals.
These maximum transversal algorithms are the simplest among a class of techniques. The criterion of just finding nonzero diagonal elements to put on the diagonal
is not sufficient and can be changed into one of finding a (row) permutation π so at
to
n
Y
|ai,π(i) | .
(10.75)
maximize
i=1

A heuristic for achieving a large product of the diagonal entries is the so-called bottleneck strategy whose goal is to maximize the smallest diagonal entry. The algorithm
removes enough small elements and finds a maximum transversal of the graph. If the

CHAPTER 10. PRECONDITIONING TECHNIQUES

354

transversal is not of cardinality n then the algorithm backtracks by removing fewer
of the small entries and repeating the process.
Another class of algorithms solve the optimization problem (10.75) more accurately. This problem can be translated into

n
X
log [ ka:,j k∞ / |aij | ] if aij 6= 0
.
ci,π(i)
where
cij =
min
π
+∞
otherwise
i=1

It is known that solving this problem is equivalent to solving its dual, which can be
formulated as follows:


n
n
X

X
max
uj
subject to: cij − ui − uj ≥ 0 .
ui +
ui ,uj 

i=1

j=1

The algorithms used to solve the above dual problem are based on graph theory
techniques - in fact they can be viewed as traversal algorithms (such as depth first
search) to which a cost measure is added. Details can be found in [110].
Experiments reported by Duff and Koster [110] and Benzi et al. [32] show that
nonsymmetric reorderings based on the methods discussed in this section can be
quite beneficial for those problems which are irregularly structured and have many
zero diagonal entries. On the other hand, they do not perform as well for PDE matrices for which symmetric orderings are often superior.

10.7

Block Preconditioners

Block preconditioning is a popular technique for block-tridiagonal matrices arising
from the discretization of elliptic problems. It can also be generalized to other sparse
matrices. We begin with a discussion of the block-tridiagonal case.

10.7.1

Block-Tridiagonal Matrices

Consider a block-tridiagonal matrix blocked in the form


D1 E2
 F2 D2

E3


.
.
.

.
.
.
.
A=
.
.
.


Fm−1 Dm−1 Em 
Fm
Dm

(10.76)

One of the most popular block preconditioners used in the context of PDEs is based
on this block-tridiagonal form of the coefficient matrix A. Let D be the blockdiagonal matrix consisting of the diagonal blocks Di , L the block strictly-lower triangular matrix consisting of the sub-diagonal blocks Fi , and U the block strictly-upper
triangular matrix consisting of the super-diagonal blocks Ei . Then, the above matrix
has the form
A = L + D + U.

10.7. BLOCK PRECONDITIONERS

355

A block ILU preconditioner is defined by
M = (L + ∆)∆−1 (∆ + U ),

(10.77)

where L and U are the same as above, and ∆ is a block-diagonal matrix whose blocks
∆i are defined by the recurrence:
∆i = Di − Fi Ωi−1 Ei ,

(10.78)

in which Ωj is some sparse approximation to ∆−1
j . Thus, to obtain a block factorization, approximations to the inverses of the blocks ∆i must be found. This clearly
will lead to difficulties if explicit inverses are used.
An important particular case is when the diagonal blocks Di of the original matrix are tridiagonal, while the co-diagonal blocks Ei and Fi are diagonal. Then, a
simple recurrence formula for computing the inverse of a tridiagonal matrix can be
exploited. Only the tridiagonal part of the inverse must be kept in the recurrence
(10.78). Thus,
∆1 = D1 ,
∆i =

(10.79)

(3)
Di − Fi Ωi−1 Ei ,

i = 1, . . . , m,

(10.80)

(3)

where Ωk is the tridiagonal part of ∆−1
k .
(3)

(Ωk )i,j = (∆−1
k )i,j

for

|i − j| ≤ 1.

The following theorem can be shown.
Theorem 10.16 Let A be Symmetric Positive Definite and such that
• aii > 0, i = 1, . . . , n, and aij ≤ 0 for all j 6= i.
• The matrices Di are all (strict) diagonally dominant.
Then each block ∆i computed by the recurrence (10.79), (10.80) is a symmetric M matrix. In particular, M is also a positive definite matrix.
We now show how the inverse of a tridiagonal matrix can be obtained. Let a
tridiagonal matrix ∆ of dimension l be given in the form


α1 −β2
 −β2 α2

−β3


.
.
.

,
.
.
.
∆=
.
.
.


−βl−1 αl−1 −βl 
−βl
αl

and let its Cholesky factorization be

∆ = LDLT ,

CHAPTER 10. PRECONDITIONING TECHNIQUES

356
with

D = diag {δi }
and



1
 −γ2

L=



1
..
.

..



.

−γl−1

1
−γl

1



.



The inverse of ∆ is L−T D −1 L−1 . Start by observing that the inverse of LT is a unit
upper triangular matrix whose coefficients uij are given by
uij = γi+1 γi+2 . . . γj−1 γj

for 1 ≤ i < j < l.

As a result, the j-th column cj of L−T is related to the (j − 1)-st column cj−1 by the
very simple recurrence,
cj = ej + γj cj−1 ,

for

j≥2

starting with the first column c1 = e1 . The inverse of ∆ becomes
∆

−1

=L

−T

D

−1

L

−1

=

l
X
1
j=1

δj

cj cTj .

(10.81)

See Exercise 12 for a proof of the above equality. As noted, the recurrence formulas
for computing ∆−1 can be unstable and lead to numerical difficulties for large values
of l.

10.7.2

General Matrices

A general sparse matrix can often be put in the form (10.76) where the blocking is
either natural as provided by the physical problem, or artificial when obtained as a
result of RCMK ordering and some block partitioning. In such cases, a recurrence
such as (10.78) can still be used to obtain a block factorization defined by (10.77).
A 2-level preconditioner can be defined by using sparse inverse approximate techniques to approximate Ωi . These are sometimes termed implicit-explicit preconditioners, the implicit part referring to the block-factorization and the explicit part to
the approximate inverses used to explicitly approximate ∆−1
i .

10.8

Preconditioners for the Normal Equations

When the original matrix is strongly indefinite, i.e., when it has eigenvalues spread
on both sides of the imaginary axis, the usual Krylov subspace methods may fail.
The Conjugate Gradient approach applied to the normal equations may then become
a good alternative. Choosing to use this alternative over the standard methods may

10.8. PRECONDITIONERS FOR THE NORMAL EQUATIONS

357

involve inspecting the spectrum of a Hessenberg matrix obtained from a small run of
an unpreconditioned GMRES algorithm.
If the normal equations approach is chosen, the question becomes how to precondition the resulting iteration. An ILU preconditioner can be computed for A and
the preconditioned normal equations,
AT (LU )−T (LU )−1 Ax = AT (LU )−T (LU )−1 b,
can be solved. However, when A is not diagonally dominant the ILU factorization
process may encounter a zero pivot. Even when this does not happen, the resulting preconditioner may be of poor quality. An incomplete factorization routine with
pivoting, such as ILUTP, may constitute a good choice. ILUTP can be used to precondition either the original equations or the normal equations shown above. This
section explores a few other options available for preconditioning the normal equations.

10.8.1

Jacobi, SOR, and Variants

There are several ways to exploit the relaxation schemes for the Normal Equations
seen in Chapter 8 as preconditioners for the CG method applied to either (8.1) or
(8.3). Consider (8.3), for example, which requires a procedure delivering an approximation to (AAT )−1 v for any vector v. One such procedure is to perform one step
of SSOR to solve the system (AAT )w = v. Denote by M −1 the linear operator that
transforms v into the vector resulting from this procedure, then the usual Conjugate
Gradient method applied to (8.3) can be recast in the same form as Algorithm 8.5.
This algorithm is known as CGNE/SSOR. Similarly, it is possible to incorporate the
SSOR preconditioning in Algorithm 8.4, which is associated with the Normal Equations (8.1), by defining M −1 to be the linear transformation that maps a vector v
into a vector w resulting from the forward sweep of Algorithm 8.2 followed by a
backward sweep. We will refer to this algorithm as CGNR/SSOR.
The CGNE/SSOR and CGNR/SSOR algorithms will not break down if A is nonsingular, since then the matrices AAT and AT A are Symmetric Positive Definite, as
are the preconditioning matrices M . There are several variations to these algorithms.
The standard alternatives based on the same formulation (8.1) are either to use the
preconditioner on the right, solving the system AT AM −1 y = b, or to split the preconditioner into a forward SOR sweep on the left and a backward SOR sweep on
the right of the matrix AT A. Similar options can also be written for the Normal
Equations (8.3) again with three different ways of preconditioning. Thus, at least six
different algorithms can be defined.

10.8.2

IC(0) for the Normal Equations

The Incomplete Cholesky IC(0) factorization can be used to precondition the Normal
Equations (8.1) or (8.3). This approach may seem attractive because of the success
of incomplete factorization preconditioners. However, a major problem is that the

CHAPTER 10. PRECONDITIONING TECHNIQUES

358

Incomplete Cholesky factorization is not guaranteed to exist for an arbitrary Symmetric Positive Definite matrix B. All the results that guarantee existence rely on
some form of diagonal dominance. One of the first ideas suggested to handle this
difficulty was to use an Incomplete Cholesky factorization on the “shifted” matrix
B + αI. We refer to IC(0) applied to B = AT A as ICNR(0), and likewise IC(0)
applied to B = AAT as ICNE(0). Shifted variants correspond to applying IC(0) to
the shifted B matrix.

220

210

iterations

200

190

180

170

160

150
0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1

alpha

Figure 10.18: Iteration count as a function of the shift α.
One issue often debated is how to find good values for the shift α. There is no
easy and well-founded solution to this problem for irregularly structured symmetric
sparse matrices. One idea is to select the smallest possible α that makes the shifted
matrix diagonally dominant. However, this shift tends to be too large in general
because IC(0) may exist for much smaller values of α. Another approach is to determine the smallest α for which the IC(0) factorization exists. Unfortunately, this
is not a viable alternative. As is often observed, the number of steps required for
convergence starts decreasing as α increases, and then increases again. The illustration shown in Figure 10.18 is from a real example using a small Laplacean matrix.
This plot suggests that there is an optimal value for α which is far from the smallest
admissible one.
For small α, the diagonal dominance of B + αI is weak and, as a result, the
computed IC factorization is a poor approximation to the matrix B(α) ≡ B + αI.
In other words, B(α) is close to the original matrix B, but the IC(0) factorization
is far from B(α). For large α, the opposite is true. The matrix B(α) has a large
deviation from B(0), but its IC(0) factorization may be quite good. Therefore, the
general shape of the curve shown in the figure is not too surprising.
To implement the algorithm, the matrix B = AAT need not be formed explicitly.
All that is required is to be able to access one row of B at a time. This row can be
computed, used, and then discarded. In the following, the i-th row eTi A of A is
denoted by ai . The algorithm is row-oriented and all vectors denote row vectors. It

10.8. PRECONDITIONERS FOR THE NORMAL EQUATIONS

359

is adapted from the ILU(0) factorization of a sparse matrix, i.e., Algorithm 10.4, but
it actually computes the LDLT factorization instead of an LU or LLT factorization.
The main difference with Algorithm 10.4 is that the loop in line 7 is now restricted
to j ≤ i because of symmetry. If only the lij elements are stored row-wise, then the
rows of U = LT which are needed in this loop are not directly available. Denote
the j-th row of U = LT by uj . These rows are accessible by adding a column data
structure for the L matrix which is updated dynamically. A linked list data structure
can be used for this purpose. With this in mind, the IC(0) algorithm will have the
following structure.
A LGORITHM 10.15 Shifted ICNE(0)

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.

Initial step: Set d1 := a11 , l11 = 1
For i = 2, 3, . . . , n Do:
Obtain all the nonzero inner products
lij = (aj , ai ), j = 1, 2, . . . , i − 1, and lii := kai k2 + α
Set N Z(i) ≡ {j | lij 6= 0}
For k = 1, . . . , i − 1 and if k ∈ N Z(i) Do:
Extract row uk = (Lek )T
Compute lik := lik /dk
For j = k + 1, . . . , i and if (i, j) ∈ N Z(i) Do:
Compute lik := lik − lij ukj
EndDo
EndDo
Set di := lii , lii := 1
EndDo

Note that initially the row u1 in the algorithm is defined as the first row of A. All
vectors in the algorithm are row vectors.
The step represented by lines 3 and 4, which computes the inner products of row
number i with all previous rows, needs particular attention. If the inner products
aT1 ai , aT2 ai , . . . , aTi−1 ai
are computed separately, the total cost of the incomplete factorization would be of
the order of n2 steps and the algorithm would be of little practical value. However,
most of these inner products are equal to zero because of sparsity. This indicates that
it may be
possible to compute only those nonzero inner products at a much lower cost.
Indeed, if c is the column of the i − 1 inner products cij , then c is the product of the
rectangular (i − 1) × n matrix Ai−1 whose rows are aT1 , . . . , aTi−1 by the vector ai ,
i.e.,
c = Ai−1 ai .
(10.82)
This is a sparse matrix-by-sparse vector product which was discussed in Section
10.5. It is best performed as a linear combination of the columns of Ai−1 which are

360

CHAPTER 10. PRECONDITIONING TECHNIQUES

sparse. The only difficulty with this implementation is that it requires both the row
data structure of A and of its transpose. A standard way to handle this problem is
by building a linked-list data structure for the transpose. There is a similar problem
for accessing the transpose of L, as mentioned earlier. Therefore, two linked lists
are needed: one for the L matrix and the other for the A matrix. These linked lists
avoid the storage of an additional real array for the matrices involved and simplify
the process of updating the matrix A when new rows are obtained. It is important to
note that these linked lists are used only in the preprocessing phase and are discarded
once the incomplete factorization terminates.

10.8.3

Incomplete Gram-Schmidt and ILQ

Consider a general sparse matrix A and denote its rows by a1 , a2 , . . . , an . The
(complete) LQ factorization of A is defined by
A = LQ,
where L is a lower triangular matrix and Q is unitary, i.e., QT Q = I. The L factor in
the above factorization is identical with the Cholesky factor of the matrix B = AAT .
Indeed, if A = LQ where L is a lower triangular matrix having positive diagonal
elements, then
B = AAT = LQQT LT = LLT .
The uniqueness of the Cholesky factorization with a factor L having positive diagonal
elements shows that L is equal to the Cholesky factor of B. This relationship can be
exploited to obtain preconditioners for the Normal Equations.
Thus, there are two ways to obtain the matrix L. The first is to form the matrix
B explicitly and use a sparse Cholesky factorization. This requires forming the data
structure of the matrix AAT , which may be much denser than A. However, reordering techniques can be used to reduce the amount of work required to compute L.
This approach is known as symmetric squaring.
A second approach is to use the Gram-Schmidt process. This idea may seem
undesirable at first because of its poor numerical properties when orthogonalizing
a large number of vectors. However, because the rows remain very sparse in the
incomplete LQ factorization (to be described shortly), any given row of A will be
orthogonal typically to most of the previous rows of Q. As a result, the GramSchmidt process is much less prone to numerical difficulties. From the data structure
point of view, Gram-Schmidt is optimal because it does not require allocating more
space than is necessary, as is the case with approaches based on symmetric squaring.
Another advantage over symmetric squaring is the simplicity of the orthogonalization
process and its strong similarity with the LU factorization. At every step, a given row
is combined with previous rows and then normalized. The incomplete Gram-Schmidt
procedure is modeled after the following algorithm.
A LGORITHM 10.16 LQ Factorization of A

10.8. PRECONDITIONERS FOR THE NORMAL EQUATIONS
1.
2.
3.
4.
5.

361

For i = 1, . . . , n Do:
Compute lij := (ai , qj ) , for j = 1, 2, . . . , i − 1,
P
Compute qi := ai − i−1
j=1 lij qj , and lii = kqi k2
If lii := 0 then Stop; else Compute qi := qi /lii .
EndDo

If the algorithm completes, then it will result in the factorization A = LQ where
the rows of Q and L are the rows defined in the algorithm. To define an incomplete
factorization, a dropping strategy similar to those defined for Incomplete LU factorizations must be incorporated. This can be done in very general terms as follows. Let
PL and PQ be the chosen zero patterns for the matrices L, and Q, respectively. The
only restriction on PL is that
PL ⊂ {(i, j) | i 6= j}.
As for PQ , for each row there must be at least one nonzero element, i.e.,
{j |(i, j) ∈ PQ } =
6 {1, 2, . . . , n},

for i = 1, . . . , n.

These two sets can be selected in various ways. For example, similar to ILUT, they
can be determined dynamically by using a drop strategy based on the magnitude of
the elements generated. As before, xi denotes the i-th row of a matrix X and xij its
(i, j)-th entry.
A LGORITHM 10.17 Incomplete Gram-Schmidt

1.
2.
3.
4.
5.
6.
7.
8.

For i = 1, . . . , n Do:
Compute lij := (ai , qj ) , for j = 1, 2, . . . , i − 1,
Replace lij by zero if (i, j) ∈ PL
P
Compute qi := ai − i−1
j=1 lij qj ,
Replace each qij , j = 1, . . . , n by zero if (i, j) ∈ PQ
lii := kqi k2
If lii = 0 then Stop; else compute qi := qi /lii .
EndDo

We recognize in line 2 the same practical problem encountered in the previous
section for IC(0) for the Normal Equations. It can be handled in the same manner.
Thus, the row structures of A, L, and Q are needed, as well as a linked list for the
column structure of Q.
After the i-th step is performed, the following relation holds:
qi = lii qi + ri = ai −
or
ai =

j
X
j=1

j−1
X

lij qj

j=1

lij qj + ri

(10.83)

362

CHAPTER 10. PRECONDITIONING TECHNIQUES

where ri is the row of elements that have been dropped from the row qi in line 5. The
above equation translates into
A = LQ + R
(10.84)
where R is the matrix whose i-th row is ri , and the notation for L and Q is as before.
The case where the elements in Q are not dropped, i.e., the case when PQ is the
empty set, is of particular interest. Indeed, in this situation, R = 0 and we have
the exact relation A = LQ. However, Q is not unitary in general because elements
are dropped from L. If at a given step lii = 0, then (10.83) implies that ai is a
linear combination of the rows q1 , . . ., qj−1 . Each of these qk is, inductively, a
linear combination of a1 , . . . ak . Therefore, ai would be a linear combination of the
previous rows, a1 , . . . , ai−1 which cannot be true if A is nonsingular. As a result, the
following proposition can be stated.
Proposition 10.17 If A is nonsingular and PQ = ∅, then the Algorithm 10.17 completes and computes an incomplete LQ factorization A = LQ, in which Q is nonsingular and L is a lower triangular matrix with positive elements.
A major problem with the decomposition (10.84) is that the matrix Q is not orthogonal in general. In fact, nothing guarantees that it is even nonsingular unless Q is not
dropped or the dropping strategy is made tight enough.
Because the matrix L of the complete LQ factorization of A is identical with the
Cholesky factor of B, one might wonder why the IC(0) factorization of B does not
always exist while the ILQ factorization seems to always exist. In fact, the relationship between ILQ and ICNE, i.e., the Incomplete Cholesky for B = AAT , can lead
to a more rigorous way of choosing a good pattern for ICNE, as is explained next.
We turn our attention to Modified Gram-Schmidt. The only difference is that the
row qj is updated immediately after an inner product is computed. The algorithm is
described without dropping for Q for simplicity.
A LGORITHM 10.18 Incomplete Modified Gram-Schmidt

1.
2.
3.
4.
5.
6.
7.
8.
9.

For i = 1, . . . , n Do:
qi := ai
For j = 1, . . . , i − 1
, Do:
0
if (i, j) ∈ PL
Compute lij :=
(qi , qj ) otherwise
Compute qi := qi − lij qj .
EndDo
lii := kqi k2
If lii = 0 then Stop; else Compute qi := qi /lii .
EndDo

When A is nonsingular, the same result as before is obtained if no dropping
is used on Q, namely, that the factorization will exist and be exact in that A =
LQ. Regarding the implementation, if the zero pattern PL is known in advance,
the computation of the inner products in line 4 does not pose a particular problem.

10.8. PRECONDITIONERS FOR THE NORMAL EQUATIONS

363

Without any dropping in Q, this algorithm may be too costly in terms of storage. It
is interesting to see that this algorithm has a connection with ICNE, the incomplete
Cholesky applied to the matrix AAT . The following result is stated without proof.
Theorem 10.18 Let A be an n × m matrix and let B = AAT . Consider a zeropattern set PL which is such that for any 1 ≤ i, j, k ≤ n, with i < j and i < k, the
following holds:
(i, j) ∈ PL and (i, k) ∈
/ PL → (j, k) ∈ PL .
Then the matrix L obtained from Algorithm 10.18 with the zero-pattern set PL is
identical with the L factor that would be obtained from the Incomplete Cholesky
factorization applied to B with the zero-pattern set PL .
For a proof, see [304]. This result shows how a zero-pattern can be defined which
guarantees the existence of an Incomplete Cholesky factorization on AAT .

P ROBLEMS
P-10.1 Assume that A is the Symmetric Positive Definite matrix arising from the 5-point
finite difference discretization of the Laplacean on a given mesh. We reorder the matrix using
the red-black ordering and obtain the reordered matrix


D1 E
.
B=
E T D2
We then form the Incomplete Cholesky factorization on this matrix.
a. Show the fill-in pattern for the IC(0) factorization for a matrix of size n = 12 associated
with a 4 × 3 mesh.

b. Show the nodes associated with these fill-ins on the 5-point stencil in the finite difference mesh.
c. Give an approximate count of the total number of fill-ins when the original mesh is
square, with the same number of mesh points in each direction. How does this compare
with the natural ordering? Any conclusions?
P-10.2 Consider a 6 × 6 tridiagonal nonsingular matrix A.

a. What can be said about its ILU(0) factorization (when it exists)?

b. Suppose that the matrix is permuted (symmetrically, i.e., both rows and columns) using
the permutation
π = [1, 3, 5, 2, 4, 6].
(i) Show the pattern of the permuted matrix.
(ii) Show the locations of the fill-in elements in the ILU(0) factorization.
(iii) Show the pattern of the ILU(1) factorization as well as the fill-ins generated.
(iv) Show the level of fill of each element at the end of the ILU(1) process (including the fill-ins).
(v) What can be said of the ILU(2) factorization for this permuted matrix?

364

CHAPTER 10. PRECONDITIONING TECHNIQUES

P-10.3 Assume that A is the matrix arising from the 5-point finite difference discretization
of an elliptic operator on a given mesh. We reorder the original linear system using the
red-black ordering and obtain the reordered linear system
  
 

x1
b1
D1 E
=
.
F D2
x2
b2
a. Show how to obtain a system (called the reduced system) which involves the variable
x2 only.
b. Show that this reduced system is also a sparse matrix. Show the stencil associated
with the reduced system matrix on the original finite difference mesh and give a graphtheory interpretation of the reduction process. What is the maximum number of nonzero
elements in each row of the reduced system.
P-10.4 It was stated in Section 10.3.2 that for some specific matrices the ILU(0) factorization of A can be put in the form
M = (D − E)D−1 (D − F )
in which −E and −F are the strict-lower and -upper parts of A, respectively.

a. Characterize these matrices carefully and give an interpretation with respect to their
adjacency graphs.

b. Verify that this is true for standard 5-point matrices associated with any domain Ω.
c. Is it true for 9-point matrices?
d. Is it true for the higher level ILU factorizations?
P-10.5 Let A be a pentadiagonal matrix having diagonals in offset positions −m, −1, 0, 1, m.
The coefficients in these diagonals
√ are all constants: a for the main diagonal and -1 for all
others. It is assumed that a ≥ 8. Consider the ILU(0) factorization of A as given in the
form (10.20). The elements di of the diagonal D are determined by a recurrence of the form
(10.19).
a. Show that a2 < di ≤ a for i = 1, . . . , n.

b. Show that di is a decreasing sequence. [Hint: Use induction].
c. Prove that the formal (infinite) sequence defined by the recurrence converges. What is
its limit?
P-10.6 Consider a matrix A which is split in the form A = D0 − E − F , where D0 is a
block diagonal matrix whose block-diagonal entries are the same as those of A, and where
−E is strictly lower triangular and −F is strictly upper triangular. In some cases the block
form of the ILU(0) factorization can be put in the form (Section 10.3.2):
M = (D − E)D−1 (D − F ).
The block entries of D can be defined by a simple matrix recurrence. Find this recurrence
relation. The algorithm may be expressed in terms of the block entries the matrix A.
P-10.7 Generalize the formulas developed at the end of Section 10.7.1 for the inverses of
symmetric tridiagonal matrices, to the nonsymmetric case.
P-10.8 Develop recurrence relations for Incomplete Cholesky with no fill-in (IC(0)), for
5-point matrices, similar to those seen in Section 10.3.4 for ILU(0). Same question for IC(1).

10.8. PRECONDITIONERS FOR THE NORMAL EQUATIONS

365

P-10.9 What becomes of the formulas seen in Section 10.3.4 in the case of a 7-point matrix (for three-dimensional problems)? In particular, can the ILU(0) factorization be cast in
the form (10.20) in which −E is the strict-lower diagonal of A and −F is the strict upper
triangular part of A, and D is a certain diagonal?
P-10.10 Consider an arbitrary matrix A which is split in the usual manner as A = D0 −
E − F , in which −E and −F are the strict-lower and -upper parts of A, respectively, and
define, for any diagonal matrix D, the approximate factorization of A given by
M = (D − E)D−1 (D − F ).
Show how a diagonal D can be determined such that A and M have the same diagonal
elements. Find a recurrence relation for the elements of D. Consider now the symmetric
case and assume that the matrix D which is positive can be found. Write M in the form
M = (D1/2 − ED−1/2 )(D1/2 − ED−1/2 )T ≡ L1 LT1 .
What is the relation between this matrix and the matrix of the SSOR(ω) preconditioning, in
the particular case when D−1/2 = ωI? Conclude that this form of ILU factorization is in
effect an SSOR preconditioning with a different relaxation factor ω for each equation.
P-10.11 Consider a general sparse matrix A (irregularly structured). We seek an approximate LU factorization of the form
M = (D − E)D−1 (D − F )
in which −E and −F are the strict-lower and -upper parts of A, respectively. It is assumed
that A is such that
aii > 0,

aij aji ≥ 0 for i, j = 1, . . . , n.

a. By identifying the diagonal elements of A with those of M , derive an algorithm for
generating the elements of the diagonal matrix D recursively.
b. Establish that if dj > 0 for j<i then di ≤ aii . Is it true in general that dj >0 for all j?

c. Assume that for i = 1, . . . , j −1 we have di ≥ α>0. Show a sufficient condition under
which dj ≥ α. Are there cases in which this condition cannot be satisfied for any α?

d. Assume now that all diagonal elements of A are equal to a constant, i.e., ajj = a for
j = 1, . . . , n. Define α ≡ a2 and let
Sj ≡

j−1
X
i=1

aij aji ,

σ ≡ max Sj .
j=1,...,n

Show a condition on σ under which dj ≥ α, j = 1, 2, . . . , n.

P-10.12 Show the second part of (10.81). [Hint: Exploit the formula AB T =
where aj , bj are the j-th columns of A and B, respectively].

Pn

T
j=1 aj bj

P-10.13 Let a preconditioning matrix M be related to the original matrix A by M = A+E,
in which E is a matrix of rank k.
a. Assume that both A and M are Symmetric Positive Definite. How many steps at most
are required for the preconditioned Conjugate Gradient method to converge when M
is used as a preconditioner?

366

CHAPTER 10. PRECONDITIONING TECHNIQUES

b. Answer the same question for the case when A and M are nonsymmetric and the full
GMRES is used on the preconditioned system.
P-10.14 Formulate the problem for finding an approximate inverse M to a matrix A as a
large n2 × n2 linear system. What is the Frobenius norm in the space in which you formulate
this problem?
P-10.15 The concept of mask is useful in the global iteration technique. For a sparsity
pattern S, i.e., a set of pairs (i, j) and a matrix B, we define the product C = B ⊙ S to be the
matrix whose elements cij are zero if (i, j) does not belong to S, and bij otherwise. This is
called a mask operation since its effect is to ignore every value not in the pattern S. Consider
a global minimization of the function FS (M ) ≡ kS ⊙ (I − AM )kF .
a. What does the result of Proposition 10.9 become for this new objective function?

b. Formulate an algorithm based on a global masked iteration, in which the mask is fixed
and equal to the pattern of A.
c. Formulate an algorithm in which the mask is adapted at each outer step. What criteria
would you use to select the mask?
P-10.16 Consider the global self preconditioned MR iteration algorithm seen in Section 10.5.5.
Define the acute angle between two matrices as
cos ∠(X, Y ) ≡

hX, Y i
.
kXkF kY kF

a. Following what was done for the (standard) Minimal Residual algorithm seen in Chapter 5, establish that the matrices Bk = AMk and Rk = I − Bk produced by global
MR without dropping are such that
kRk+1 kF ≤ kRk kF sin ∠(Rk , Bk Rk ).
b. Let now M0 = αAT so that Bk is symmetric for all k (see Section 10.5.5). Assume
that, at a given step k the matrix Bk is positive definite. Show that
cos ∠(Rk , Bk Rk ) ≥

λmin (Bk )
λmax (Bk )

in which λmin (Bk ) and λmax (Bk ) are, respectively, the smallest and largest eigenvalues of Bk .
P-10.17 In the two-sided version of approximate inverse preconditioners, the option of minimizing
f (L, U ) = kI − LAU k2F
was mentioned, where L is unit lower triangular and U is upper triangular.
a. What is the gradient of f (L, U )?
b. Formulate an algorithm based on minimizing this function globally.
P-10.18 Consider the two-sided version of approximate inverse preconditioners, in which a
unit lower triangular L and an upper triangular U are sought so that LAU ≈ I. One idea is to
use an alternating procedure in which the first half-step computes a right approximate inverse
U to LA, which is restricted to be upper triangular, and the second half-step computes a left
approximate inverse L to AU , which is restricted to be lower triangular.

10.8. PRECONDITIONERS FOR THE NORMAL EQUATIONS

367

a. Consider the first half-step. Since the candidate matrix U is restricted to be upper
triangular, special care must be exercised when writing a column-oriented approximate
inverse algorithm. What are the differences with the standard MR approach described
by Algorithm 10.12?
b. Now consider seeking an upper triangular matrix U such that the matrix (LA)U is
close to the identity only in its upper triangular part. A similar approach is to be taken
for the second half-step. Formulate an algorithm based on this approach.
P-10.19 Write all six variants of the preconditioned Conjugate Gradient algorithm applied
to the Normal Equations, mentioned at the end of Section 10.8.1.
P-10.20 With the standard splitting A = D − E − F , in which D is the diagonal of A
and −E, −F its lower- and upper triangular parts, respectively, we associate the factored
approximate inverse factorization,
(I + ED−1 )A(I + D−1 F ) = D + R.

(10.85)

a. Determine R and show that it consists of second order terms, i.e., terms involving
products of at least two matrices from the pair E, F .
b. Now use the previous approximation for D + R ≡ D1 − E1 − F1 ,
(I + E1 D1−1 )(D + R)(I + D1−1 F1 ) = D1 + R1 .
Show how the approximate inverse factorization (10.85) can be improved using this
new approximation. What is the order of the resulting approximation?
N OTES AND R EFERENCES . The idea of transforming a linear system into one that is easier to solve by
iterations was known quite early on. In a 1937 paper, Cesari [71], proposed what is now known as polynomial preconditioning (see also [43, p.156] where this is discussed). Other forms of preconditioning
were also exploited in some earlier papers. For example, in [11] Axelsson discusses SSOR iteration,
“accelerated” by either the Conjugate Gradient or Chebyshev acceleration. Incomplete factorizations
were also discussed quite early, for example, by Varga [292] and Buleev [68]. The breakthrough article
by Meijerink and van der Vorst [208] established existence of the incomplete factorization for M matrices and showed that preconditioning the Conjugate Gradient by using an incomplete factorization
can result in an extremely efficient combination. This article played an essential role in directing the
attention of researchers and practitioners to a rather important topic and marked a turning point. Many
of the early techniques were developed for regularly structured matrices. The generalization, using the
definition of level of fill for high-order Incomplete LU factorizations for unstructured matrices, was
introduced by Watts [306] for petroleum engineering problems.
Recent research on iterative techniques has focussed on preconditioning methods while the importance of accelerators has diminished. Preconditioners are essential to the success of iterative methods
in real-life applications. A general preconditioning approach based on modifying a given direct solver
by including dropping was one of the first “general-purpose” that was proposed [212, 221, 325, 137].
More economical alternatives, akin to ILU(p), were developed later [249, 97, 96, 314, 323, 245].
ILUT and ILUTP are relatively robust and efficient but they can nonetheless fail. Instances can also
encountered when a more accurate ILUT factorization leads to a larger number of steps to converge.
One source of failure is the instability of the preconditioning operation. These phenomena of instability
have been studied by Elman [116] who proposed a detailed analysis of ILU and MILU preconditioners for model problems. The theoretical analysis on ILUT stated as Theorem 10.8 is modeled after
Theorem 1.14 in Axelsson and Barker [15] for ILU(0).
Some theory for block preconditioners is discussed in the book by O. Axelsson [14]. Different
forms of block preconditioners were developed independently by Axelsson, Brinkkemper, and Il’in
[16] and by Concus, Golub, and Meurant [89], initially for block matrices arising from PDEs in two dimensions. Later, some generalizations were proposed by Kolotina and Yeremin [191]. Thus, the 2-level

368

CHAPTER 10. PRECONDITIONING TECHNIQUES

implicit-explicit preconditioning introduced in [191] consists of using sparse inverse approximations to
for obtaining Ωi .
∆−1
i
The rebirth of approximate inverse preconditioners [158, 91, 191, 159, 34, 157, 33, 80, 78] has
been spurred both by considerations related to parallel processing and the relative ineffectiveness of
standard ILU preconditioners in dealing with highly indefinite matrices. Other preconditioners which
are not covered here are those based on domain decomposition techniques. Some of these techniques
will be reviewed in Chapter 14.
The primary motivation for the Crout version of ILU is the overhead in ILUT due to the search
for the leftmost pivot. The idea of exploiting condition number estimators in this context has been
motivated by compelling results in Bollhöefer’s work [44].
The effect of reordering on incomplete factorizations has been a subject of debate among researchers but the problem is still not well understood. What experience shows is that some of the better
reordering techniques used for sparse direct solutions methods do not necessarily perform well for ILU
[35, 64, 111, 112, 96, 97, 265]. As could be expected when fill-in is increased to high levels, then the
effect of reordering starts resembling that of direct solvers. A rule of thumb is that the reversed CuthillMcKee ordering does quite well on average. It appears that orderings that take into account the values
of the matrix can perform better, but these may be expensive [87, 96, 97]. The use of nonsymmetric
orderings as a means of enhancing robustness of ILU has been proposed in recent articles by Duff and
Koster [109, 110]. The algorithms developed in this context are rather complex but lead to remarkable
improvements, especially for matrices with very irregular patterns.
The saddle-point point problem is a classic example of what can be achieved by a preconditioner
developed by exploiting the physics versus a general purpose preconditioner. An ILUT factorization
for the saddle point problem may work if a high level of fill is used. However, this usually results in
poor performance. A better performance can be obtained by exploiting information about the original
problem, see for example, [152, 305, 264, 118, 119].
On another front, there is also some interest in methods that utilize normal equations in one way
or another. Earlier, ideas revolved around shifting the matrix B = AT A before applying the IC(0) factorization as was suggested by Kershaw [187] in 1978. Manteuffel [206] also made some suggestions
on how to select a good α in the context of the CGW algorithm. Currently, new ways of exploiting the
relationship with the QR (or LQ) factorization to define IC(0) more rigorously are being explored; see
the work in [304]. Preconditioning normal equations remains a difficult problem.

Chapter 11

PARALLEL IMPLEMENTATIONS

Parallel computing has recently gained widespread acceptance as a means of handling very large
computational tasks. Since iterative methods are appealing for large linear systems of equations,
it is no surprise that they are the prime candidates for implementations on parallel architectures.
There have been two traditional approaches for developing parallel iterative techniques thus far.
The first extracts parallelism whenever possible from standard algorithms. The advantage of
this viewpoint is that it is easier to understand in general since the underlying method has not
changed from its sequential equivalent. The second approach is to develop alternative algorithms
which have enhanced parallelism. This chapter will give an overview of implementations and will
emphasize methods in the first category. The later chapters will consider alternative algorithms
that have been developed specifically for parallel computing environments.

11.1

Introduction

Because of the increased importance of three-dimensional models and the high cost
associated with sparse direct methods for solving these problems, iterative techniques
play a major role in application areas. The main appeal of iterative methods is their
low storage requirement. Another advantage is that they are far easier to implement
on parallel computers than sparse direct methods because they only require a rather
small set of computational kernels. Increasingly, direct solvers are being used in
conjunction with iterative solvers to develop robust preconditioners.
The first considerations for high-performance implementations of iterative methods involved implementations on vector computers. These efforts started in the mid
1970s when the first vector computers appeared. Currently, there is a larger effort
to develop new practical iterative methods that are not only efficient in a parallel environment, but also robust. Often, however, these two requirements seem to be in
conflict.
This chapter begins with a short overview of the various ways in which parallelism has been exploited in the past and a description of the current architectural
models for existing commercial parallel computers. Then, the basic computations
required in Krylov subspace methods will be discussed along with their implemen369

CHAPTER 11. PARALLEL IMPLEMENTATIONS

370
tations.

11.2

Forms of Parallelism

Parallelism has been exploited in a number of different forms since the first computers were built. The six major forms of parallelism are: (1) multiple functional
units; (2) pipelining; (3) vector processing; (4) multiple vector pipelines; (5) multiprocessing; and (6) distributed computing. Next is a brief description of each of
these approaches.

11.2.1

Multiple Functional Units

This is one of the earliest forms of parallelism. It consists of multiplying the number
of functional units such as adders and multipliers. Thus, the control units and the
registers are shared by the functional units. The detection of parallelism is done
at compilation time with a “Dependence Analysis Graph,” an example of which is
shown in Figure 11.1.
+

+

a

+

b

*
c

*
d

e

f

Figure 11.1: Dependence analysis for arithmetic expression: (a + b) + (c ∗ d + d ∗ e).
In the example of Figure 11.1, the two multiplications can be performed simultaneously, then the two additions in the middle are performed simultaneously. Finally,
the addition at the root is performed.

11.2.2

Pipelining

The pipelining concept is essentially the same as that of an assembly line used in
car manufacturing. Assume that an operation takes s stages to complete. Then the
operands can be passed through the s stages instead of waiting for all stages to be
completed for the first two operands.
✲
✲

xi−3
yi−3

stage 1

✲

xi−2
yi−2

stage 2

✲

xi−1
yi−1

stage 3

✲

xi
yi

stage 4

✲

11.3. TYPES OF PARALLEL ARCHITECTURES

371

If each stage takes a time τ to complete, then an operation with n numbers will
take the time sτ + (n − 1)τ = (n + s − 1)τ . The speed-up would be the ratio of the
time to complete the s stages in a non-pipelined unit versus, i.e., s × n × τ , over the
above obtained time,
ns
.
S=
n+s−1
For large n, this would be close to s.

11.2.3

Vector Processors

Vector computers appeared in the beginning of the 1970s with the CDC Star 100
and then the CRAY-1 and Cyber 205. These are computers which are equipped with
vector pipelines, i.e., pipelined functional units, such as a pipelined floating-point
adder, or a pipelined floating-point multiplier. In addition, they incorporate vector
instructions explicitly as part of their instruction sets. Typical vector instructions are,
for example:
VLOAD
VADD
VMUL

To load a vector from memory to a vector register
To add the content of two vector registers
To multiply the content of two vector registers.

Similar to the case of multiple functional units for scalar machines, vector pipelines
can be duplicated to take advantage of any fine grain parallelism available in loops.
For example, the Fujitsu and NEC computers tend to obtain a substantial portion of
their performance in this fashion. There are many vector operations that can take
advantage of multiple vector pipelines.

11.2.4

Multiprocessing and Distributed Computing

A multiprocessor system is a computer, or a set of several computers, consisting
of several processing elements (PEs), each consisting of a CPU, a memory, an I/O
subsystem, etc. These PEs are connected to one another with some communication
medium, either a bus or some multistage network. There are numerous possible
configurations, some of which will be covered in the next section.
Distributed computing is a more general form of multiprocessing, in which the
processors are actually computers linked by some Local Area Network. Currently,
there are a number of libraries that offer communication mechanisms for exchanging
messages between Unix-based systems. The best known of these are the Parallel
Virtual Machine (PVM) and the Message Passing Interface (MPI). In heterogeneous
networks of computers, the processors are separated by relatively large distances and
that has a negative impact on the performance of distributed applications. In fact,
this approach is cost-effective only for large applications, in which a high volume of
computation can be performed before more data is to be exchanged.

11.3

Types of Parallel Architectures

There are currently three leading architecture models. These are:

CHAPTER 11. PARALLEL IMPLEMENTATIONS

372

• The shared memory model.
• SIMD or data parallel models.
• The distributed memory message passing model.
A brief overview of the characteristics of each of the three groups follows. Emphasis is on the possible effects these characteristics have on the implementations of
iterative methods.

11.3.1

Shared Memory Computers

A shared memory computer has the processors connected to a large global memory
with the same global view, meaning the address space is the same for all processors.
One of the main benefits of shared memory models is that access to data depends
very little on its location in memory. In a shared memory environment, transparent
data access facilitates programming to a great extent. From the user’s point of view,
data are stored in a large global memory that is readily accessible to any processor.
However, memory conflicts as well as the necessity to maintain data coherence can
lead to degraded performance. In addition, shared memory computers cannot easily
take advantage of data locality in problems which have an intrinsically local nature,
as is the case with most discretized PDEs. Some current machines have a physically
distributed memory but they are logically shared, i.e., each processor has the same
view of the global address space.
P

P

P

P

P

✻
❄

✻
❄

✻
❄

✻
❄

✻
❄

✻
❄

✻
❄

✻
❄

✻
❄

HIGH SPEED BUS

✻
❄

SHARED MEMORY

Figure 11.2: A bus-based shared memory computer.
M

M

M

M

M

M

M

M

SWITCHING NETWORK
P

P

P

P

P

P

P

P

Figure 11.3: A switch-based shared memory computer.
There are two possible implementations of shared memory machines: (1) busbased architectures, and (2) switch-based architecture. These two model architec-

11.3. TYPES OF PARALLEL ARCHITECTURES

373

tures are illustrated in Figure 11.2 and Figure 11.3, respectively. So far, shared memory computers have been implemented more often with buses than with switching
networks.
Buses are the backbone for communication between the different units of most
computers. Physically, a bus is nothing but a bundle of wires, made of either fiber
or copper. These wires carry information consisting of data, control signals, and
error correction bits. The speed of a bus, often measured in Megabytes per second
and called the bandwidth of the bus, is determined by the number of lines in the bus
and the clock rate. Often, the limiting factor for parallel computers based on bus
architectures is the bus bandwidth rather than the CPU speed.
The primary reason why bus-based multiprocessors are more common than switchbased ones is that the hardware involved in such implementations is simple. On the
other hand, the difficulty with bus-based machines is that the number of processors
which can be connected to the memory will be small in general. Typically, the bus is
timeshared, meaning slices of time are allocated to the different clients (processors,
IO processors, etc.) that request its use.
In a multiprocessor environment, the bus can easily be saturated. Several remedies are possible. The first, and most common, remedy is to attempt to reduce traffic
by adding local memories or caches attached to each processor. Since a data item
used by a given processor is likely to be reused by the same processor in the next
instructions, storing the data item in local memory will help reduce traffic in general.
However, this strategy causes some difficulties due to the requirement to maintain
data coherence. If Processor (A) reads some data from the shared memory, and Processor (B) modifies the same data in shared memory, immediately after, the result is
two copies of the same data that have different values. A mechanism should be put in
place to ensure that the most recent update of the data is always used. The additional
overhead incurred by such memory coherence operations may well offset the savings
involving memory traffic.
The main features here are the switching network and the fact that a global memory is shared by all processors through the switch. There can be p processors on one
side connected to p memory units or banks on the other side. Alternative designs
based on switches connect p processors to each other instead of p memory banks.
The switching network can be a crossbar switch when the number of processors is
small. A crossbar switch is analogous to a telephone switch board and allows p
inputs to be connected to m outputs without conflict. Since crossbar switches for
large numbers of processors are typically expensive they are replaced by multistage
networks. Signals travel across a small number of stages consisting of an array of
elementary switches, e.g., 2 × 2 or 4 × 4 switches.
There have been two ways of exploiting multistage networks. In circuit switching networks, the elementary switches are set up by sending electronic signals across
all of the switches. The circuit is set up once in much the same way that telephone
circuits are switched in a switchboard. Once the switch has been set up, communi-

CHAPTER 11. PARALLEL IMPLEMENTATIONS

374

cation between processors P1 , . . . , Pn is open to the memories
Mπ1 , Mπ2 , . . . , Mπn ,
in which π represents the desired permutation. This communication will remain
functional for as long as it is not reset. Setting up the switch can be costly, but once it
is done, communication can be quite fast. In packet switching networks, a packet of
data will be given an address token and the switching within the different stages will
be determined based on this address token. The elementary switches have to provide
for buffering capabilities, since messages may have to be queued at different stages.

11.3.2

Distributed Memory Architectures

The distributed memory model refers to the distributed memory message passing architectures as well as to distributed memory SIMD computers. A typical distributed
memory system consists of a large number of identical processors which have their
own memories and which are interconnected in a regular topology. Examples are depicted in Figures 11.4 and 11.5. In these diagrams, each processor unit can be viewed
actually as a complete processor with its own memory, CPU, I/O subsystem, control
unit, etc. These processors are linked to a number of “neighboring” processors which
in turn are linked to other neighboring processors, etc. In “Message Passing” models there is no global synchronization of the parallel tasks. Instead, computations
are data driven because a processor performs a given task only when the operands
it requires become available. The programmer must program all the data exchanges
explicitly between processors.
P1
P2

P8

P3

P7
P6

P4
P5

Figure 11.4: An eight-processor ring (left) and a 4 × 4 multiprocessor mesh (right).
In SIMD designs, a different approach is used. A host processor stores the program and each slave processor holds different data. The host then broadcasts instructions to processors which execute them simultaneously. One advantage of this
approach is that there is no need for large memories in each node to store large programs since the instructions are broadcast one by one to all processors.
Distributed memory computers can exploit locality of data in order to keep communication costs to a minimum. Thus, a two-dimensional processor grid such as

11.3. TYPES OF PARALLEL ARCHITECTURES

375

the one depicted in Figure 11.4 is perfectly suitable for solving discretized elliptic
Partial Differential Equations (e.g., by assigning each grid point to a corresponding
processor) because some iterative methods for solving the resulting linear systems
will require only interchange of data between adjacent grid points. A good general
purpose multiprocessor must have powerful mapping capabilities because it should
be capable of easily emulating many of the common topologies such as 2-D and 3-D
grids or linear arrays, FFT-butterflies, finite element meshes, etc.
Three-dimensional configurations have also been popular.
111

110
101

100
10

11
010

0

1

00

01

000

011

001

Figure 11.5: The n-cubes of dimensions n = 1, 2, 3.
Hypercubes are highly concurrent multiprocessors based on the binary n-cube topology which is well known for its rich interconnection capabilities. A parallel processor
based on the n-cube topology, called a hypercube hereafter, consists of 2n identical
processors, interconnected with n neighbors. A 3-cube can be represented as an ordinary cube in three dimensions where the vertices are the 8 = 23 nodes of the 3-cube;
see Figure 11.5. More generally, one can construct an n-cube as follows: First, the
2n nodes are labeled by the 2n binary numbers from 0 to 2n − 1. Then a link between
two nodes is drawn if and only if their binary numbers differ by one (and only one)
bit.
An n-cube graph can be constructed recursively from lower dimensional cubes.
More precisely, consider two identical (n − 1)-cubes whose vertices are labeled likewise from 0 to 2n−1 . By joining every vertex of the first (n − 1)-cube to the vertex
of the second having the same number, one obtains an n-cube. Indeed, it suffices to
renumber the nodes of the first cube as 0 ∧ ai and those of the second as 1 ∧ ai
where ai is a binary number representing the two similar nodes of the (n − 1)-cubes
and where ∧ denotes the concatenation of binary numbers.
Distributed memory computers come in two different designs, namely, SIMD
and MIMD. Many of the early projects have adopted the SIMD organization. For
example, the historical ILLIAC IV Project of the University of Illinois was a machine
based on a mesh topology where all processors execute the same instructions.
SIMD distributed processors are sometimes called array processors because of
the regular arrays that they constitute. In this category, systolic arrays can be classified as an example of distributed computing. Systolic arrays, which popular in the

CHAPTER 11. PARALLEL IMPLEMENTATIONS

376

1980s, are organized in connected cells, which are programmed (possibly microcoded) to perform only one of a few operations. All the cells are synchronized and
perform the same task. Systolic arrays are designed in VLSI technology and are
meant to be used for special purpose applications, primarily in signal processing.
In the last few years, parallel computing technologies have seen a healthy maturation. Currently, the architecture of choice is the distributed memory machine using
message passing. There is no doubt that this is due to the availability of excellent
communication software, such the Message Passing Interface (MPI), see [156]. In
addition, the topology
is often hidden from the user, so there is no need to code communication on
specific configurations such as hypercubes. Since this mode of computing has penetrated the applications areas, and industrial applications it is likely to remain for
some time.

11.4

Types of Operations

Now consider two prototype Krylov subspace techniques, namely, the preconditioned Conjugate Gradient method for the symmetric case and the preconditioned
GMRES algorithm for the nonsymmetric case. It should be emphasized that all
Krylov subspace techniques require the same basic operations.
Consider Algorithm 9.1. The first step when implementing this algorithm on a
high-performance computer is identifying the main operations that it requires. We
distinguish five types of operations, which are: (1) Preconditioner setup; (2) Matrix
vector multiplications; (3) Vector updates; (4) Dot products; and (5) Preconditioning
operations. In this list the potential bottlenecks are (1), setting up the preconditioner
and (5), solving linear systems with M , i.e., the preconditioning operation. Section
11.6 discusses the implementation of traditional preconditioners, and the last two
chapters are devoted to preconditioners that are specialized to parallel environments.
Next come the matrix-by-vector products which deserve particular attention. The
rest of the algorithm consists essentially of dot products and vector updates which
do not cause significant difficulties in parallel machines, although inner products can
lead to some loss of efficiency on certain types of computers with large numbers of
processors.
If we now consider the GMRES algorithm, the only new operation here with
respect to the Conjugate Gradient method is the orthogonalization of the vector Avi
against the previous v’s. The usual way to accomplish this is via the modified GramSchmidt process, which is basically a sequence of subprocesses of the form:
• Compute α = (y, v).
• Compute ŷ := y − αv.
This orthogonalizes a vector y against another vector v of norm one. Thus, the outer
loop of the modified Gram-Schmidt is sequential, but the inner loop, i.e., each subprocess, can be parallelized by dividing the inner product and SAXPY operations

11.4. TYPES OF OPERATIONS

377

among processors. Although this constitutes a perfectly acceptable approach for a
small number of processors, the elementary subtasks may be too small to be efficient
on a large number of processors. An alternative for this case is to use a standard
Gram-Schmidt process with reorthogonalization. This replaces the previous sequential orthogonalization process by a matrix operation of the form ŷ = y − V V T y, i.e.,
BLAS-1 kernels are replaced by BLAS-2 kernels.
Recall that the next level of BLAS, i.e., level 3 BLAS, exploits blocking in
dense matrix operations in order to obtain performance on machines with hierarchical memories. Unfortunately, level 3 BLAS kernels cannot be exploited here because
at every step, there is only one vector to orthogonalize against all previous ones. This
may be remedied by using block Krylov methods.
Vector operations, such as linear combinations of vectors and dot-products are
usually the simplest to implement on any computer. In shared memory computers,
compilers are capable of recognizing these operations and invoking the appropriate
machine instructions, possibly vector instructions. We consider now these operations
in turn.
Vector Updates Operations of the form
y(1:n) = y(1:n) + a * x(1:n),
where a is a scalar and y and x two vectors, are known as vector updates or SAXPY
operations. They are typically straightforward to implement in all three machine
models discussed earlier. For example, the above FORTRAN-90 code segment can
be used on most shared memory (’symmetric multiprocessing’) and the compiler will
translate it into the proper parallel version.
On distributed memory computers, some assumptions must be made about the
way in which the vectors are distributed. The main assumption is that the vectors x
and y are distributed in the same manner among the processors, meaning the indices
of the components of any vector that are mapped to a given processor are the same.
In this case, the vector-update operation will be translated into p independent vector
updates, requiring no communication. Specifically, if nloc is the number of variables
local to a given processor, this processor will simply execute a vector loop of the form
y(1:nloc) = y(1:nloc) + a * x(1:nloc)
and all processors will execute a similar operation simultaneously.
Dot products A number of operations use all the components of a given vector to
compute a single floating-point result which is then needed by all processors. These
are termed Reduction Operations and the dot product is the prototype example. A
distributed version of the dot-product is needed to compute the inner product of two
vectors x and y that are distributed the same way across the processors. In fact,
to be more specific, this distributed dot-product operation should compute the inner
product t = xT y of these two vectors and then make the result t available in each

CHAPTER 11. PARALLEL IMPLEMENTATIONS

378

processor. Typically, this result is needed to perform vector updates or other operations in each node. For a large number of processors, this sort of operation can be
demanding in terms of communication costs. On the other hand, parallel computer
designers have become aware of their importance and are starting to provide hardware and software support for performing global reduction operations efficiently.
Reduction operations that can be useful include global sums, global max/min calculations, etc. A commonly adopted convention provides a single subroutine for all
these operations, and passes the type of operation to be performed (add, max, min,
multiply,. . . ) as one of the arguments. With this in mind, a distributed dot-product
function can be programmed roughly as follows (using C syntax).
tloc = DDOT(nrow, x, incx, y, incy);
MPI\_Allreduce(\&t, \&tsum, 1, MPI\_DOUBLE, MPI\_SUM, comm);
The function DDOT performs the usual BLAS-1 dot product of x and y with strides
incx and incy, respectively. The MPI Allreduce operation, which is called with
“MPI SUM” as the operation-type parameter, sums all the variables “tloc” from each
processor and put the resulting global sum in the variable tsum in each processor.

11.5

Matrix-by-Vector Products

Matrix-by-vector multiplications (sometimes called “Matvecs” for short) are relatively easy to implement efficiently on high performance computers. For a description of storage formats for sparse matrices, see Chapter 3. We will first discuss
matrix-by-vector algorithms without consideration of sparsity. Then we will cover
sparse Matvec operations for a few different storage formats.
The computational kernels for performing sparse matrix operations such as matrixby-vector products are intimately associated with the data structures used. However, there are a few general approaches that are common to different algorithms for
matrix-by-vector products which can be described for dense matrices. Two popular ways of performing these operations are the inner product form and the SAXPY
form. In the inner product form for computing y = Ax, the component yi is obtained
as a dot-product of the i-th row of i and the vector x. The SAXPY form computes
y as a linear combination of the columns of A, specifically as the sum of xi A:,i for
i = 1, . . . , n. A third option consists of performing the product by diagonals. This
option bears no interest in the dense case, but it is at the basis of many important
matrix-by-vector algorithms in the sparse case as will be seen shortly.

11.5.1

The CSR and CSC Formats

Recall that the CSR data-structure seen in Chapter 3 consists of three arrays: a real
array A(1:nnz) to store the nonzero elements of the matrix row-wise, an integer array
JA(1:nnz) to store the column positions of the elements in the real array A, and,
finally, a pointer array IA(1:n+1), the i-th entry of which points to the beginning of
the i-th row in the arrays A and JA. To perform the matrix-by-vector product y = Ax

11.5. MATRIX-BY-VECTOR PRODUCTS

379

in parallel using this format, note that each component of the resulting vector y can
be computed independently as the dot product of the i-th row of the matrix with the
vector x.
A LGORITHM 11.1 CSR Format – Dot Product Form

1.
2.
3.
4.
5.

Do i = 1, n
k1 = ia(i)
k2 = ia(i+1)-1
y(i) = dotproduct(a(k1:k2),x(ja(k1:k2)))
EndDo

Line 4 computes the dot product of the vector with components a(k1), a(k1+1), · · ·,
a(k2) with the vector with components x(ja(k1)), x(ja(k1+1)), · · ·, x(ja(k2)).
The fact that the outer loop can be performed in parallel can be exploited on
any parallel platform. On some shared-memory machines, the synchronization of
this outer loop is inexpensive and the performance of the above program can be
excellent. On distributed memory machines, the outer loop can be split in a number
of steps to be executed on each processor. Thus, each processor will handle a few
rows that are assigned to it. It is common to assign a certain number of rows (often
contiguous) to each processor and to also assign the component of each of the vectors
similarly. The part of the matrix that is needed is loaded in each processor initially.
When performing a matrix-by-vector product, interprocessor communication will be
necessary to get the needed components of the vector x that do not reside in a given
processor. This important case will return in Section 11.5.5.
+

Gather

+

DotProduct

+

*

y(i)

x(*) a(i,*)
+

x(1:n)

Figure 11.6: Illustration of the row-oriented matrix-by-vector multiplication.
The indirect addressing involved in the second vector in the dot product is called
a gather operation. The vector x(ja(k1:k2)) is first “gathered” from memory into
a vector of contiguous elements. The dot product is then carried out as a standard
dot-product operation between two dense vectors. This is illustrated in Figure 11.6.
Now assume that the matrix is stored by columns (CSC format). The matrix-byvector product can be performed by the following algorithm.
A LGORITHM 11.2 CSC Format – SAXPY Form

CHAPTER 11. PARALLEL IMPLEMENTATIONS

380

1.
2.
3.
4.
5.
6.

y(1:n) = 0.0
Do i = 1, n
k1 = ia(i)
k2 = ia(i + 1)-1
y(ja(k1:k2)) = y(ja(k1:k2)) + x(j) * a(k1:k2)
EndDo

The above code initializes y to zero and then adds the vectors x(j) × a(1 : n, j)
for j = 1, . . . , n to it. It can also be used to compute the product of the transpose
of a matrix by a vector, when the matrix is stored (row-wise) in the CSR format.
Normally, the vector y(ja(k1:k2)) is gathered and the SAXPY operation is performed
in vector mode. Then the resulting vector is “scattered” back into the positions ja(*),
by what is called a Scatter operation. This is illustrated in Figure 11.7.
A major difficulty with the above FORTRAN program is that it is intrinsically
sequential. First, the outer loop is not parallelizable as it is, but this may be remedied
as will be seen shortly. Second, the inner loop involves writing back results of the
right-hand side into memory positions that are determined by the indirect address
function ja. To be correct, y(ja(1)) must be copied first, followed by y(ja(2)), etc.
However, if it is known that the mapping ja(i) is one-to-one, then the order of the
assignments no longer matters. Since compilers are not capable of deciding whether
this is the case, a compiler directive from the user is necessary for the Scatter to be
invoked.
Going back to the outer loop, p subsums can be computed (independently) into
p separate temporary vectors. Once all the p separate subsums are completed, these
these p temporary vectors can be added to obtain the final result. Note that the final
sum incurs some additional work but it is highly vectorizable and parallelizable.

+

Gather

Scatter

+

+
+

+ x(j)*

+

y(*)

a(*,j)

=

+

y(*)

+

y(1:n)

+

y(1:n)

Figure 11.7: Illustration of the column-oriented matrix-by-vector multiplication.

11.5.2

Matvecs in the Diagonal Format

The diagonal storage format was one of the first data structures used in the context
of high performance computing to take advantage of special sparse structures. Often,
sparse matrices consist of a small number of diagonals in which case the matrix-by-

11.5. MATRIX-BY-VECTOR PRODUCTS

381

vector product can be performed by diagonals. There are again different variants of
Matvec algorithms for the diagonal format, related to different orderings of the loops
in the basic FORTRAN program. Recall that the matrix is stored in a rectangular
array diag(1:n,1:ndiag) and the offsets of these diagonals from the main diagonal
may be stored in a small integer array offset(1:ndiag). Consider a “dot-product”
variant first.
A LGORITHM 11.3 DIA Format – Dot Product Form

1.
2.
3.
4.
5.
6.
7.

Do i = 1, n
tmp = 0.0d0
Do j = 1, ndiag
tmp = tmp + diag(i,j)*x(i+offset(j))
EndDo
y(i) = tmp
EndDo

In a second variant, the vector y is initialized to zero, and then x is multiplied by
each of the diagonals and the separate results are added to y. The innermost loop in
this computation is sometimes called a Triad operation.
A LGORITHM 11.4 Matvec in Triad Form

1.
2.
3.
4.
5.
6.
7.

y = 0.0d0
Do j = 1, ndiag
joff = offset(j)
i1 = max(1, 1-offset(j))
i2 = min(n, n-offset(j))
y(i1:i2) = y(i1:i2) + diag(i1:i2,j)*x(i1+joff:i2+joff)
EndDo

Good speeds can be reached on vector machines for large enough matrices. A
drawback with diagonal schemes is that it are not general. For general sparse matrices, we can either generalize the diagonal storage scheme or reorder the matrix in
order to obtain a diagonal structure. The simplest generalization is the Ellpack-Itpack
Format.

11.5.3

The Ellpack-Itpack Format

The Ellpack-Itpack (or Ellpack) format is of interest only for matrices whose maximum number of nonzeros per row, jmax, is small. The nonzero entries are stored in
a real array ae(1:n,1:jmax). Along with this is integer array jae(1:n,1:jmax) which
stores the column indices of each corresponding entry in ae. Similar to the diagonal
scheme, there are also two basic ways of implementing a matrix-by-vector product
when using the Ellpack format. We begin with an analogue of Algorithm 11.3.

382

CHAPTER 11. PARALLEL IMPLEMENTATIONS

A LGORITHM 11.5 Ellpack Format – Dot-Product Form

1.
2.
3.
4.
5.
6.
7.

Do i = 1, n
yi = 0
Do j = 1, ncol
yi = yi + ae(i,j) * x(jae(i,j))
EndDo
y(i) = yi
EndDo

If the number of nonzero elements per row varies substantially, many zero elements must be stored unnecessarily. Then the scheme becomes inefficient. As an
extreme example, if all rows are very sparse except for one of them which is full,
then the arrays ae, jae must be full n × n arrays, containing mostly zeros. This is
remedied by a variant of the format which is called the jagged diagonal format.

11.5.4

The Jagged Diagonal Format

The Jagged Diagonal (JAD) format can be viewed as a generalization of the EllpackItpack format which removes the assumption on the fixed length rows. To build the
jagged diagonal structure, start from the CSR data structure and sort the rows of the
matrix by decreasing number of nonzero elements. To build the first “j-diagonal”
extract the first element from each row of the CSR data structure. The second jagged
diagonal consists of the second elements of each row in the CSR data structure.
The third, fourth, . . ., jagged diagonals can then be extracted in the same fashion.
The lengths of the successive j-diagonals decreases. The number of j-diagonals that
can be extracted is equal to the number of nonzero elements of the first row of the
permuted matrix, i.e., to the largest number of nonzero elements per row. To store
this data structure, three arrays are needed: a real array DJ to store the values of
the jagged diagonals, the associated array JDIAG which stores the column positions
of these values, and a pointer array IDIAG which points to the beginning of each
j-diagonal in the DJ, JDIAG arrays.
Example 11.1. Consider the following matrix and its sorted version P A:




1. 0. 2. 0. 0.
3. 4. 0. 5. 0.
 3. 4. 0. 5. 0. 
 0. 6. 7. 0. 8. 







A =  0. 6. 7. 0. 8.  → P A = 
1.
0.
2.
0.
0.


 0. 0. 9. 10. 0. 
 0. 0. 9. 10. 0. 
0. 0. 0. 11. 12.
0. 0. 0. 11. 12.

The rows of P A have been obtained from those of A by sorting them by number
of nonzero elements, from the largest to the smallest number. Then the JAD data
structure for A is as follows:

11.5. MATRIX-BY-VECTOR PRODUCTS

383

DJ

3.

6.

1.

9.

11.

4.

7.

2.

10.

12.

5.

8.

JDIAG

1

2

1

3

4

2

3

3

4

5

4

5

IDIAG

1

6

11

13

Thus, there are two j-diagonals of full length (five) and one of length two.
A matrix-by-vector product with this storage scheme can be performed by the
following code segment.

1.
2.
3.
4.
5.
6.

Do j=1, ndiag
k1 = idiag(j)
k2 = idiag(j+1) – 1
len = idiag(j+1) – k1
y(1:len) = y(1:len) + dj(k1:k2)*x(jdiag(k1:k2))
EndDo

Since the rows of the matrix A have been permuted, the above code will compute
P Ax, a permutation of the vector Ax, rather than the desired Ax. It is possible
to permute the result back to the original ordering after the execution of the above
program. This operation can also be performed until the final solution has been
computed, so that only two permutations on the solution vector are needed, one at the
beginning and one at the end. For preconditioning operations, it may be necessary to
perform a permutation before or within each call to the preconditioning subroutines.
There are many possible variants of the jagged diagonal format. One variant which
does not require permuting the rows is described in Exercise 8.

11.5.5

The Case of Distributed Sparse Matrices

Given a sparse linear system to be solved on a distributed memory environment, it is
natural to map pairs of equations-unknowns to the same processor in a certain predetermined way. This mapping can be determined automatically by a graph partitioner
or it can be assigned ad hoc from knowledge of the problem. Without any loss of
generality, the matrix under consideration can be viewed as originating from the discretization of a Partial Differential Equation on a certain domain. This is illustrated
in Figure 11.8. Assume that each subgraph (or subdomain, in the PDE literature)
is assigned to a different processor, although this restriction can be relaxed, i.e., a
processor can hold several subgraphs to increase parallelism.
A local data structure must be set up in each processor (or subdomain, or subgraph) which will allow the basic operations such as (global) matrix-by-vector products and preconditioning operations to be performed efficiently. The only assumption
to make regarding the mapping is that if row number i is mapped into processor p,
then so is the unknown i, i.e., the matrix is distributed row-wise across the processors
according to the distribution of the variables. The graph is assumed to be undirected,
i.e., the matrix has a symmetric pattern.

CHAPTER 11. PARALLEL IMPLEMENTATIONS

384

Internal
points
External Interface
Internal
interface
points

points

Figure 11.8: Decomposition of physical domain or adjacency graph and the local
data structure.
It is important to “preprocess the data” in order to facilitate the implementation
of the communication tasks and to gain efficiency during the iterative process. The
preprocessing requires setting up the following: information in each processor.
1. List of processors with which communication will take place. These are called
“neighboring processors” although they may not be physically nearest neighbors.
2. List of local nodes that are coupled with external nodes. These are the local
interface nodes.
3. Local representation of the distributed matrix in each processor.
To perform a matrix-by-vector product with the global matrix A, the matrix consisting of rows that are local to a given processor must be multiplied by some global
vector v. Some components of this vector will be local, and some components must
be brought from external processors. These external variables correspond to interface points belonging to adjacent subdomains. When performing a matrix-by-vector
product, neighboring processors must exchange values of their adjacent interface
nodes.
Let Aloc be the local part of the matrix, i.e., the (rectangular) matrix consisting of
all the rows that are mapped to myproc. Call Aloc the “diagonal block” of A located
in Aloc , i.e., the submatrix of Aloc whose nonzero elements aij are such that j is
a local variable. Similarly, call Bext the “offdiagonal” block, i.e., the submatrix of

11.5. MATRIX-BY-VECTOR PRODUCTS

385

Aloc whose nonzero elements aij are such that j is not a local variable. To perform
a matrix-by-vector product, start multiplying the diagonal block Aloc by the local
variables. Then, multiply the external variables by the sparse matrix Bext . Notice
that since the external interface points are not coupled with local internal points, only
the rows nint + 1 to nnloc in the matrix Bext will have nonzero elements.
Thus, the matrix-by-vector product can be separated into two such operations,
one involving only the local variables and the other involving external variables. It is
necessary to construct these two matrices and define a local numbering of the local
variables in order to perform the two matrix-by-vector products efficiently each time.
To perform a global matrix-by-vector product, with the distributed data structure
described above, each processor must perform the following operations. First, multiply the local variables by the matrix Aloc . Second, obtain the external variables from
the neighboring processors in a certain order. Third, multiply these by the matrix
Bext and add the resulting vector to the one obtained from the first multiplication by
Aloc . Note that the first and second steps can be done in parallel.

Internal
points
A

Local
interface
points

+

loc

Bext

Figure 11.9: The local matrices and data structure associated with each subdomain.
With this decomposition, the global matrix-by-vector product can be implemented as indicated in Algorithm 11.6 below. In what follows, xloc is a vector of
variables that are local to a given processor. The components corresponding to the
local interface points (ordered to be the last components in xloc for convenience) are
called xbnd . The external interface points, listed in a certain order, constitute a vector
which is called xext . The matrix Aloc is a sparse nloc × nloc matrix representing the
restriction of A to the local variables xloc . The matrix Bext operates on the external
variables xext to give the correction which must be added to the vector Aloc xloc in
order to obtain the desired result (Ax)loc .
A LGORITHM 11.6 Distributed Sparse Matrix Product Kernel

1.
2.
3.
4.
5.

Exchange interface data, i.e.,
Scatter xbnd to neighbors and
Gather xext from neighbors
Do Local Matvec: y = Aloc xloc
Do External Matvec: y = y + Bext xext

386

CHAPTER 11. PARALLEL IMPLEMENTATIONS

An important observation is that the matrix-by-vector products in lines 4 and 5 can
use any convenient data structure that will improve efficiency by exploiting knowledge on the local architecture. An example of the implementation of this operation
is illustrated next:

call bdxchg(nloc,x,y,nproc,proc,ix,ipr,type,xlen,iout)
y(1:nloc) = 0.0
call amux1 (nloc,x,y,aloc,jaloc,ialoc)
nrow = nloc – nbnd + 1
call amux1(nrow,x,y(nbnd),aloc,jaloc,ialoc(nloc+1))
The only routine requiring communication is bdxchg whose purpose is to exchange interface values between nearest neighbor processors. The first call to amux1
performs the operation y := y + Aloc xloc , where y has been initialized to zero prior
to the call. The second call to amux1 performs y := y + Bext xext . Notice that the
data for the matrix Bext is simply appended to that of Aloc , a standard technique
used for storing a succession of sparse matrices. The Bext matrix acts only on the
subvector of x which starts at location nbnd of x. The size of the Bext matrix is
nrow = nloc − nbnd + 1.

11.6

Standard Preconditioning Operations

Each preconditioned step requires the solution of a linear system of equations o the
form M z = y. This section only considers those traditional preconditioners, such
as ILU or SOR or SSOR, in which the solution with M is the result of solving triangular systems. Since these are commonly used, it is important to explore ways to
implement them efficiently in a parallel environment. It is also important to stress
that the techniques to be described in this section are mostly useful on shared memory computers. Distributed memory computers utilize different strategies. We only
consider lower triangular systems of the form
Lx = b.

(11.1)

Without loss of generality, it is assumed that L is unit lower triangular.

11.6.1

Parallelism in Forward Sweeps

Typically in solving a lower triangular system, the solution is overwritten onto the
right-hand side on return. In other words, there is one array x for both the solution
and the right-hand side. Therefore, the forward sweep for solving a lower triangular
system with coefficients al(i, j) and right-hand-side x is as follows.
A LGORITHM 11.7 Sparse Forward Elimination

1.
2.

Do i=2, n
For (all j such that al(i,j) is nonzero) Do:

11.6. STANDARD PRECONDITIONING OPERATIONS
3.
4.
5.

387

x(i) := x(i) – al(i,j) * x(j)
EndDo
EndDo

Assume that the matrix is stored row wise in the general Compressed Sparse Row
(CSR) format, except that the diagonal elements (ones) are not stored. Then the
above algorithm translates into the following code segment:

1.
2.
3.
4.
5.

Do i=2, n
Do j=ial(i), ial(i+1) – 1
x(i)=x(i) – al(j) * x(jal(j))
EndDo
EndDo

The outer loop corresponding to the variable i is sequential. The j loop is a sparse
dot product of the ith row of L and the (dense) vector x. This dot product may be split
among the processors and the partial results may be added at the end. However, the
length of the vector involved in the dot product is typically short. So, this approach
is quite inefficient in general. We examine next a few alternative approaches. The
regularly structured and the irregularly structured cases are treated separately.

11.6.2

Level Scheduling: the Case of 5-Point Matrices

First, consider an example which consists of a 5-point matrix associated with a 4 × 3
mesh as represented in Figure 11.10. The lower triangular matrix associated with
this mesh is represented in the left side of Figure 11.10. The stencil represented in
the right side of Figure 11.10 establishes the data dependence between the unknowns
in the lower triangular system solution when considered from the point of view of a
grid of unknowns. It tells us that in order to compute the unknown in position (i, j),
only the two unknowns in positions (i−1, j) and (i, j −1) are needed . The unknown
x11 does not depend on any other variable and can be computed first. Then the value
of x11 can be used to get x1,2 and x2,1 simultaneously. Then these two values will
in turn enable x3,1 , x2,2 and x1,3 to be obtained simultaneously, and so on. Thus, the
computation can proceed in wavefronts.
The steps for this wavefront algorithm are shown with dashed lines in Figure
11.10. Observe that the maximum degree of parallelism (or vector length, in the case
of vector processing) that can be reached is the minimum of nx , ny , the number of
mesh points in the x and y directions, respectively, for 2-D problems.
For 3-D problems, the parallelism is of the order of the maximum size of the sets
of domain points xi,j,k , where i + j + k = lev, a constant level lev. It is important to
note that there is little parallelism or vectorization at the beginning and at the end of
the sweep. The degree of parallelism is equal to one initially, and then increases by
one for each wave reaching its maximum, and then decreasing back down to one at
the end of the sweep. For example, for a 4 × 3 grid, the levels (sets of equations that
can be solved in parallel) are {1}, {2, 5}, {3, 6, 9}, {4, 7, 10}, {8, 11}, and finally
{12}. The first and last few steps may take a heavy toll on achievable speed-ups.

CHAPTER 11. PARALLEL IMPLEMENTATIONS

388
9

10

11

12

6
5

7

6

(i, j − 1)

(i, j)

✲

✻

8

5
1

2

3

(i − 1, j)

4

Stencil
1

3

2

4

Figure 11.10: Level scheduling for a 4 × 3 grid problem.
The idea of proceeding by levels or wavefronts is a natural one for finite difference matrices on rectangles. Discussed next is the more general case of irregular
matrices, a textbook example of scheduling, or topological sorting, it is well known
in different forms to computer scientists.

11.6.3

Level Scheduling for Irregular Graphs

The simple scheme described above can be generalized for irregular grids. The objective of the technique, called level scheduling, is to group the unknowns in subsets
so that they can be determined simultaneously. To explain the idea, consider again
Algorithm 11.7 for solving a unit lower triangular system. The i-th unknown can be
determined once all the other ones that participate in equation i become available.
In the i-th step, all unknowns j that al(i, j) 6= 0 must be known. To use graph
terminology, these unknowns are adjacent to unknown number i. Since L is lower
triangular, the adjacency graph is a directed acyclic graph. The edge j → i in the
graph simply indicates that xj must be known before xi can be determined. It is
possible and quite easy to find a labeling of the nodes that satisfy the property that
if label(j) < label(i), then task j must be executed before task i. This is called a
topological sorting of the unknowns.
The first step computes x1 and any other unknowns for which there are no predecessors in the graph, i.e., all those unknowns xi for which the offdiagonal elements
of row i are zero. These unknowns will constitute the elements of the first level. The
next step computes in parallel all those unknowns that will have the nodes of the first
level as their (only) predecessors in the graph. The following steps can be defined
similarly: The unknowns that can be determined at step l are all those that have as
predecessors equations that have been determined in steps 1, 2, . . . , l − 1. This leads
naturally to the definition of a depth for each unknown. The depth of a vertex is defined by performing the following loop for = 1, 2, . . . , n, after initializing depth(j)
to zero for all j.
depth(i) = 1 + max{depth(j), for all j such that al(i, j) 6= 0}.
j

11.6. STANDARD PRECONDITIONING OPERATIONS

389

By definition, a level of the graph is the set of nodes with the same depth. A data
structure for the levels can be defined: A permutation q(1 : n) defines the new
ordering and level(i), i = 1, · · · , nlev + 1 points to the beginning of the i-th level in
that array.
Wavefront ordering

Natural ordering

Figure 11.11: Lower triangular matrix associated with mesh of Figure 11.10.
Once these level sets are found, there are two different ways to proceed. The
permutation vector q can be used to permute the matrix according to the new order.
In the 4 × 3 example mentioned in the previous subsection, this means renumbering
the variables {1}, {2, 5}, {3, 6, 9}, . . ., consecutively, i.e., as {1, 2, 3, . . .}. The resulting matrix after the permutation is shown in the right side of Figure 11.11. An
alternative is simply to keep the permutation array and use it to identify unknowns
that correspond to a given level in the solution. Then the algorithm for solving the
triangular systems can be written as follows, assuming that the matrix is stored in the
usual row sparse matrix format.
A LGORITHM 11.8 Forward Elimination with Level Scheduling

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Do lev=1, nlev
j1 = level(lev)
j2 = level(lev+1) – 1
Do k = j1, j2
i = q(k)
Do j= ial(i), ial(i+1) – 1
x(i) = x(i) – al(j) * x(jal(j))
EndDo
EndDo
EndDo

An important observation here is that the outer loop, which corresponds to a
level, performs an operation of the form
x := x − Bx

390

CHAPTER 11. PARALLEL IMPLEMENTATIONS

where B is a submatrix consisting only of the rows of level lev, and excluding the
diagonal elements. This operation can in turn be optimized by using a proper data
structure for these submatrices.
For example, the JAD data structure can be used. The resulting performance can
be quite good. On the other hand, implementation can be quite involved since two
embedded data structures are required.
Example 11.2. Consider a finite element matrix obtained from the example shown
in Figure 3.1. After an additional level of refinement, done in the same way as was
described in Chapter 3, the resulting matrix, shown in the left part of Figure 11.12,
is of size n = 145. In this case, 8 levels are obtained. If the matrix is reordered by
levels, the matrix shown in the right side of the figure results. The last level consists
of only one element.
Natural ordering

Level-Scheduling ordering

Figure 11.12: Lower-triangular matrix associated with a finite element matrix and its
level-ordered version.

P ROBLEMS
P-11.1 Give a short answer to each of the following questions:
a. What is the main disadvantage of shared memory computers based on a bus architecture?
b. What is the main factor in yielding the speed-up in pipelined processors?
c. Related to the previous question: What is the main limitation of pipelined processors
in regards to their potential for providing high speed-ups?
P-11.2 Show that the number of edges in a binary n-cube is n2n−1 .
P-11.3 Show that a binary 4-cube is identical with a torus which is a 4 × 4 mesh with
wrap-around connections. Are there hypercubes of any other dimensions that are equivalent
topologically to toruses?

11.6. STANDARD PRECONDITIONING OPERATIONS

391

P-11.4 A Gray code of length k = 2n is a sequence a0 , . . . , ak−1 of n-bit binary numbers
such that (a) any two successive numbers in the sequence differ by one and only one bit; (b)
all n-bit binary numbers are represented in the sequence; and (c) a0 and ak−1 differ by one
bit.
a. Find a Gray code sequence of length k = 8 and show the (closed) path defined by
the sequence of nodes of a 3-cube, whose labels are the elements of the Gray code
sequence. What type of paths does a Gray code define in a hypercube?
b. To build a “binary reflected” Gray code, start with the trivial Gray code sequence consisting of the two one-bit numbers 0 and 1. To build a two-bit Gray code, take the same
sequence and insert a zero in front of each number, then take the sequence in reverse
order and insert a one in front of each number. This gives G2 = {00, 01, 11, 10}.
The process is repeated until an n-bit sequence is generated. Show the binary reflected
Gray code sequences of length 2, 4, 8, and 16. Prove (by induction) that this process
does indeed produce a valid Gray code sequence.
c. Let an n-bit Gray code be given and consider the sub-sequence of all elements whose
first bit is constant (e.g., zero). Is this an n − 1 bit Gray code sequence? Generalize
this to any of the n-bit positions. Generalize further to any set of k < n bit positions.
d. Use the previous question to find a strategy to map a 2n1 × 2n2 mesh into an (n1 +n2 )cube.
P-11.5 Consider a ring of k processors which are characterized by the following communication performance characteristics. Each processor can communicate with its two neighbors
simultaneously, i.e., it can send or receive a message while sending or receiving another message. The time for a message of length m to be transmitted between two nearest neighbors is
of the form
β + mτ.
a. A message of length m is “broadcast” to all processors by sending it from P1 to P2 and
then from P2 to P3 , etc., until it reaches all destinations, i.e., until it reaches Pk . How
much time does it take for the message to complete this process?
b. Now split the message into packets of equal size and pipeline the data transfer. Typically, each processor will receive packet number i from the previous processor, while
sending packet i − 1 it has already received to the next processor. The packets will
travel in chain from P1 to P2 , . . ., to Pk . In other words, each processor executes a
program that is described roughly as follows:
Do i=1, Num\_packets
Receive Packet number i from Previous Processor
Send Packet number i to Next Processor
EndDo
There are a few additional conditionals. Assume that the number of packets is equal to
k − 1. How much time does it take for all packets to reach all k processors? How does
this compare with the simple method in (a)?
P-11.6 (a) Write a short FORTRAN routine (or C function) which sets up the level number
of each unknown of an upper triangular matrix. The input matrix is in CSR format and the
output should be an array of length n containing the level number of each node. (b) What
data structure should be used to represent levels? Without writing the code, show how to
determine this data structure from the output of your routine. (c) Assuming the data structure

392

CHAPTER 11. PARALLEL IMPLEMENTATIONS

of the levels has been determined, write a short FORTRAN routine (or C function) to solve
an upper triangular system using the data structure resulting in the previous question. Show
clearly which loop should be executed in parallel.
P-11.7 In the jagged diagonal format described in Section 11.5.4, it is necessary to preprocess the matrix by sorting its rows by decreasing number of rows. What type of sorting
should be used for this purpose?
P-11.8 In the jagged diagonal format described in Section 11.5.4, the matrix had to be
preprocessed by sorting it by rows of decreasing number of elements.
a. What is the main reason it is necessary to reorder the rows?
b. Assume that the same process of extracting one element per row is used. At some point
the extraction process will come to a stop and the remainder of the matrix can be put
into a CSR data structure. Write down a good data structure to store the two pieces of
data and a corresponding algorithm for matrix-by-vector products.
c. This scheme is efficient in many situations but can lead to problems if the first row is
very short. Suggest how to remedy the situation by padding with zero elements, as is
done for the Ellpack format.
P-11.9 Many matrices that arise in PDE applications have a structure that consists of a few
diagonals and a small number of nonzero elements scattered irregularly in the matrix. In
such cases, it is advantageous to extract the diagonal part and put the rest in a general sparse
(e.g., CSR) format. Write a pseudo-code to extract the main diagonals and the sparse part.
As input parameter, the number of diagonals desired must be specified.
N OTES AND R EFERENCES . General recommended reading on parallel computing are the books
by Kumar et al. [194]. Foster [131], and Wilkinson and Allen [316]. Trends in high-performance
architectures seem to come and go rapidly. In the 80s, it seemed that the paradigm of shared memory
computers with massive parallelism and coarse grain parallelism was sure to win in the long run. Then,
a decade ago massive parallelism of the SIMD type dominated the scene for while, with hypercube
topologies at the forefront. Thereafter, computer vendors started mixing message-passing paradigms
with “global address space”. Currently, it appears that distributed heteregenous computing will be
dominating the high-performance computing scene for some time to come. Another recent development
is the advent of network computing or grid-computing.
Until the advent of supercomputing in the mid 1970s, storage schemes for sparse matrices were
chosen mostly for convenience as performance was not an issue, in general. The first paper showing the
advantage of diagonal storage schemes in sparse matrix computations is probably [184]. The discovery
by supercomputer manufacturers of the specificity of sparse matrix computations was the painful realization that without hardware support, vector computers could be inefficient. Indeed, the early vector
machines (CRAY) did not have hardware instructions for gather and scatter operations but this was
soon remedied in the second-generation machines. For a detailed account of the beneficial impact of
hardware for “scatter” and “gather” on vector machines, see [201].
Level scheduling is a textbook example of topological sorting in graph theory and was discussed
from this viewpoint in, e.g., [8, 258, 318]. For the special case of finite difference matrices on rectangular domains, the idea was suggested by several authors independently, [288, 289, 155, 252, 10]. In
fact, the level scheduling approach described in this chapter is a “greedy” approach and is unlikely to
be optimal. It may be preferable to use a backward scheduling [7] which define the levels from bottom
up in the graph. Thus, the last level consists of the leaves of the graph, the previous level consists of
their predecessors, etc. Instead of static scheduling, it is also possible to perform a dynamic scheduling
whereby the order of the computation is determined at run-time. The advantage over pre-scheduled
triangular solutions is that it allows processors to always execute a task as soon as its predecessors have
been completed, which reduces idle time. Some of the earlier references on implementations and tests
wih level-scheduling are [30, 257, 165, 30, 37, 7, 8, 294, 296].

Chapter 12

PARALLEL PRECONDITIONERS

This chapter covers a few alternative methods for preconditioning a linear system. These
methods are suitable when the desired goal is to maximize parallelism. The simplest approach is
the diagonal (or Jacobi) preconditioning. Often, this preconditioner is not very useful, since the
number of iterations of the resulting iteration tends to be much larger than the more standard
variants, such as ILU or SSOR. When developing parallel preconditioners, one should beware that
the benefits of increased parallelism are not outweighed by the increased amount of computations.
The main question to ask is whether or not it is possible to find preconditioning techniques that
have a high degree of parallelism, as well as good intrinsic qualities.

12.1

Introduction

As seen in the previous chapter, a limited amount of parallelism can be extracted
from the standard preconditioners such as ILU and SSOR. Fortunately, a number
of alternative techniques can be developed that are specifically targeted at parallel
environments. These are preconditioning techniques that would normally not be used
on a standard machine, but only for parallel computers. There are at least three such
types of techniques discussed in this chapter. The simplest approach is to use a Jacobi
or, even better, a block Jacobi approach. In the simplest case, a Jacobi preconditioner
may consist of the diagonal or a block-diagonal of A. To enhance performance, these
preconditioners can themselves be accelerated by polynomial iterations, i.e., a second
level of preconditioning called polynomial preconditioning.
A different strategy altogether is to enhance parallelism by using graph theory
algorithms, such as graph-coloring techniques. These consist of coloring nodes such
that two adjacent nodes have different colors. The gist of this approach is that all
unknowns associated with the same color can be determined simultaneously in the
forward and backward sweeps of the ILU preconditioning operation.
Finally, a third strategy uses generalizations of “partitioning” techniques, which
can be put in the general framework of “domain decomposition” approaches. These
will be covered in detail in the next chapter.
Algorithms are emphasized rather than implementations. There are essentially
two types of algorithms, namely, those which can be termed coarse-grain and those
which can be termed fine-grain. In coarse-grain algorithms, the parallel tasks are
relatively big and may, for example, involve the solution of small linear systems.
393

CHAPTER 12. PARALLEL PRECONDITIONERS

394

In fine-grain parallelism, the subtasks can be elementary floating-point operations
or consist of a few such operations. As always, the dividing line between the two
classes of algorithms is somewhat blurred.

12.2

Block-Jacobi Preconditioners

Overlapping block-Jacobi preconditioning consists of a general block-Jacobi approach as described in Chapter 4, in which the sets Si overlap. Thus, we define
the index sets
Si = {j | li ≤ j ≤ ri }
with
l1 = 1
rp = n
ri > li+1 ,

1 ≤ i ≤ p−1

where p is the number of blocks. Now use the block-Jacobi method with this particular partitioning, or employ the general framework of additive projection processes
of Chapter 5, and use an additive projection method onto the sequence of subspaces
Ki = span{Vi },

Vi = [eli , eli +1 , . . . , eri ].

Each of the blocks will give rise to a correction of the form
(k+1)

ξi

(k)

= ξi

T
(k)
+ A−1
i Vi (b − Ax ).

(12.1)

One problem with the above formula is related to the overlapping portions of the x
variables. The overlapping sections will receive two different corrections in general.
According to the definition of “additive projection processes” seen in Chapter 5, the
next iterate can be defined as
xk+1 = xk +

p
X

T
Vi A−1
i Vi rk

i=1

where rk = b − Axk is the residual vector at the previous iteration. Thus, the
corrections for the overlapping regions simply are added together. It is also possible
to weigh these contributions before adding them up. This is equivalent to redefining
(12.1) into
(k+1)
(k)
T
ξi
= ξi + Di A−1
i Vi (b − Axk )
in which Di is a nonnegative diagonal matrix of weights. It is typical to weigh a
nonoverlapping contribution by one and an overlapping contribution by 1/k where k
is the number of times the unknown is represented in the partitioning.

12.3. POLYNOMIAL PRECONDITIONERS

395

A1
A2
A3
A4
A5
A6
A7

Figure 12.1: The block-Jacobi matrix with overlapping blocks.
The block-Jacobi iteration is often over- or under-relaxed, using a relaxation
parameter ω. The iteration can be defined in the form
xk+1 = xk +

p
X

T
ωi Vi A−1
i Vi rk .

i=1

Recall that the residual at step k + 1 is then related to that at step k by
#
"
p
X

−1
ViT rk .
ωi AVi ViT AVi
rk+1 = I −
i=1

The solution of a sparse linear system is required at each projection step. These systems can be solved by direct methods if the subblocks are small enough. Otherwise,
iterative methods may be used. The outer loop accelerator should then be a flexible
variant, such as FGMRES, which can accommodate variations in the preconditioners.

12.3

Polynomial Preconditioners

In polynomial preconditioning the matrix M is defined by
M −1 = s(A)
where s is a polynomial, typically of low degree. Thus, the original system is replaced by the preconditioned system
s(A)Ax = s(A)b

(12.2)

CHAPTER 12. PARALLEL PRECONDITIONERS

396

which is then solved by a conjugate gradient-type technique. Note that s(A) and
A commute and, as a result, the preconditioned matrix is the same for right or left
preconditioning. In addition, the matrix s(A) or As(A) does not need to be formed
explicitly since As(A)v can be computed for any vector v from a sequence of matrixby-vector products.
Initially, this approach was motivated by the good performance of matrix-vector
operations on vector computers for long vectors, e.g., the Cyber 205. However, the
idea itself is an old one and has been suggested by Stiefel [276] for eigenvalue calculations in the mid 1950s. Next, some of the popular choices for the polynomial s
are described.

12.3.1

Neumann Polynomials

The simplest polynomial s which has been used is the polynomial of the Neumann
series expansion
I + N + N2 + · · · + Ns

in which

N = I − ωA

and ω is a scaling parameter. The above series comes from expanding the inverse of
ωA using the splitting
ωA = I − (I − ωA).
This approach can also be generalized by using a splitting of the form
ωA = D − (D − ωA)
where D can be the diagonal of A or, more appropriately, a block diagonal of A.
Then,

−1
(ωA)−1 = D(I − (I − ωD −1 A))

−1 −1
D .
= I − (I − ωD −1 A)
Thus, setting

N = I − ωD −1 A

results in the approximate s-term expansion

(ωA)−1 ≈ M −1 ≡ [I + N + · · · + N s ] D −1 .

Since D −1 A = ω −1 [I − N ] , note that

(12.3)

M −1 A = [I + N + · · · + N s ] D −1 A
1
[I + N + · · · + N s ] (I − N )
=
ω
1
=
(I − N s+1 ).
ω
The matrix operation with the preconditioned matrix can be difficult numerically for
large s. If the original matrix is Symmetric Positive Definite, then M −1 A is not
symmetric, but it is self-adjoint with respect to the D-inner product; see Exercise 1.

12.3. POLYNOMIAL PRECONDITIONERS

12.3.2

397

Chebyshev Polynomials

The polynomial s can be selected to be optimal in some sense, and this leads to the
use of Chebyshev polynomials. The criterion that is used makes the preconditioned
matrix s(A)A as close as possible to the identity matrix in some sense. For example, the spectrum of the preconditioned matrix can be made as close as possible to
that of the identity. Denoting by σ(A) the spectrum of A, and by Pk the space of
polynomials of degree not exceeding k, the following may be solved.
Find s ∈ Pk which minimizes:
max |1 − λs(λ)|.

λ∈σ(A)

(12.4)

Unfortunately, this problem involves all the eigenvalues of A and is harder to solve
than the original problem. Usually, problem (12.4) is replaced by the problem
Find s ∈ Pk which minimizes:

max |1 − λs(λ)|,
λ∈E

(12.5)

which is obtained from replacing the set σ(A) by some continuous set E that encloses
it. Thus, a rough idea of the spectrum of the matrix A is needed. Consider first the
particular case where A is Symmetric Positive Definite, in which case E can be taken
to be an interval [α, β] containing the eigenvalues of A.
A variation of Theorem 6.25 is that for any real scalar γ such with γ ≤ α, the
minimum
min
max |p(t)|
p∈Pk ,p(γ)=1 t∈[α,β]

is reached for the shifted and scaled Chebyshev polynomial of the first kind,


α−t
Ck 1 + 2 β−α

.
Ĉk (t) ≡
α−γ
Ck 1 + 2 β−α
Of interest is the case where γ = 0 which gives the polynomial




β + α − 2t
β+α
1
Ck
with σk ≡ Ck
.
Tk (t) ≡
σk
β−α
β−α

Denote the center and mid-width of the interval [α, β], respectively, by
θ≡

β+α
,
2

δ≡

β−α
.
2

Using these parameters instead of α, β, the above expressions then become


 
1
θ−t
θ
Tk (t) ≡
Ck
with σk ≡ Ck
.
σk
δ
δ

CHAPTER 12. PARALLEL PRECONDITIONERS

398

The three-term recurrence for the Chebyshev polynomials results in the following
three-term recurrences:
θ
σk+1 = 2 σk − σk−1 , k = 1, 2 . . . ,
δ
with
σ1 =

θ
,
δ

σ0 = 1,

and
Tk+1 (t) ≡
=
with


θ−t
σk Tk (t) − σk−1 Tk−1 (t)
2
σk+1
δ


σk
σk−1
θ−t
Tk (t) −
Tk−1 (t) ,
2
σk+1
δ
σk
1



t
T1 (t) = 1 − ,
θ

T0 (t) = 1.

σk
,
σk+1

k = 1, 2, . . . .

k ≥ 1,

Define
ρk ≡

(12.6)

Note that the above recurrences can be put together as
1
2σ1 − ρk−1


 
t
Tk (t) − ρk−1 Tk−1 (t) ,
Tk+1 (t) = ρk 2 σ1 −
δ
ρk =

(12.7)
k ≥ 1.

(12.8)

Observe that formulas (12.7–12.8) can be started at k = 0 provided we set T−1 ≡ 0
and ρ−1 ≡ 0, so that ρ0 = 1/(2σ1 ).
The goal is to obtain an iteration that produces a residual vector of the form
rk+1 = Tk+1 (A)r0 where Tk is the polynomial defined by the above recurrence.
The difference between two successive residual vectors is given by
rk+1 − rk = (Tk+1 (A) − Tk (A))r0 .
The identity 1 = (2σ1 − ρk−1 )ρk and the relations (12.8) yield
Tk+1 (t) − Tk (t) = Tk+1 (t) − (2σ1 − ρk−1 )ρk Tk (t)
= ρk




2t
− Tk (t) + ρk−1 (Tk (t) − Tk−1 (t)) .
δ

As a result,


Tk (t) − Tk−1 (t) 2
Tk+1 (t) − Tk (t)
= ρk ρk−1
− Tk (t) .
t
t
δ

(12.9)

12.3. POLYNOMIAL PRECONDITIONERS

399

Define
dk ≡ xk+1 − xk ,

and note that rk+1 − rk = −Adk . As a result, the relation (12.9) translates into the
recurrence,


2
dk = ρk ρk−1 dk−1 + rk .
δ
Finally, the following algorithm is obtained.
A LGORITHM 12.1 Chebyshev Acceleration

1.
2.
3.
4.
5.
6.
7.
8.

r0 = b − Ax0 ; σ1 = θ/δ;
ρ0 = 1/σ1 ; d0 = 1θ r0 ;
For k = 0, . . . , until convergence Do:
xk+1 = xk + dk
rk+1 = rk − Adk
ρk+1 = (2σ1 − ρk )−1 ;
2ρ
dk+1 = ρk+1 ρk dk + k+1
δ rk+1
EndDo

Note that the algorithm requires no inner products, and this constitutes one of its
attractions in a parallel computing environment. Lines 7 and 4 can also be recast into
one single update of the form


2
xk+1 = xk + ρk ρk−1 (xk − xk−1 ) + (b − Axk ) .
δ
It can be shown that when α = λ1 and β = λN , the resulting preconditioned
matrix minimizes the condition number of the preconditioned matrices of the form
As(A) over all polynomials s of degree ≤ k − 1. However, when used in conjunction with the Conjugate Gradient method, it is observed that the polynomial which
minimizes the total number of Conjugate Gradient iterations is far from being the
one which minimizes the condition number. If instead of taking α = λ1 and β = λN ,
the interval [α, β] is chosen to be slightly inside the interval [λ1 , λN ], a much faster
convergence might be achieved. The true optimal parameters, i.e., those that minimize the number of iterations of the polynomial preconditioned Conjugate Gradient
method, are difficult to determine in practice.
There is a slight disadvantage to the approaches described above. The parameters
α and β, which approximate the smallest and largest eigenvalues of A, are usually
not available beforehand and must be obtained in some dynamic way. This may be
a problem mainly because a software code based on Chebyshev acceleration could
become quite complex.
To remedy this, one may ask whether the values provided by an application of
Gershgorin’s theorem can be used for α and β. Thus, in the symmetric case, the
parameter α, which estimates the smallest eigenvalue of A, may be nonpositive even
when A is a positive definite matrix. However, when α ≤ 0, the problem of minimizing (12.5) is not well defined, since it does not have a unique solution due to the non

400

CHAPTER 12. PARALLEL PRECONDITIONERS

strict-convexity of the uniform norm. An alternative uses the L2 -norm on [α, β] with
respect to some weight function w(λ). This “least-squares” polynomials approach is
considered next.

12.3.3

Least-Squares Polynomials

Consider the inner product on the space Pk :
Z β
p(λ)q(λ)w(λ)dλ
hp, qi =

(12.10)

α

where w(λ) is some non-negative weight function on (α, β). Denote by kpkw and
call w-norm, the 2-norm induced by this inner product.
We seek the polynomial sk−1 which minimizes
k1 − λs(λ)kw

(12.11)

over all polynomials s of degree ≤ k − 1. Call sk−1 the least-squares iteration polynomial, or simply the least-squares polynomial, and refer to Rk (λ) ≡ 1 − λsk−1 (λ)
as the least-squares residual polynomial. A crucial observation is that the least
squares polynomial is well defined for arbitrary values of α and β. Computing the
polynomial sk−1 (λ) is not a difficult task when the weight function w is suitably
chosen.
Computation of the least-squares polynomials There are three ways to compute the least-squares polynomial sk defined in the previous section. The first approach is to use an explicit formula for Rk , known as the kernel polynomials formula,
Pk
i=0 qi (0)qi (λ)
(12.12)
Rk (λ) = P
k
2
i=0 qi (0)

in which the qi ’s represent a sequence of polynomials orthogonal with respect to the
weight function w(λ). The second approach generates a three-term recurrence satisfied by the residual polynomials Rk (λ). These polynomials are orthogonal with
respect to the weight function λw(λ). From this three-term recurrence, we can proceed exactly as for the Chebyshev iteration to obtain a recurrence formula for the
sequence of approximate solutions xk . Finally, a third approach solves the Normal
Equations associated with the minimization of (12.11), namely,
h1 − λsk−1 (λ), λQj (λ)i = 0, j = 0, 1, 2, . . . , k − 1

where Qj , j = 1, . . . , k − 1 is any basis of the space Pk−1 of polynomials of degree
≤ k − 1.
These three approaches can all be useful in different situations. For example, the
first approach can be useful for computing least-squares polynomials of low degree
explicitly. For high-degree polynomials, the last two approaches are preferable for

12.3. POLYNOMIAL PRECONDITIONERS

401

their better numerical behavior. The second approach is restricted to the case where
α ≥ 0, while the third is more general.
Since the degrees of the polynomial preconditioners are often low, e.g., not exceeding 5 or 10, we will give some details on the first formulation. Let qi (λ), i =
0, 1, . . . , n, . . ., be the orthonormal polynomials with respect to w(λ). It is known
that the least-squares residual polynomial Rk (λ) of degree k is determined by the
kernel polynomials formula (12.12). To obtain sk−1 (λ), simply notice that
sk−1 (λ) =
=
ti (λ) =

1 − Rk (λ)
Pk λ
i=0 qi (0)ti (λ)
,
P
k
2
i=0 qi (0)
qi (0) − qi (λ)
.
λ

with

(12.13)
(12.14)

This allows sk−1 to be computed as a linear combination of the polynomials ti (λ).
Thus, we can obtain the desired least-squares polynomials from the sequence of orthogonal polynomials qi which satisfy a three-term recurrence of the form:
βi+1 qi+1 (λ) = (λ − αi )qi (λ) − βi qi−1 (λ), i = 1, 2, . . . .
From this, the following recurrence for the ti ’s can be derived:
βi+1 ti+1 (λ) = (λ − αi )ti (λ) − βi ti−1 (λ) + qi (0), i = 1, 2, . . . .
The weight function w is chosen so that the three-term recurrence of the orthogonal polynomials qi is known explicitly and/or is easy to generate. An interesting
class of weight functions that satisfy this requirement is considered next.
Choice of the weight functions This section assumes that α = 0 and β = 1.
Consider the Jacobi weights
1
w(λ) = λµ−1 (1 − λ)ν , where µ > 0 and ν ≥ − .
2

(12.15)

For these weight functions, the recurrence relations are known explicitly for the polynomials that are orthogonal with respect to w(λ), λw(λ), or λ2 w(λ). This allows the
use of any of the three methods described in the previous section for computing
sk−1 (λ). Moreover, it has been shown [180] that the preconditioned matrix Ask (A)
is Symmetric Positive Definite when A is Symmetric Positive Definite, provided that
µ − 1 ≥ ν ≥ − 21 .
The following explicit formula for Rk (λ) can be derived easily from the explicit
expression of the Jacobi polynomials and the fact that {Rk } is orthogonal with respect to the weight λw(λ):
Rk (λ) =

k
X
j=0

(k)

κj (1 − λ)k−j (−λ)j

(12.16)

CHAPTER 12. PARALLEL PRECONDITIONERS

402

(k)
κj =

  j−1
Y k−i+ν
k
j

i=0

i+1+µ

.

Using (12.13), the polynomial sk−1 (λ) = (1 − Rk (λ))/λ can be derived easily “by
hand” for small degrees; see Exercise 4.
Example 12.1. As an illustration, we list the least-squares polynomials sk for k =
1, . . ., 8, obtained for the Jacobi weights with µ = 21 and ν = − 21 . The polynomials
listed are for the interval [0, 4] as this leads to integer coefficients. For a general
interval [0, β], the best polynomial of degree k is sk (4λ/β). Also, each polynomial
sk is rescaled by (3 + 2k)/4 to simplify the expressions. However, this scaling factor
is unimportant if these polynomials are used for preconditioning.

s1
s2
s3
s4
s5
s6
s7
s8

1

λ

λ2

5
14
30
55
91
140
204
285

−1
−7
− 27
− 77
− 182
− 378
− 714
− 1254

1
9
44
156
450
1122
2508

λ3

λ4

−1
− 11
− 65
− 275
− 935
− 2717

1
13
90
442
1729

λ5

λ6

−1
− 15
− 119
− 665

1
17
152

λ7

λ8

−1
− 19

1

We selected µ = 12 and ν = − 21 only because these choices lead to a very simple
recurrence for the polynomials qi , which are the Chebyshev polynomials of the first
kind.
Theoretical considerations An interesting theoretical question is whether the
least-squares residual polynomial becomes small in some sense as its degree increases. Consider first the case 0 < α < β. Since the residual polynomial Rk
minimizes the norm kRkw associated with the weight w, over all polynomials R of
degree ≤ k such that R(0) = 1, the polynomial (1 − (λ/θ))k with θ = (α + β)/2
satisfies






λ k
β−α k
b−a k
kRk kw ≤
1−
≤
=κ
c
b+a
β+α
w

w

where κ is the w-norm of the function unity on the interval [α, β]. The norm of Rk
will tend to zero geometrically as k tends to infinity, provided α > 0.
Consider now the case α = 0, β = 1 and the Jacobi weight (12.15). For this
choice of the weight function, the least-squares residual polynomial is known to be
pk (λ)/pk (0) where pk is the kth degree Jacobi polynomial associated with the weight
function w′ (λ) = λµ (1 − λ)ν . It can be shown that the 2-norm of such a residual

12.3. POLYNOMIAL PRECONDITIONERS

403

polynomial with respect to this weight is given by
kpk /pk (0)k2w′ =

Γ(k + 1)
Γ2 (µ + 1)Γ(k + ν + 1)
(2k + µ + ν + 1)(Γ(k + µ + ν + 1) Γ(k + µ + 1)

in which Γ is the Gamma function. For the case µ = 12 and ν = − 12 , this becomes
kpk /pk (0)k2w′ =

[Γ( 32 )]2
π
1 = 2(2k + 1)2 .
(2k + 1)(k + 2 )

Therefore, the w′ -norm of the least-squares residual polynomial converges to zero
like 1/k as the degree k increases (a much slower rate than when α > 0). However,
note that the condition p(0) = 1 implies that the polynomial must be large in some
interval around the origin.

12.3.4

The Nonsymmetric Case

Given a set of approximate eigenvalues of a nonsymmetric matrix A, a simple region
E can be constructed in the complex plane, e.g., a disk, an ellipse, or a polygon,
which encloses the spectrum of the matrix A. There are several choices for E. The
first idea uses an ellipse E that encloses an approximate convex hull of the spectrum.
Consider an ellipse centered at θ, and with focal distance δ. Then as seen in Chapter
6, the shifted and scaled Chebyshev polynomials defined by

Ck θ−λ
δ

Tk (λ) =
Ck θδ

are nearly optimal. The use of these polynomials leads again to an attractive threeterm recurrence and to an algorithm similar to Algorithm 12.1. In fact, the recurrence
is identical, except that the scalars involved can now be complex to accommodate
cases where the ellipse has foci not necessarily located on the real axis. However,
when A is real, then the symmetry of the foci with respect to the real axis can be
exploited. The algorithm can still be written in real arithmetic.
An alternative to Chebyshev polynomials over ellipses employs a polygon H
that contains σ(A). Polygonal regions may better represent the shape of an arbitrary
spectrum. The best polynomial for the infinity norm is not known explicitly but it
may be computed by an algorithm known in approximation theory as the Remez
algorithm. It may be simpler to use an L2 -norm instead of the infinity norm, i.e.,
to solve (12.11) where w is some weight function defined on the boundary of the
polygon H.
Now here is a sketch of an algorithm based on this approach. An L2 -norm associated with Chebyshev weights on the edges of the polygon is used. If the contour of
H consists of k edges each with center θi and half-length δi , then the weight on each
edge is defined by
wi (λ) =

2
|δi − (λ − θi )2 |−1/2 , i = 1, . . . , k.
π

(12.17)

404

CHAPTER 12. PARALLEL PRECONDITIONERS

Using the power basis to express the best polynomial is not viable. It is preferable
to use the Chebyshev polynomials associated with the ellipse of smallest area containing H. With the above weights or any other Jacobi weights on the edges, there is
a finite procedure which does not require numerical integration to compute the best
polynomial. To do this, each of the polynomials of the basis (i.e., the Chebyshev
polynomials associated with the ellipse of smallest area containing H) must be expressed as a linear combination of the Chebyshev polynomials associated with the
different intervals [θi − δi , θi + δi ]. This redundancy allows exact expressions for the
integrals involved in computing the least-squares solution to (12.11).
Next, the main lines of a preconditioned GMRES algorithm are described based
on least-squares polynomials. Eigenvalue estimates are obtained from a GMRES step
at the beginning of the outer loop. This GMRES adaptive corrects the current solution
and the eigenvalue estimates are used to update the current polygon H. Correcting
the solution at this stage is particularly important since it often results in a few orders
of magnitude improvement. This is because the polygon H may be inaccurate and
the residual vector is dominated by components in one or two eigenvectors. The
GMRES step will immediately annihilate those dominating components. In addition,
the eigenvalues associated with these components will now be accurately represented
by eigenvalues of the Hessenberg matrix.
A LGORITHM 12.2 Polynomial Preconditioned GMRES

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.

Start or Restart:
Compute current residual vector r := b − Ax.
Adaptive GMRES step:
Run m1 steps of GMRES for solving Ad = r .
Update x by x := x + d.
Get eigenvalue estimates from the eigenvalues of the
Hessenberg matrix.
Compute new polynomial:
Refine H from previous hull H and new eigenvalue estimates.
Get new best polynomial sk .
Polynomial Iteration:
Compute the current residual vector r = b − Ax.
Run m2 steps of GMRES applied to sk (A)Ad = sk (A)r .
Update x by x := x + d.
Test for convergence.
If solution converged then Stop; else GoTo 1.

Example 12.2. Table 12.1 shows the results of applying GMRES(20) with polynomial preconditioning to the first four test problems described in Section 3.7. See
Example 6.1 for the meaning of the column headers in the table. In fact, the system is
preconditioned by ILU(0) before polynomial preconditioning is applied to it. Degree
10 polynomials (maximum) are used. The tolerance for stopping is 10−7 . Recall

12.3. POLYNOMIAL PRECONDITIONERS

405

Matrix

Iters

Kflops

Residual

Error

F2DA

56

2774

0.22E-05

0.51E-06

F3D

22

7203

0.18E-05

0.22E-05

ORS

78

4454

0.16E-05

0.32E-08

F2DB

100

4432

0.47E-05

0.19E-05

Table 12.1: A test run of ILU(0)-GMRES accelerated with polynomial preconditioning.
that Iters is the number of matrix-by-vector products rather than the number of GMRES iterations. Notice that, for most cases, the method does not compare well with
the simpler ILU(0) example seen in Chapter 10. The notable exception is example
F2DB for which the method converges fairly fast in contrast with the simple ILU(0)GMRES; see Example 10.2. An attempt to use the method for the fifth matrix in the
test set, namely, the FIDAP matrix FID, failed because the matrix has eigenvalues on
both sides of the imaginary axis and the code tested does not handle this situation.
It is interesting to follow the progress of the algorithm in the above examples.
For the first example, the coordinates of the vertices of the upper part of the first
polygon H are
ℜe(ci )

ℑm(ci )

0.06492
0.17641
0.29340
0.62858
1.18052

0.00000
0.02035
0.03545
0.04977
0.00000

This hull is computed from the 20 eigenvalues of the 20 × 20 Hessenberg matrix
resulting from the first run of GMRES(20). In the ensuing GMRES loop, the outer
iteration converges in three steps, each using a polynomial of degree 10, i.e., there is
no further adaptation required. For the second problem, the method converges in the
20 first steps of GMRES, so polynomial acceleration was never invoked. For the third
example, the initial convex hull found is the interval [0.06319, 1.67243] of the real
line. The polynomial preconditioned GMRES then convergences in five iterations.
Finally, the initial convex hull found for the last example is
ℜe(ci )

ℑm(ci )

0.17131
0.39337
1.43826

0.00000
0.10758
0.00000

CHAPTER 12. PARALLEL PRECONDITIONERS

406

and the outer loop converges again without another adaptation step, this time in seven
steps.

12.4

Multicoloring

The general idea of multicoloring, or graph coloring, has been used for a long time
by numerical analysts. It was exploited, in particular, in the context of relaxation
techniques both for understanding their theory and for deriving efficient algorithms.
More recently, these techniques were found to be useful in improving parallelism
in iterative solution techniques. This discussion begins with the 2-color case, called
red-black ordering.

12.4.1

Red-Black Ordering

The problem addressed by multicoloring is to determine a coloring of the nodes of the
adjacency graph of a matrix such that any two adjacent nodes have different colors.
For a 2-dimensional finite difference grid (5-point operator), this can be achieved
with two colors, typically referred to as “red” and “black.” This red-black coloring
is illustrated in Figure 12.2 for a 6 × 4 mesh where the black nodes are represented
by filled circles.
19

20

21

22

23

24

13

14

15

16

17

18

7

8

9

10

11

12

1

2

3

4

5

6

Figure 12.2: Red-black coloring of a 6 × 4 grid. Natural labeling of the nodes.
Assume that the unknowns are labeled by listing the red unknowns first together,
followed by the black ones. The new labeling of the unknowns is shown in Figure
12.3. Since the red nodes are not coupled with other red nodes and, similarly, the
black nodes are not coupled with other black nodes, the system that results from this
reordering will have the structure
   

D1 F
b1
x1
,
(12.18)
=
b2
x2
E D2
in which D1 and D2 are diagonal matrices. The reordered matrix associated with
this new labeling is shown in Figure 12.4.

12.4. MULTICOLORING

407

22

10

23

11

24

12

7

19

8

20

9

21

16

4

17

5

18

6

1

13

2

14

3

15

Figure 12.3: Red-black coloring of a 6 × 4 grid. Red-black labeling of the nodes.

Figure 12.4: Matrix associated with the red-black reordering of Figure 12.3.
Two issues will be explored regarding red-black ordering. The first is how to
exploit this structure for solving linear systems. The second is how to generalize this
approach for systems whose graphs are not necessarily 2-colorable.

12.4.2

Solution of Red-Black Systems

The easiest way to exploit the red-black ordering is to use the standard SSOR or
ILU(0) preconditioners for solving the block system (12.18) which is derived from
the original system. The resulting preconditioning operations are highly parallel. For
example, the linear system that arises from the forward solve in SSOR will have the
form

   
D1 O
b1
x1
.
=
b2
x2
E D2

This system can be solved by performing the following sequence of operations:

1.
2.
3.

Solve D1 x1 = b1 .
Compute b̂2 := b2 − Ex1 .
Solve D2 x2 = b̂2 .

408

CHAPTER 12. PARALLEL PRECONDITIONERS

This consists of two diagonal scalings (operations 1 and 3) and a sparse matrixby-vector product. Therefore, the degree of parallelism, is at least n/2 if an atomic
task is considered to be any arithmetic operation. The situation is identical with
the ILU(0) preconditioning. However, since the matrix has been reordered before
ILU(0) is applied to it, the resulting LU factors are not related in any simple way
to those associated with the original matrix. In fact, a simple look at the structure
of the ILU factors reveals that many more elements are dropped with the red-black
ordering than with the natural ordering. The result is that the number of iterations
to achieve convergence can be much higher with red-black ordering than with the
natural ordering.
A second method that has been used in connection with the red-black ordering
solves the reduced system which involves only the black unknowns. Eliminating the
red unknowns from (12.18) results in the reduced system:
(D2 − ED1−1 F )x2 = b2 − ED1−1 b1 .
Note that this new system is again a sparse linear system with about half as many
unknowns. In addition, it has been observed that for “easy problems,” the reduced
system can often be solved efficiently with only diagonal preconditioning. The computation of the reduced system is a highly parallel and inexpensive process. Note
that it is not necessary to form the reduced system. This strategy is more often employed when D1 is not diagonal, such as in domain decomposition methods, but it
can also have some uses in other situations. For example, applying the matrix to a
given vector x can be performed using nearest-neighbor communication, and this can
be more efficient than the standard approach of multiplying the vector by the Schur
complement matrix D2 − ED1−1 F . In addition, this can save storage, which may be
more critical in some cases.

12.4.3

Multicoloring for General Sparse Matrices

Chapter 3 discussed a general greedy approach for multicoloring a graph. Given a
general sparse matrix A, this inexpensive technique allows us to reorder it into a
block form where the diagonal blocks are diagonal matrices. The number of blocks
is the number of colors. For example, for six colors, a matrix would result with the
structure shown in Figure 12.5 where the Di ’s are diagonal and E, F are general
sparse. This structure is obviously a generalization of the red-black ordering.
Just as for the red-black ordering, ILU(0), SOR, or SSOR preconditioning can
be used on this reordered system. The parallelism of SOR/SSOR is now of order n/p
where p is the number of colors. A loss in efficiency may occur since the number of
iterations is likely to increase.
A Gauss-Seidel sweep will essentially consist of p scalings and p − 1 matrix-byvector products, where p is the number of colors. Specifically, assume that the matrix
is stored in the well known Ellpack-Itpack format and that the block structure of the
permuted matrix is defined by a pointer array iptr. The index iptr(j) is the index of
the first row in the j-th block.

12.5. MULTI-ELIMINATION ILU

409

D1
D2

F
D3
D4

E

D5
D6

Figure 12.5: A six-color ordering of a general sparse matrix.
Thus, the pair A(n1 : n2, ∗), JA(n1 : n2, ∗) represents the sparse matrix consisting of the rows n1 to n2 in the Ellpack-Itpack format. The main diagonal of A
is assumed to be stored separately in inverted form in a one-dimensional array diag.
One single step of the multicolor SOR iteration will then take the following form.
A LGORITHM 12.3 Multicolor SOR Sweep in the Ellpack Format

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

Do col = 1, ncol
n1 = iptr(col)
n2 = iptr(col+1) – 1
y(n1:n2) = rhs(n1:n2)
Do j = 1, ndiag
Do i = n1, n2
y(i) = y(i) – a(i,j)*y(ja(i,j))
EndDo
EndDo
y(n1:n2) = diag(n1:n2) * y(n1:n2)
EndDo

In the above algorithm, ncol is the number of colors. The integers n1 and n2 set in
lines 2 and 3 represent the beginning and the end of block col. In line 10, y(n1 : n2)
is multiplied by the diagonal D −1 which is kept in inverted form in the array diag.
The outer loop, i.e., the loop starting in line 1, is sequential. The loop starting in
line 6 is vectorizable/parallelizable. There is additional parallelism which can be
extracted in the combination of the two loops starting in lines 5 and 6.

12.5

Multi-Elimination ILU

The discussion in this section begins with the Gaussian elimination algorithm for a
general sparse linear system. Parallelism in sparse Gaussian elimination can be obtained by finding unknowns that are independent at a given stage of the elimination,

410

CHAPTER 12. PARALLEL PRECONDITIONERS

i.e., unknowns that do not depend on each other according to the binary relation defined by the graph of the matrix. A set of unknowns of a linear system which are
independent is called an independent set. Thus, independent set orderings can be
viewed as permutations to put the original matrix in the form


D E
(12.19)
F C
in which D is diagonal, but C can be arbitrary. This amounts to a less restrictive
form of multicoloring, in which a set of vertices in the adjacency graph is found so
that no equation in the set involves unknowns from the same set. A few algorithms
for finding independent set orderings of a general sparse graph were discussed in
Chapter 3.
The rows associated with an independent set can be used as pivots simultaneously. When such rows are eliminated, a smaller linear system results, which is again
sparse. Then we can find an independent set for this reduced system and repeat the
process of reduction. The resulting second reduced system is called the second-level
reduced system.
The process can be repeated recursively a few times. As the level of the reduction increases, the reduced systems gradually lose their sparsity. A direct solution
method would continue the reduction until the reduced system is small enough or
dense enough to switch to a dense Gaussian elimination to solve it. This process is
illustrated in Figure 12.6. There exists a number of sparse direct solution techniques
based on this approach.

Figure 12.6: Illustration of two levels of multi-elimination for sparse linear systems.
After a brief review of the direct solution method based on independent set orderings, we will explain how to exploit this approach for deriving incomplete LU
factorizations by incorporating drop tolerance strategies.

12.5.1

Multi-Elimination

We start by a discussion of an exact reduction step. Let Aj be the matrix obtained
at the j-th step of the reduction, j = 0, . . . , nlev with A0 = A. Assume that an
independent set ordering is applied to Aj and that the matrix is permuted accordingly

12.5. MULTI-ELIMINATION ILU
as follows:

411




(12.20)

Aj+1 = Cj − Ej Dj−1 Fj .

(12.21)

Pj Aj PjT =

Dj
Ej

Fj
Cj

where Dj is a diagonal matrix. Now eliminate the unknowns of the independent set
to get the next reduced matrix,

This results, implicitly, in a block LU factorization
 

 
Dj
Dj Fj
I
O
×
Pj Aj PjT =
=
Ej Dj−1 I
O
Ej Cj

Fj
Aj+1



with Aj+1 defined above. Thus, in order to solve a system with the matrix Aj , both
a forward and a backward substitution need to be performed with the block matrices
on the right-hand side of the above system. The backward solution involves solving
a system with the matrix Aj+1 .
This block factorization approach can be used recursively until a system results
that is small enough to be solved with a standard method. The transformations used
in the elimination process, i.e., the matrices Ej Dj−1 and the matrices Fj must be
saved. The permutation matrices Pj can also be saved. Alternatively, the matrices
involved in the factorization at each new reordering step can be permuted explicitly.

Figure 12.7: Illustration of the processed matrices obtained from three steps of independent set ordering and reductions.

CHAPTER 12. PARALLEL PRECONDITIONERS

412

12.5.2

ILUM

The successive reduction steps described above will give rise to matrices that become more and more dense due to the fill-ins introduced by the elimination process.
In iterative methods, a common cure for this is to neglect some of the fill-ins introduced by using a simple dropping strategy as the reduced systems are formed. For
example, any fill-in element introduced is dropped, whenever its size is less than a
given tolerance times the 2-norm of the original row. Thus, an “approximate” version of the successive reduction steps can be used to provide an approximate solution
M −1 v to A−1 v for any given v. This can be used to precondition the original linear system. Conceptually, the modification leading to an “incomplete” factorization
replaces (12.21) by
Aj+1 = (Cj − Ej Dj−1 Fj ) − Rj
(12.22)
in which Rj is the matrix of the elements that are dropped in this reduction step.
Globally, the algorithm can be viewed as a form of incomplete block LU with permutations.
Thus, there is a succession of block ILU factorizations of the form


Dj Fj
T
Pj Aj Pj =
E Cj
 j
 



I
O
Dj
Fj
O O
=
×
+
Ej Dj−1 I
O Aj+1
O Rj
with Aj+1 defined by (12.22). An independent set ordering for the new matrix Aj+1
will then be found and this matrix is reduced again in the same manner. It is not
necessary to save the successive Aj matrices, but only the last one that is generated.
We need also to save the sequence of sparse matrices


Dj
Fj
Bj+1 =
(12.23)
Ej Dj−1 O
which contain the transformation needed at level j of the reduction. The successive permutation matrices Pj can be discarded if they are applied to the previous
Bi matrices as soon as these permutation matrices are known. Then only the global
permutation is needed, which is the product of all these successive permutations.
An illustration of the matrices obtained after three reduction steps is shown in
Figure 12.7. The original matrix is a 5-point matrix associated with a 15×15 grid and
is therefore of size N = 225. Here, the successive matrices Bi (with permutations
applied) are shown together with the last Aj matrix which occupies the location of
the O block in (12.23).
We refer to this incomplete factorization as ILUM (ILU with Multi-Elimination).
The preprocessing phase consists of a succession of nlev applications of the following three steps: (1) finding the independent set ordering, (2) permuting the matrix,
and (3) reducing it.
A LGORITHM 12.4 ILUM: Preprocessing Phase

12.5. MULTI-ELIMINATION ILU
1.
2.
3.
4.
5.
6.
7.
8.

413

Set A0 = A.
For j = 0, 1, . . . , nlev − 1 Do:
Find an independent set ordering permutation Pj for Aj ;
Apply Pj to Aj to permute it into the form (12.20);
Apply Pj to B1 , . . . , Bj ;
Apply Pj to P0 , . . . , Pj−1 ;
Compute the matrices Aj+1 and Bj+1 defined by (12.22) and (12.23).
EndDo

In the backward and forward solution phases, the last reduced system must be solved
but not necessarily with high accuracy. For example, we can solve it according to the
level of tolerance allowed in the dropping strategy during the preprocessing phase.
Observe that if the linear system is solved inaccurately, only an accelerator that
allows variations in the preconditioning should be used. Such algorithms have been
discussed in Chapter 9. Alternatively, we can use a fixed number of multicolor SOR
or SSOR steps or a fixed polynomial iteration. The implementation of the ILUM preconditioner corresponding to this strategy is rather complicated and involves several
parameters.
In order to describe the forward and backward solution, we introduce some notation. We start by applying the “global permutation,” i.e., the product
Pnlev−1 , Pnlev−2 . . . , P0
to the right-hand side. We overwrite the result on the current solution vector, an
N -vector called x0 . Now partition this vector into
 
y0
x0 =
x1
according to the partitioning (12.20). The forward step consists of transforming the
second component of the right-hand side as
x1 := x1 − E0 D0−1 y0 .
Now x1 is partitioned in the same manner as x0 and the forward elimination is continued the same way. Thus, at each step, each xj is partitioned as


yj
xj =
.
xj+1
A forward elimination step defines the new xj+1 using the old xj+1 and yj for j =
0, . . . , nlev − 1 while a backward step defines yj using the old yj and xj+1 , for
j = nlev − 1, . . . , 0. Algorithm 12.5 describes the general structure of the forward
and backward solution sweeps. Because the global permutation was applied at the
beginning, the successive permutations need not be applied. However, the final result
obtained must be permuted back into the original ordering.

414

CHAPTER 12. PARALLEL PRECONDITIONERS

A LGORITHM 12.5 ILUM: Forward and Backward Solutions

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

Apply global permutation to right-hand-side b and copy into x0 .
For j = 0, 1, . . . , nlev − 1 Do: [Forward sweep]
xj+1 := xj+1 − Ej Dj−1 yj
EndDo
Solve with a relative tolerance ǫ:
Anlev xnlev := xnlev .
For j = nlev − 1, . . . , 1, 0 Do: [Backward sweep]
yj := Dj−1 (yj − Fj xj+1 ).
EndDo
Permute the resulting solution vector back to the original
ordering to obtain the solution x.

Computer implementations of ILUM can be rather tedious. The implementation issues are similar to those of parallel direct-solution methods for sparse linear
systems.

12.6

Distributed ILU and SSOR

This section describes parallel variants of the block Successive Over-Relaxation
(BSOR) and ILU(0) preconditioners which are suitable for distributed memory environments. Chapter 11 briefly discussed distributed sparse matrices. A distributed
matrix is a matrix whose entries are located in the memories of different processors
in a multiprocessor system. These types of data structures are very convenient for
distributed memory computers and it is useful to discuss implementations of preconditioners that are specifically developed for them. Refer to Section 11.5.5 for the
terminology used here. In particular, the term subdomain is used in the very general
sense of subgraph. For both ILU and SOR, multicoloring or level scheduling can be
used at the macro level, to extract parallelism. Here, macro level means the level of
parallelism corresponding to the processors, or blocks, or subdomains.
In the ILU(0) factorization, the LU factors have the same nonzero patterns as
the original matrix A, so that the references of the entries belonging to the external
subdomains in the ILU(0) factorization are identical with those of the matrix-byvector product operation with the matrix A. This is not the case for the more accurate
ILU(p) factorization, with p > 0. If an attempt is made to implement a wavefront
ILU preconditioner on a distributed memory computer, a difficulty arises because the
natural ordering for the original sparse problem may put an unnecessary limit on the
amount of parallelism available. Instead, a two-level ordering is used. First, define a
“global” ordering which is a wavefront ordering for the subdomains. This is based on
the graph which describes the coupling between the subdomains: Two subdomains
are coupled if and only if they contain at least a pair of coupled unknowns, one from
each subdomain. Then, within each subdomain, define a local ordering.

12.6. DISTRIBUTED ILU AND SSOR

415

Proc. 14

Proc. 13

Proc. 6
Proc. 10

Internal interface points
Proc. 2
Proc. 4
External interface points

Figure 12.8: A local view of the distributed ILU(0).
To describe the possible parallel implementations of these ILU(0) preconditioners, it is sufficient to consider a local view of the distributed sparse matrix, illustrated
in Figure 12.8. The problem is partitioned into p subdomains or subgraphs using
some graph partitioning technique. This results in a mapping of the matrix into processors where it is assumed that the i-th equation (row) and the i-th unknown are
mapped to the same processor. We distinguish between interior points and interface
points. The interior points are those nodes that are not coupled with nodes belonging
to other processors. Interface nodes are those local nodes that are coupled with at
least one node which belongs to another processor. Thus, processor number 10 in
the figure holds a certain number of rows that are local rows.
Consider the rows associated with the interior nodes. The unknowns associated
with these nodes are not coupled with variables from other processors. As a result,
the rows associated with these nodes can be eliminated independently in the ILU(0)
process. The rows associated with the nodes on the interface of the subdomain will
require more attention. Recall that an ILU(0) factorization is determined entirely by
the order in which the rows are processed.
The interior nodes can be eliminated first. Once this is done, the interface rows
can be eliminated in a certain order. There are two natural choices for this order.
The first would be to impose a global order based on the labels of the processors.
Thus, in the illustration, the interface rows belonging to Processors 2, 4, and 6 are
processed before those in Processor 10. The interface rows in Processor 10 must in
turn be processed before those of Processors 13 and 14.
The local order, i.e., the order in which we process the interface rows in the same
processor (e.g. Processor 10), may not be as important. This global order based on
PE-number defines a natural priority graph and parallelism can be exploited easily in
a data-driven implementation.
It is somewhat unnatural to base the ordering just on the processor labeling.

416

CHAPTER 12. PARALLEL PRECONDITIONERS

Observe that a proper order can also be defined for performing the elimination by
replacing the PE-numbers with any labels, provided that any two neighboring processors have a different label. The most natural way to do this is by performing a
multicoloring of the subdomains, and using the colors in exactly the same way as
before to define an order of the tasks. The algorithms will be written in this general
form, i.e., with a label associated with each processor. Thus, the simplest valid labels
are the PE numbers, which lead to the PE-label-based order. In the following, we
define Labj as the label of Processor number j.
A LGORITHM 12.6 Distributed ILU(0) factorization

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

In each processor Pi , i = 1, . . . , p Do:
Perform the ILU(0) factorization for interior local rows.
Receive the factored rows from the adjacent processors j with
Labj < Labi .
Perform the ILU(0) factorization for the interface rows with
pivots received from the external processors in step 3.
Perform the ILU(0) factorization for the boundary nodes, with
pivots from the interior rows completed in step 2.
Send the completed interface rows to adjacent processors j with
Labj > Labi .
EndDo

Step 2 of the above algorithm can be performed in parallel because it does not depend on data from other subdomains. Once this distributed ILU(0) factorization is
completed, the preconditioned Krylov subspace algorithm will require a forward and
backward sweep at each step. The distributed forward/backward solution based on
this factorization can be implemented as follows.
A LGORITHM 12.7 Distributed Forward and Backward Sweep

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.

In each processor Pi , i = 1, . . . , p Do:
Forward solve:
Perform the forward solve for the interior nodes.
Receive the updated values from the adjacent processors j
with Labj < Labi .
Perform the forward solve for the interface nodes.
Send the updated values of boundary nodes to the adjacent
processors j with Labj > Labi .
Backward solve:
Receive the updated values from the adjacent processors j
with Labj > Labi .
Perform the backward solve for the boundary nodes.
Send the updated values of boundary nodes to the adjacent
processors, j with Labj < Labi .
Perform the backward solve for the interior nodes.
EndDo

12.7. OTHER TECHNIQUES

417

As in the ILU(0) factorization, the interior nodes do not depend on the nodes from
the external processors and can be computed in parallel in lines 3 and 15. In the
forward solve, the solution of the interior nodes is followed by an exchange of data
and the solution on the interface. The backward solve works in reverse in that the
boundary nodes are first computed, then they are sent to adjacent processors. Finally,
interior nodes are updated.

12.7

Other Techniques

This section gives a brief account of other parallel preconditioning techniques which
are sometimes used. The next chapter also examines another important class of methods, which were briefly mentioned before, namely, the class of Domain Decomposition methods.

12.7.1

Approximate Inverses

Another class of preconditioners that require only matrix-by-vector products, is the
class of approximate inverse preconditioners. Discussed in Chapter 10, these can be
used in many different ways. Besides being simple to implement, both their preprocessing phase and iteration phase allow a large degree of parallelism. Their disadvantage is similar to polynomial preconditioners, namely, the number of steps required
for convergence may be large, possibly substantially larger than with the standard
techniques. On the positive side, they are fairly robust techniques which can work
well where standard methods may fail.

12.7.2

Element-by-Element Techniques

A somewhat specialized set of techniques is the class of Element-By-Element (EBE)
preconditioners which are geared toward finite element problems and are motivated
by the desire to avoid assembling finite element matrices. Many finite element codes
keep the data related to the linear system in unassembled form. The element matrices
associated with each element are stored and never added together. This is convenient
when using direct methods since there are techniques, known as frontal methods, that
allow Gaussian elimination to be performed by using a few elements at a time.
It was seen in Chapter 2 that the global stiffness matrix A is the sum of matrices
A[e] associated with each element, i.e.,
A =

N el
X

A[e] .

e=1

Here, the matrix A[e] is an n × n matrix defined as
A[e] = Pe AKe PeT
in which AKe is the element matrix and Pe is a Boolean connectivity matrix which
maps the coordinates of the small AKe matrix into those of the full matrix A. Chapter

418

CHAPTER 12. PARALLEL PRECONDITIONERS

2 showed how matrix-by-vector products can be performed in unassembled form. To
perform this product in parallel, note that the only potential obstacle to performing
the matrix-by-vector product in parallel, i.e., across all elements, is in the last phase,
i.e., when the contributions are summed to the resulting vector y. In order to add the
contributions A[e] x in parallel, group elements that do not have nodes in common.
Referring to Equation (2.46), the contributions
ye = AKe (PeT x)
can all be computed in parallel and do not depend on one another. The operations
y := y + Pe ye
can be processed in parallel for any group of elements that do not share any vertices.
This grouping can be found by performing a multicoloring of the elements. Any two
elements which have a node in common receive a different color. Using this idea,
good performance can be achieved on vector computers.
EBE preconditioners are based on similar principles and many different variants
have been developed. They are defined by first normalizing each of the element
matrices. In the sequel, assume that A is a Symmetric Positive Definite matrix.
Typically, a diagonal, or block diagonal, scaling is first applied to A to obtain a
scaled matrix Ã,
Ã = D −1/2 AD −1/2 .
(12.24)
This results in each matrix A[e] and element matrix AKe being transformed similarly:
Ã[e] = D −1/2 A[e] D −1/2
= D −1/2 Pe AKe D −1/2
= Pe (PeT D −1/2 Pe )A[e] (Pe D −1/2 PeT )
≡ Pe ÃKe PeT .
The second step in defining an EBE preconditioner is to regularize each of these
transformed matrices. Indeed, each of the matrices A[e] is of rank pe at most, where
pe is the size of the element matrix AKe , i.e., the number of nodes which constitute
the e-th element. In the so-called Winget regularization, the diagonal of each A[e] is
forced to be the identity matrix. In other words, the regularized matrix is defined as
Ā[e] = I + Ã[e] − diag(Ã[e] ).

(12.25)

These matrices are positive definite; see Exercise 8.
The third and final step in defining an EBE preconditioner is to choose the factorization itself. In the EBE Cholesky factorization, the Cholesky (or Crout) factorization of each regularized matrix Ā[e] is performed,
Ā[e] = Le De LTe .

(12.26)

12.7. OTHER TECHNIQUES

419

The preconditioner from it is defined as
M=

nel
Y

e=1

Le ×

nel
Y

e=1

De ×

1
Y

LTe .

(12.27)

e=nel

Note that to ensure symmetry, the last product is in reverse order of the first one.
The factorization (12.26) consists of a factorization of the small pe × pe matrix ĀKe .
Performing the preconditioning operations will therefore consist of a sequence of
small pe ×pe backward or forward solves. The gather and scatter matrices Pe defined
in Chapter 2 must also be applied for each element. These solves are applied to
the right-hand side in sequence. In addition, the same multicoloring idea as for the
matrix-by-vector product can be exploited to perform these sweeps in parallel.
One of the drawbacks of the EBE Cholesky preconditioner is that an additional
set of element matrices must be stored. That is because the factorizations (12.26)
must be stored for each element. In EBE/SSOR, this is avoided. Instead of factoring each Ā[e] , the usual splitting of each Ā[e] is exploited. Assuming the Winget
regularization, we have
Ā[e] = I − Ee − EeT
(12.28)
in which −Ee is the strict-lower part of Ā[e] . By analogy with the SSOR preconditioner, the EBE-SSOR preconditioner is defined by
M=

nel
Y

(I − ωEe ) ×

e=1

12.7.3

nel
Y

e=1

De ×

1
Y

e=nel

(I − ωEeT ).

(12.29)

Parallel Row Projection Preconditioners

One of the attractions of row-projection methods seen in Chapter 8 is their high degree of parallelism. In Cimmino’s method, the scalars δi as well as the new residual
vector can be computed in parallel. In the Gauss-Seidel-NE (respectively GaussSeidel-NR), it is also possible to group the unknowns in such a way that any pair
of rows (respectively columns) have disjointed nonzero patterns. Updates of components in the same group can then be performed in parallel. This approach essentially requires finding a multicolor ordering for the matrix B = AAT (respectively
B = AT A ).
It is necessary to first identify a partition of the set {1, 2, . . . , N } into subsets
S1 , . . ., Sk such that the rows (respectively columns) whose indices belong to the
same set Si are structurally orthogonal to each other, i.e., have no nonzero elements
in the same column locations. When implementing a block SOR scheme where the
blocking is identical with that defined by the partition, all of the unknowns belonging
to the same set Sj can be updated in parallel. To be more specific, the rows are
reordered by scanning those in S1 followed by those in S2 , etc.. Denote by Ai the
matrix consisting of the rows belonging to the i-th block. We assume that all rows
of the same set are orthogonal to each other and that they have been normalized

CHAPTER 12. PARALLEL PRECONDITIONERS

420

so that their 2-norm is unity. Then a block Gauss-Seidel sweep, which generalizes
Algorithm 8.1, follows.
A LGORITHM 12.8 Forward Block NE-Gauss-Seidel Sweep

1.
2.
3.
4.
5.

Select an initial x0 .
For i = 1, 2, . . . , k Do:
di = bi − Ai x
x := x + ATi di
EndDo

Here, xi and bi are subvectors corresponding to the blocking and di is a vector of
length the size of the block, which replaces the scalar δi of Algorithm 8.1. There is
parallelism in each of the steps 3 and 4.
The question that arises is how to find good partitions Si . In simple cases, such
as block-tridiagonal matrices, this can easily be done; see Exercise 7. For general
sparse matrices, a multicoloring algorithm on the graph of AAT (respectively AT A)
can be employed. However, these matrices are never stored explicitly. Their rows
can be generated, used, and then discarded.

P ROBLEMS
P-12.1 Let A be a Symmetric Positive Definite matrix and consider N = I − D−1 A where
D is a block diagonal of A.
a. Show that D is a Symmetric Positive Definite matrix. Denote by (., .)D the associated
inner product.
b. Show that N is self-adjoint with respect to to (., .)D .
c. Show that N k is self-adjoint with respect to to (., .)D for any integer k.
d. Show that the Neumann series expansion preconditioner defined by the right-hand side
of (12.3) leads to a preconditioned matrix that is self-adjoint with respect to the D-inner
product.
e. Describe an implementation of the preconditioned CG algorithm using this preconditioner.
P-12.2 The development of the Chebyshev iteration algorithm seen in Section 12.3.2 can
be exploited to derive yet another formulation of the conjugate algorithm from the Lanczos
algorithm. Observe that the recurrence relation (12.8) is not restricted to scaled Chebyshev
polynomials.
a. The scaled Lanczos polynomials, i.e., the polynomials pk (t)/pk (0), in which pk (t) is
the polynomial such that vk+1 = pk (A)v1 in the Lanczos algorithm, satisfy a relation
of the form (12.8). What are the coefficients ρk and δ in this case?
b. Proceed in the same manner as in Section 12.3.2 to derive a version of the Conjugate
Gradient algorithm.

12.7. OTHER TECHNIQUES

421

P-12.3 Show that ρk as defined by (12.7) has a limit ρ. What is this limit? Assume that
Algorithm 12.1 is to be executed with the ρk ’s all replaced by this limit ρ. Will the method
converge? What is the asymptotic rate of convergence of this modified method?
P-12.4 Derive the least-squares polynomials for α = − 21 , β = 21 for the interval [0, 1] for
k = 1, 2, 3, 4. Check that these results agree with those of the table shown at the end of
Section 12.3.3.
P-12.5 Consider the mesh shown below. Assume that the objective is to solve the Poisson
equation with Dirichlet boundary conditions.

a. Consider the resulting matrix obtained (before boundary conditions are applied) from
ordering the nodes from bottom up, and left to right (thus, the bottom left vertex is
labeled 1 and the top right vertex is labeled 13). What is the bandwidth of the linear
system? How many memory locations would be needed to store the matrix in Skyline
format? (Assume that the matrix is nonsymmetric so both upper and lower triangular
parts must be stored).
b. Is it possible to find a 2-color ordering of the mesh points? If so, show the ordering, or
otherwise prove that it is not possible.
c. Find an independent set of size 5. Show the pattern of the matrix associated with this
independent set ordering.
d. Find a multicolor ordering of the mesh by using the greedy multicolor algorithm. Can
you find a better coloring (i.e., a coloring with fewer colors)? If so, show the coloring
[use letters to represent each color].
P-12.6 A linear system Ax = b where A is a 5-point matrix, is reordered using red-black
ordering as
   

x
D1 F
f
=
.
y
E D2
g
a. Write the block Gauss-Seidel iteration associated with the above partitioned system
(where the blocking in block Gauss-Seidel is the same as the above blocking).

b. Express the y iterates, independently of the x iterates, i.e., find an iteration which
involves only y-iterates. What type of iteration is the resulting scheme?
P-12.7 Consider a tridiagonal matrix T = tridiag (ai , bi , ci ). Find a grouping of the rows
such that rows in each group are structurally orthogonal, i.e., orthogonal regardless of the
values of the entry. Find a set of three groups at most. How can this be generalized to block
tridiagonal matrices such as those arising from 2-D and 3-D centered difference matrices?
P-12.8 Why are the Winget regularized matrices Ā[e] defined by (12.25) positive definite
when the matrix Ã is obtained from A by a diagonal scaling from A?

422

CHAPTER 12. PARALLEL PRECONDITIONERS

N OTES AND R EFERENCES . When vector processing appeared in the middle to late 1970s, a number
of efforts were made to change algorithms, or implementations of standard methods, to exploit the
new architectures. One of the first ideas in this context was to perform matrix-by-vector products by
diagonals [184]. Matrix-by-vector products using this format can yield excellent performance. Hence,
came the idea of using polynomial preconditioning.
Polynomial preconditioning was exploited independently of supercomputing, as early as 1937 in
a paper by Cesari [71], and then in a 1952 paper by Lanczos [196]. The same idea was later applied
for eigenvalue problems by Stiefel who employed least-squares polynomials [276], and Rutishauser
[237] who combined the QD algorithm with Chebyshev acceleration. Dubois et al. [105] suggested
using polynomial preconditioning, specifically, the Neumann series expansion, for solving Symmetric
Positive Definite linear systems on vector computers. Johnson et al. [180] later extended the idea by
exploiting Chebyshev polynomials, and other orthogonal polynomials. It was observed in [180] that
least-squares polynomials tend to perform better than those based on the uniform norm, in that they lead
to a better overall clustering of the spectrum. Moreover, as was already observed by Rutishauser [237],
in the symmetric case there is no need for accurate eigenvalue estimates: It suffices to use the simple
bounds that are provided by Gershgorin’s theorem. In [241] it was also observed that in some cases the
least-squares polynomial approach which requires less information than the Chebyshev approach tends
to perform better.
The use of least-squares polynomials over polygons was first advocated by Smolarski and Saylor
[271] and later by Saad [242]. The application to the indefinite case was examined in detail in [240].
Still in the context of using polygons instead of ellipses, yet another attractive possibility proposed
by Fischer and Reichel [129] avoids the problem of best approximation altogether. The polygon can
be conformally transformed into a circle and the theory of Faber polynomials yields a simple way of
deriving good polynomials from exploiting specific points on the circle.
Although only approaches based on the formulation (12.5) and (12.11) have been discussed in
this book, there are other lesser known possibilities based on minimizing k1/λ − s(λ)k∞ . There
has been very little work on polynomial preconditioning or Krylov subspace methods for highly nonnormal matrices; see, however, the recent analysis in [285]. Another important point is that polynomial
preconditioning can be combined with a subsidiary relaxation-type preconditioning such as SSOR [2,
217]. Finally, polynomial preconditionings can be useful in some special situations such as that of
complex linear systems arising from the Helmholtz equation [132].
Multicoloring has been known for a long time in the numerical analysis literature and was used
in particular for understanding the theory of relaxation techniques [322, 293] as well as for deriving
efficient alternative formulations of some relaxation algorithms [293, 151]. With the advent of parallel
processing, it became an essential ingredient in parallelizing iterative algorithms, see for example [4,
2, 117, 219, 218, 228]. In [98] and [248] it was observed that k-step SOR preconditioning was very
competitive relative to the standard ILU preconditioners. Combined with multicolor ordering, multiplestep SOR can perform quite well on vector computers. Multicoloring is also useful in finite element
methods, where elements instead of nodes are colored [31, 297]. In Element-By-Element techniques,
multicoloring is used when forming the residual, i.e., when multiplying an unassembled matrix by a
vector [174, 126, 262]. The contributions of the elements of the same color can all be evaluated and
applied simultaneously to the resulting vector.
Independent set orderings have been used in the context of parallel direct solution techniques for
sparse matrices [95, 199, 200] and multifrontal techniques [107] can be viewed as a particular case. The
gist of all these techniques is that it is possible to reorder the system in groups of equations which can be
solved simultaneously. A parallel direct solution sparse solver based on performing several successive
levels of independent set orderings and reduction was suggested in [199] and in a more general form in
[94].

Chapter 13

MULTIGRID METHODS

The convergence of preconditioned Krylov subspace methods for solving linear systems arising
from discretized Partial Differential Equations tends to slow down considerably as these systems
become larger. This deterioration in the convergence rate, compounded with the increased
operation count per step due to the sheer problem size, results in a severe loss of efficiency. In
contrast, the class of methods to be described in this chapter are capable of achieving convergence
rates which are, in theory, independent of the mesh size. One significant difference with the
preconditioned Krylov subspace approach is that Multigrid methods have been initially designed
specifically for the solution of discretized elliptic Partial Differential Equations. The method
was later extended in different ways to handle other PDE problems, including nonlinear ones,
as well as problems not modeled by PDEs. Because these methods exploit more information on
the problem than do standard preconditioned Krylov subspace methods, their performance can
be vastly superior. On the other hand, they may require implementations that are specific to
the physical problem at hand, in contrast with preconditioned Krylov subspace methods which
attempt to be ‘general-purpose’.

13.1

Introduction

Multigrid techniques exploit discretizations with different mesh sizes of a given problem to obtain optimal convergence from relaxation techniques. At the foundation of
these techniques is the basic and powerful principle of divide and conquer. Though
most relaxation-type iterative processes, such as Gauss-Seidel, may converge slowly
for typical problems, it can be noticed that the components of the errors (or residuals) in the directions of the eigenvectors of the iteration matrix corresponding to
the large eigenvalues are damped very rapidly. These eigenvectors are known as the
oscillatory modes or high-frequency modes. The other components, associated with
low-frequency or smooth modes, are difficult to damp with standard relaxation. This
causes the observed slow down of all basic iterative methods. However, many of
these modes (say half) are mapped naturally into high-frequency modes on a coarser
mesh. Hence the idea of moving to a coarser mesh to eliminate the corresponding
error components. The process can obviously be repeated with the help of recursion,
using a hierarchy of meshes.
423

CHAPTER 13. MULTIGRID METHODS

424

The methods described in this chapter will differ in one essential way from those
seen so far. They will require to take a special look at the original physical problem
and in particular at the modes associated with different meshes. The availability of
a hierarchy of meshes and the corresponding linear problems opens up possibilities
which were not available with the methods seen so far which have only access to
the coefficient matrix and the right-hand side. There are, however, generalizations of
multigrid methods, termed Algebraic Multigrid (AMG), which attempt to reproduce
the outstanding performance enjoyed by multigrid in the regularly structured elliptic case. This is done by extending in a purely algebraic manner the fundamental
principles just described to general sparse linear systems.
This chapter will begin with a description of the model problems and the spectra
of the associated matrices. This is required for understanding the motivation and
theory behind multigrid.

13.2

Matrices and spectra of model problems

Consider first the one-dimensional model problem seen in Chapter 2:
−u′′ (x) = f (x) for x ∈ (0, 1)

u(0) = u(1) = 0 .

(13.1)
(13.2)

The interval [0,1] is discretized with centered difference approximations, using the
equally spaced n + 2 points
xi = i × h, i = 0, . . . , n + 1 ,
where h = 1/(n+1). A common notation is to call the original (continuous) domain
Ω and its discrete version Ωh . So Ω = (0, 1) and Ωh = {xi }i=0,...,n+1. The
discretization results in the system
Ax = b

(13.3)

where


2
 −1

A=



−1
2 −1
..
..
.
.
−1

..

.
2
−1





;

−1 
2




f (x0 )
 f (x1 ) 


..
2
.
b=h 
.

 f (x

n−2 )
f (xn−1 )

(13.4)

The above system is of size n × n.
Next, the eigenvalues and eigenvectors of the matrix A will be determined. The
following trigonometric relation will be useful:
sin((j + 1)θ) + sin((j − 1)θ) = 2 sin(jθ) cos θ .

(13.5)

13.2. MATRICES AND SPECTRA OF MODEL PROBLEMS

425

Consider the vector u whose components are sin θ, sin 2θ, · · · , sin nθ. Using the
relation (13.5) we find that
(A − 2(1 − cos θ)I)u = sin ((n + 1)θ) en
where en is the n-th column of the identity. The right-hand side in the above relation
is equal to zero for the following values of θ:
θk =

kπ
,
n+1

(13.6)

For any integer value k. Therefore, the eigenvalues of A are
λk = 2(1 − cos θk ) = 4 sin2

θk
2

k = 1, . . . , n,

and the associated eigenvectors are given by:


sin θk
 sin(2θk ) 
.
wk = 
..


.

(13.7)

(13.8)

sin(nθk )

The i-th component of wk can be rewritten in the form
sin

ikπ
= sin(kπxi )
n+1

and represents the value of the function sin(kπx) at the discretization point xi . This
component of the eigenvector may therefore be written
wk (xi ) = sin(kπxi ) .

(13.9)

Note that these eigenfunctions satisfy the boundary conditions wk (x0 ) = wk (xn+1 ) =
0. These eigenfunctions are illustrated in Figure 13.1 for the case n = 7.
Now consider the 2-D Poisson equation
 2

∂ u ∂2u
−
+ 2
= f in Ω
(13.10)
∂x2
∂y
u = 0 on Γ
(13.11)
where Ω is the rectangle (0, l1 ) × (0, l2 ) and Γ its boundary. Both intervals can be
discretized uniformly by taking n + 2 points in the x direction and m + 2 points in
the y directions:
xi = i × h1 , i = 0, . . . , n + 1 ;
where

yj = j × h2 , j = 0, . . . , m + 1

l2
l1
; h2 =
.
n+1
m+1
For simplicity we now assume that h1 = h2 .
h1 =

CHAPTER 13. MULTIGRID METHODS

426

0 1 2 3 4 5 6 7 8

0 1 2 3 4 5 6 7 8

0 1 2 3 4 5 6 7 8

0 1 2 3 4 5 6 7 8

0 1 2 3 4 5 6 7 8

0 1 2 3 4 5 6 7 8

0 1 2 3 4 5 6 7 8

Figure 13.1: The seven eigenfunctions of the discretized one-dimensional Laplacean
when n = 7.

13.2. MATRICES AND SPECTRA OF MODEL PROBLEMS

427

In this case the linear system has the form (13.3) where A has the form




B −I
4 −1
 −I B −I

 −1 4 −1





..
..
..
..
..
..



.
A=
.
.
.
.
.
.
 with B = 



−I B −I 
−1 4 −1 
−I B
−1 4

The right-hand side is again the discrete version of the function f scaled by h2 .
The above matrix can be represented in a succinct way using tensor product notation.
Given an m × p matrix X and an n × q matrix Y , the matrix
X ⊗Y
can be viewed as a block matrix which has in (block) location (i, j) the matrix xij Y .
In other words, X ⊗Y is of size (nm)×(pq) and is obtained by expanding each entry
xij of X into the block xij Y . This definition is also valid for vectors by considering
them as matrices (p = q = 1).
With this notation, the matrix A given above, can be written as
A = I ⊗ Tx + Ty ⊗ I,

(13.12)

in which Tx abd Ty are tridiagonal matrices of the same form as the matrix A in
(13.4) and of dimension n and m respectively. Often, the right-hand side of (13.12)
is called the tensor sum of Tx and Ty and is denoted by Tx ⊕ Ty . A few simple
properties are easy to show (see Exercise 1) for tensor products and tensor sums.
One that is important for determining the spectrum of A is
(Tx ⊕ Ty )(v ⊗ w) = v ⊗ (Tx w) + (Ty v) ⊗ w .

(13.13)

In particular if wk is an eigenvector of Tx associated with σk and vl is an eigenvector
of Tl associated with µl , it is clear that
(Tx ⊕ Ty )(vl ⊗ wk ) = vl ⊗ (Tx wk ) + (Ty vk ) ⊗ wk = (σk + µl ) vl ⊗ wk .
So, λkl = σk + µl is an eigenvalue of A for each pair of eigenvalues σk ∈ Λ(Tx )
and µk ∈ Λ(Ty ). The associated eigenvector is vl ⊗ wk . These eigenvalues and
associated eigenvectors are best labeled with two indices:




lπ
kπ
+ 2 1 − cos
λkl = 2 1 − cos
n+1
m+1


lπ
kπ
2
2
+ sin
.
(13.14)
= 4 sin
2(n + 1)
2(m + 1)
Their associated eigenvectors zk,l are
zk,l = vl ⊗ wk

CHAPTER 13. MULTIGRID METHODS

428

and they are best expressed by their values at the points (xi , yj ) on the grid:
zk,l (xi , yj ) = sin(kπxi ) sin(lπyj ) .
When all the sums σk + µl are distinct this gives all the eigenvalues and eigenvectors of A. Otherwise, we must show that the multiple eigenvalues correspond to
independent eigenvectors. In fact it can be shown that the system
{vl ⊗ wk }k=1,...,n; l=1...,m
is an orthonormal system if both the system of the vl ’s and the wk ’s are orthonormal.

13.2.1

Richardson’s iteration

Multigrid can be easily motivated by taking an in-depth look at simple iterative
schemes such as the Richardson iteration and Jacobi’s method. Note that these two
methods are essentially identical for the model problems under consideration, because the diagonal of the matrix is a multiple of the identity matrix. Richardson’s
iteration is considered here for the one-dimensional case, using a fixed parameter ω.
In the next section, the weighted Jacobi iteration is fully analyzed with an emphasis
on studying the effect of varying the parameter ω.
Richardson’s iteration takes the form:
uj+1 = uj + ω(b − Auj ) = (I − ωA)uj + ωb .
Thus, the iteration matrix is
Mω = I − ωA .

(13.15)

Recall from Example 4.1 from Chapter 4, that convergence takes place for 0 < ω <
2/ρ(A). In realistic situations, the optimal ω given by (4.33) is difficult to use.
Instead, an upper bound ρ(A) ≤ γ is often available from, e.g., Gershgorin’s theorem, and we can simply take ω = 1/γ. This yields a converging iteration since
1/γ ≤ 1/ρ(A) < 2/ρ(A).
By the relation (13.15), the eigenvalues of the iteration matrix are 1−ωλk , where
λk is given by (13.7). The eigenvectors are the same as those of A. If u∗ is the exact
solution, it was seen in Chapter 4 that the error vector dj ≡ u∗ − uj , obeys the
relation,
dj = Mωj d0 .
(13.16)
It is useful to expand the error vector d0 in the eigenbasis of Mω , as
d0 =

n
X

ξk wk .

k=1

From (13.16) and (13.15) this implies that at step j,

n 
X
λk j
ξk wk .
1−
dj =
γ
k=1

13.2. MATRICES AND SPECTRA OF MODEL PROBLEMS

429

Each component is reduced by (1 − λk /γ)j . The slowest converging component
corresponds to the smallest eigenvalue λ1 , which could yield a very slow convergence
rate when |λ1 /γ| ≪ 1.
For the model problem seen above, in the one-dimensional case, Gershgorin’s
theorem yields γ = 4 and the corresponding reduction coefficient is
1 − sin2

π
≈ 1 − (πh/2)2 = 1 − O(h2 ) .
2(n + 1)

As a result, convergence can be quite slow for fine meshes, i.e., when h is small.
However, the basic observation on which multigrid methods are founded is that convergence is not similar for all components. Half of the error components see actually
a very good decrease. This is the case for the high frequency components, that is,
all those components corresponding to k > n/2. This part of the error is often referred to as the oscillatory part, for obvious reasons. The reduction factors for these
components are
ηk = 1 − sin2

kπ
1
kπ
= cos2
≤ .
2(n + 1)
2(n + 1)
2

θ1

θn/2+1

1
η1
1/2

ηn
θn

Figure 13.2: Reduction coefficients for Richardson’s method applied to the 1-D
model problem
These coefficients are illustrated in Figure 13.2. Two important observations can
be made. The first is that the oscillatory components, i.e., those corresponding to
θn/2+1 , . . . , θn , undergo excellent reduction, better than 1/2, at each step of the
iteration. It is also important to note that this factor is independent of the step-size
h. The next observation will give a hint as to what might be done to reduce the other
components. In order to see this we now introduce, for the first time, a coarse grid
problem. Assume that n is odd and consider the problem issued from discretizing
the original PDE (13.1) on a mesh Ω2h with the mesh-size 2h. The superscripts h

CHAPTER 13. MULTIGRID METHODS

430

and 2h will now be used to distinguish between quantities related to each grid. The
grid points on the coarser mesh are x2h
i = i ∗ (2h). The second observation is based
h from which it follows that, for k ≤ n/2,
on the simple fact that x2h
=
x
i
2i
2h 2h
wkh (xh2i ) = sin(kπxh2i ) = sin(kπx2h
i ) = wk (xi ) .

In other words, taking a smooth mode on the fine grid (wkh with k ≤ n/2) and
canonically injecting it into the coarse grid, i.e., defining its values on the coarse
points to be the same as those on the fine points, yields the k-th mode on the coarse
grid. This is illustrated in Figure 13.3 for k = 2 and grids of 9 points (n = 7) and 5
points (n = 3).
Some of the modes which were smooth on the fine grid, become oscillatory. For
h
example, when n is odd, the mode w(n+1)/2
becomes precisely the highest mode on
Ω2h . At the same time the oscillatory modes on the fine mesh are no longer represented on the coarse mesh. The iteration fails to make progress on the fine grid
when the only components left are those associated with the smooth modes. Multigrid strategies do not attempt to eliminate these components on the fine grid. Instead,
they first move down to a coarser grid where smooth modes are translated into oscillatory ones. Practically, this requires going back and forth between different grids.
The necessary grid-transfer operations will be discussed in detail later.

Fine mesh

0

1

2

3

4

5

6

7

8

Coarse mesh

0

1

2

3

4

Figure 13.3: The mode w2 on a fine grid (n = 7) and a coarse grid (n = 3).

13.2. MATRICES AND SPECTRA OF MODEL PROBLEMS

13.2.2

431

Weighted Jacobi iteration

In this section a weighted Jacobi iteration is considered and analyzed for both 1-D
and 2-D model problems. The standard Jacobi iteration is of the form
uj+1 = D −1 (E + F )uj + D −1 f .
The weighted version of this iteration uses a parameter ω and combines the above
iterate with the current uj :

uj+1 = ω D −1 (E + F )uj + D −1 f + (1 − ω)uj


= (1 − ω)I + ωD −1 (E + F ) uj + ωD −1 f
(13.17)
≡ Jω uj + fω .

(13.18)

Using the relation E + F = D − A it follows that
Jω = I − ωD −1 A .

(13.19)

In particular note that when A is SPD, the weighted Jacobi iteration will converge
when 0 < ω < 2/ρ(D −1 A). In the case of our 1-D model problem the diagonal is
D = 2I, so the following expression for Jω is obtained,
Jω = (1 − ω)I +

ω
ω
(2I − A) = I − A.
2
2

(13.20)

For the 2-D case, a similar result can be obtained in which the denominator 2 is
replaced by 4. The eigenvalues of the iteration matrix follow immediately from the
expression (13.7),




kπ
kπ
2
= 1 − 2ω sin
.
(13.21)
µk (ω) = 1 − ω 1 − cos
n+1
2(n + 1)
In the 2-D case, these become,

µk,l (ω) = 1 − ω sin2

lπ
kπ
+ sin2
2(n + 1)
2(m + 1)



.

Consider the 1-D case first. The sine terms sin2 (kπ/2(n + 1)) lie in between
1−s2 and s2 , in which s = sin(π/2(n+1)). Therefore, the eigenvalues are bounded
as follows:
(1 − 2ω) + 2ωs2 ≤ µk (ω) ≤ 1 − 2ωs2 .
(13.22)
The spectral radius of Jω is
ρ(Jω ) = max{|(1 − 2ω) + 2ωs2 |, |1 − 2ωs2 |} .
When ω is < 0 or > 1, it can be shown that ρ(Jω ) > 1 for h small enough (See
Problem 1). When ω is between 0 and 1, then the spectral radius is simply 1−2ωs2 ≈
1 − ωπ 2 h2 /2.

CHAPTER 13. MULTIGRID METHODS

432

It is interesting to note that the best ω in the interval [0, 1] is ω = 1, so no
acceleration of the original Jacobi iteration can be achieved. On the other hand, if
the weighted Jacobi iteration is regarded as a smoother, the situation is different. For
those modes associated with k > n/2, the term sin2 θk is ≥ 1/2 so
1
1 − 2ω < (1 − 2ω) + 2ωs2 ≤ µk (ω) ≤ 1 − ω .
2

(13.23)

For example when ω = 1/2, then all reduction coefficients for the oscillatory modes
will be in between 0 and 3/4, thus guaranteeing again a reduction of h. For ω = 2/3
the eigenvalues are between -1/3 and 1/3, leading to a smoothing factor of 1/3. This
is the best that can achieved independently of h.
For 2-D problems, the situation is qualitatively the same. The bound (13.22)
becomes,
(1 − 2ω) + ω(s2x + s2y ) ≤ µk,l (ω) ≤ 1 − ω(s2x + s2y )
(13.24)
in which sx is the same as s and sy = sin(π/(2(m + 1))). The conclusion for the
spectral radius and rate of convergence of the iteration is similar, in that ρ(Jω ) ≈
1 − O(h2 ) and the best ω is one. In addition, the high-frequency modes are damped
with coefficients which satisfy:
1
1 − 2ω < (1 − 2ω) + ω(s2x + s2y ) ≤ µk,l (ω) ≤ 1 − ω .
2

(13.25)

As before, ω = 1/2 yields a smoothing factor of 3/4, and ω = 3/5 yields, a smoothing factor of 4/5. Here the best that can be done, is to take ω = 4/5.

13.2.3

Gauss-Seidel iteration

In pratice, Gauss-Seidel and red-black Gauss-Seidel relaxation are more common
smoothers than Jacobi or Richardson’s iterations. Also, SOR (with ω 6= 1) is rarely
used as it is known that overrelaxation adds no benefit in general. Gauss-Seidel and
SOR schemes are somewhat more difficult to analyze.
Consider the iteration matrix
G = (D − E)−1 F

(13.26)

in the one-dimensional case. The eigenvalues and eigenvectors of G satisfy the relation
[F − λ(D − E)]u = 0
the j-th row of which is
ξj+1 − 2λξj + λξj−1 = 0,

(13.27)

where ξj is the j-component of the vector u. The boundary conditions ξ0 = ξn+1 =
0, should be added to the above equations. Note that because ξn+1 = 0, equation
(13.27) is valid when j = n (despite the fact that entry (n, n+1) of F is not defined).

13.2. MATRICES AND SPECTRA OF MODEL PROBLEMS

433

This is a difference equation, similar to Equation (2.21) encountered in Chapter 2
and and it can be solved similarly by seeking a general solution in the form ξj = r j .
Substituting in (13.27), r must satisfy the quadratic equation
r 2 − 2λr + λ = 0,
whose roots are
r1 = λ +

p

λ2 − λ,

r2 = λ −

p

λ2 − λ .

This leads to the general solution ξj = αr1j + βr2j . The first boundary condition
ξ0 = 0, implies that β = −α. The boundary condition ξn+1 = 0 yields the equation
in λ
!n+1
√
n+1 
n+1

p
p
2 − λ)2
(λ
+
λ
− λ − λ2 − λ
=0 →
= 1,
λ + λ2 − λ
λ
in which it is assumed that λ 6= 0. With the change of variables λ ≡ cos2 θ, this
becomes (cos θ ± i sin θ)2(n+1) = 1, where the sign ± is positive when cos θ and
sin θ are of the same sign and negative otherwise. Hence,
±2(n + 1)θ = ±2k π

→

θ = θk ≡

kπ
, k = 1, . . . , n
n+1

(13.28)

Therefore the eigenvalues are of the form λk = cos2 θk , where θk was defined above,
i.e.,
kπ
λk = cos2
.
n+1
In fact this result could have been obtained in a simpler way. According to Theorem
4.16 seen in Chapter 4, when ω = 1, the eigenvalues of SOR iteration matrix are the
squares of those of the corresponding Jacobi iteration matrix with the same ω, which
according to (13.21) (left side) are µk = cos[kπ/(n + 1)].
Some care must be exercised when computing the eigenvectors. The j-th component of the eigenvector is given by ξj = r1j − r2j . Proceeding as before, we have

j
p
r1j = cos2 θk + cos4 θk − cos2 θk = (cos θk )j (cos θk ± i sin θk )j ,

where the ± sign was defined before. Similarly, r2j = (cos θk )j (cos θk ∓ i sin θk )j
where ∓ is the opposite sign from ±. Therefore,
i
h
ξj = (cos θk )j (cos θk ∓ i sin θk )j − (cos θk ± i sin θk )j = 2i (cos θk )j [± sin(jθk )] .

CHAPTER 13. MULTIGRID METHODS

434

k=1

k=2

0 1 2 3 4 5 6 7 8 9 10 11 12 0 1 2 3 4 5 6 7 8 9 10 11 12

k=3

k=4

0 1 2 3 4 5 6 7 8 9 10 11 12 0 1 2 3 4 5 6 7 8 9 10 11 12

k=5

k=7

0 1 2 3 4 5 6 7 8 9 10 11 12 0 1 2 3 4 5 6 7 8 9 10 11 12

k=9
k=8
0 1 2 3 4 5 6 7 8 9 10 11 12
0 1 2 3 4 5 6 7 8 9 10 11 12

k=10

k=11

0 1 2 3 4 5 6 7 8 9 10 11 12 0 1 2 3 4 5 6 7 8 9 10 11 12

Figure 13.4: The eigenfunctions of 13-point one-dimensional mesh (n = 11). The
case k = 6 is omitted.

13.2. MATRICES AND SPECTRA OF MODEL PROBLEMS

435

Since θk is defined by (13.28), sin θk is nonnegative, and therefore the ± sign
is simply the sign of cos θk . In addition the constant factor 2i can be deleted since
eigenvectors are defined up to a scalar constant. Therefore, we can set


uk = | cos θk |j sin(jθk ) j=1,...,n .
(13.29)

The above formula would yield an incorrect answer (a zero vector) for the situation
when λk = 0. This special case can be handled by going back to (13.27) which
yields the vector e1 as an eigenvector. In addition, it is left to show that indeed the
above set of vectors constitutes a basis. This is the subject of Exercise 2.
λk (G)
✻

✲k

0

1

2

3

4

5

6

7

8

9

10

11

12

Figure 13.5: Eigenvalues of the Gauss-Seidel iteration for a 13-point onedimensional mesh (n = 11).
The smallest eigenvalues are those for which k is close to n/2, as is illustrated
in Figure 13.5. Components in the directions of the corresponding eigenvectors, i.e.,
those associated with the eigenvalues of G in the middle of the spectrum, are damped
rapidly by the process. The others are harder to eliminate. This is in contrast with
the situation for the Jacobi iteration where the modes corresponding to the largest
eigenvalues are damped first.
Interestingly, the eigenvectors corresponding to the middle eigenvalues are not
the most oscillatory in the proper sense of the word. Specifically, a look at the eigenfunctions of G illustrated in Figure 13.4, reveals that the modes with high
oscillations are those corresponding to eigenvalues with the larger values of k,
and these are not damped rapidly. The figure shows the eigenfunctions of G, for a 13point discretization of the 1-D Laplacean. It omits the case k = 6, which corresponds
to the special case of a zero eigenvalue mentioned above.
The eigenvectors of the Gauss-Seidel iteration matrix are not related in a simple
way to those of the original matrix A. As it turns out, the low frequency eigenfunctions of the original matrix A are damped slowly while the high frequency modes are
damped rapidly, just as is the case for the Jacobi and Richardson iteration. This can
be readily verified experimentally, see Exercise 3

CHAPTER 13. MULTIGRID METHODS

436

13.3

Inter-grid operations

Multigrid algorithms require going back and forth between several grid problems
related to the solution of the same original equations. It is sufficient to present these
grid transfer operations for the simple case of two meshes, Ωh (fine) and ΩH (coarse),
and to only consider the situation when H = 2h. In particular, the problem size of
the fine mesh problem will be about 2d times as large as that of the coarse mesh
problem, where d is the space dimension. In the previous section, the 1-D case was
already considered and the subscript h corresponding to the mesh problem under
consideration was introduced.

13.3.1

Prolongation

A prolongation operation takes a vector from ΩH and defines the analogue vector in
Ωh . A common notation in use is:
h
IH
: ΩH −→ Ωh .

The simplest way to define a prolongation operator is through linear interpolation,
which is now presented for the 1-D case first. The generic situation is that of n + 2
points, x0 , x1 , . . . , xn+1 where x0 and xn+1 are boundary points. The number of
internal points n is assumed to be odd, so that halving the size of each subinterval
amounts to introducing the middle points. Given a vector (vi2h )i=0,...,(n+1)/2 , the
h v 2h of Ω is defined as follows
vector v h = I2h
h
(
h
v2j
= vj2h
n+1
.
for j = 0, . . . ,
h
2h
2h
v2j+1 = (vj + vj+1 )/2
2
In matrix form, the above defined prolongation can be written as


1

2



1 1




2




1 1
1
 2h
h
..
v = 
 v .
.

2


..


.



1 1



2
1

(13.30)

In 2-D, the linear interpolation can be defined in a straightforward manner from
the 1-D case. Thinking in terms of a matrix vij representing the coordinate of a
function v at the points xi , yj , it is possible to define the interpolation in 2-D in
h
denotes the interpolation in the x direction only
two stages. In the following Ix,2h

13.3. INTER-GRID OPERATIONS

437

h
the interpolation for y variables only. First, interpolate all values in the
and Iy,2h
x-direction only:
( h,x
2h
v2i,:
= vi,:
m+1
h
.
v h,x = Ix,2h
v where
for i = 0, . . . ,
h,x
2h
2h
2
v2i+1,: = (vi,: + vi+1,: )/2

Then interpolate this semi-interpolated result, with respect to the y variable:
(
x,2h
h
v:,2j
= v:,j
n+1
h,x
h
h
.
for j = 0, . . . ,
where
v = Iy,2h v
x,2h
x,2h
h
2
v:,2j+1 = (v:,j + v:,j+1 )/2
This gives the following formulas for the 2-D interpolation of an element v H in ΩH ,
h in Ωh ,
into the corresponding element v h = IH

h
2h

v2i,2j
= vij



 vh
2h + v 2h )/2
= (vij
i = 0, . . . , n+1
2i+1,2j
i+1,j
2 ; .
for
h
2h
2h
m+1
v
=
(v
+
v
)/2
j
=
0,
.
.
.
,

2i,2j+1
ij
i,j+1

2

2h + v 2h
2h
2h
 vh
=
(v
+
v
+
v
)/4
2i+1,2j+1
ij
i+1,j
i,j+1
i+1,j+1
From the above derivation, it is useful to observe that the 2-D interpolation can be
expressed as the tensor product of the two one-dimensional interpolations, i.e.,
h
h
h
.
⊗ Ix,2h
= Iy,2h
I2h

(13.31)

This is the subject of Exercise 4.
It is common to represent the prolongation operators using a variation of the
stencil notation employed in Chapter 4 and Chapter 10. The stencil now operates on
a grid to give values on a different grid. The one-dimensional stencil is denoted by


1
1
1
.
p=
2
2
The open brackets notation only means that the stencil must be interpreted as a fanout rather than fan-in operation as in the cases we have seen in earlier chapters. In
other words it is a column instead of a row operation, as can also be understood by a
look at the matrix in (13.30). Each stencil is associated with a coarse grid point. The
result of the stencil operation are the values viH /2, viH , viH /2, contributed to the three
fine mesh-points xh2i−1 , xh2i , and xh2i+1 by the value viH . Another, possibly clearer,
interpretation is that the function with value one at the coarse grid point x2h
i , and zero
elsewhere, will be interpolated to a function in the fine mesh which has the values
0.5, 1, 0.5 at the points xh2i−1 , xh2i , xh2i+1 , respectively, and zero elsewhere. Under
this interpretation, the stencil for the 2-D linear interpolation is


1 2 1
1
2 4 2.
4
1 2 1

It is also interesting to note that the 2-D stencil can be viewed as a tensor product of
the one dimensional stencil p and its transpose pT . The stencil pT acts on the vertical
coordinates in exactly the same way that p acts on the horizontal coordinates.

CHAPTER 13. MULTIGRID METHODS

438

Example 13.1. This example illustrates the use of the tensor product notation to
determine the 2-D stencil. The stencil can also be understood in terms of the action
of the interpolation operation on a unit vector. Using the stencil notation, this unit
vector is of the form ei ⊗ ej and we have (see Exercise 1)
h
h
h
h
h
I2h
(ei ⊗ ej ) = (Iy,2h
⊗ Ix,2h
)(ei ⊗ ej ) = (Iy,2h
ei ) ⊗ (Ix,2h
ej ) .

When written in coordinate (or matrix) form this is a vector which corresponds to
the outer product ppT with pT ≡ [ 21 1 12 ], centered at the point with coordinate
xi , y j .

13.3.2

Restriction

The restriction operation is the reverse of prolongation. Given a function v h on the
fine mesh, a corresponding function in ΩH must be defined from v h . In the earlier
analysis one such operation was encountered. It was simply based on defining the
function v 2h from the function v h as follows
h
vi2h = v2i
.

(13.32)

Because this is simply a canonical injection from Ωh to Ω2h , it is termed the injection
2h = v h
operator. This injection has an obvious 2-D analogue: vi,j
2i,2j .
A more common restriction operator, called full weighting (FW), defines v 2h as
follows in the 1-D case:

1 h
h
h
.
(13.33)
v2j−1 + 2v2j
+ v2j+1
vj2h =
4

This averages the neighboring values using the weights 0.25, 0.5, 0.25. An important
property can be seen by considering the matrix associated with this definition of Ih2h :


1 2 1


1 2 1

1
2h

 .
Ih = 
1
2
1
(13.34)

4

··· ··· ···
1 2 1
Apart from a scaling factor, this matrix is the transpose of the interpolation operator
seen earlier. Specifically,
h
I2h
= 2 (Ih2h )T .
(13.35)
The stencil for the above operator is
1
[1
4

2 1]

where the closed brackets are now used to indicate the standard fan-in (row) operation.

13.4. STANDARD MULTIGRID TECHNIQUES

439

In the 2-D case, the stencil for the full-weighting averaging is given by


1 2 1
1 
2 4 2.
16
1 2 1

This takes for uh2i,2j the result of a weighted average of the 9 points uH
i+q,j+p with
|p|, |q| ≤ 1 with the associated weights 2−|p|−|q|−2 . Note that because the Full
Weighting stencil is a scaled row (fan-in) version of the linear interpolation stencil, the matrix associated with the operator Ih2h is essentially a transpose of the
prolongation (interpolation) operator:
h
= 4(Ih2h )T .
I2h

(13.36)

The statements (13.35) and (13.36), can be summarized by
h
= 2d (IhH )T
IH

(13.37)

where d is the space dimension.
The following relation can be shown
2h
2h
⊗ Ix,h
Ih2h = Iy,h

(13.38)

which is analogous to (13.31) (see Exercise 5).

13.4

Standard multigrid techniques

One of the most natural ways to exploit a hierarchy of grids when solving PDEs, is to
obtain an initial guess from interpolating a solution computed on a coarser grid. The
process can be recursively repeated until a given grid is reached. This interpolation
from a coarser grid can be followed by a few steps of a smoothing iteration. This
is known as nested iteration. General multigrid cycles are intrinsically recursive
processes which use essentially two main ingredients. The first is a hierarchy of
grid problems along with restrictions and prolongations to move between grids. The
second is a smoother, i.e., any scheme which has the smoothing property of damping
quickly the high frequency components of the error. A few such schemes, such as
the Richardson and weighted Jacobi iterations, have been seen in earlier sections.
Other smoothers which are often used in practice are the Gauss-Seidel and RedBlack Gauss-Seidel iterations seen in Chapter 4.

13.4.1

Coarse problems and smoothers

At the highest level (finest grid) a mesh-size of h is used and the resulting problem
to solve is of the form:
Ah uh = f h .
One of the requirements of multigrid techniques is that a system similar to the one
above must be solved at the coarser levels. It is natural to define this problem at the

CHAPTER 13. MULTIGRID METHODS

440

next level where a mesh of size, say, H, is used, as simply the system arising from
discretizing the same problem on the coarser mesh ΩH . In other cases, it may be
more useful to define the linear system by Galerkin projection, where the coarse
grid problem is defined by
h
AH = IhH Ah IH
,

f H = IhH f h .

(13.39)

This formulation is more common in finite element methods. It also has some advantages from a theoretical point of view.
Example 13.2. Consider the model problem in 1-D, and the situation when AH
is defined from the Galerkin projection, i.e., via, formula (13.39), where the prolongation and restriction operators are related by (13.35) (1-D) or (13.36) (2-D). In
1-D, AH can be easily defined for the model problem when full-weighting is used.
Indeed,
AH eH
j

h H
e
= IhH Ah IH
 j

1 h
1 h
H
h
= Ih Ah e2j−1 + e2j + e2j+1
2
2


1
1
h
h
h
H
= Ih − e2j−2 + e2j − e2j+2
2
2
H
H
H
= −ej−1 + 2ej − ej+1 .

This defines the j-th column of AH , which has a 2 in the diagonal, -1 in the super
and sub-diagonal and zero elsewhere. This means that the operator AH defined by
the Galerkin property is identical with the operator that would be defined from a
coarse discretization. This property is not true in 2-D when full weighting is used.
see Exercise 6.
The notation
uhν = smoothν (Ah , uh0 , fh )
means that uhν is the result of ν smoothing steps for solving the above system, starting
with the initial guess uh0 . Smoothing iterations are of the form
uhj+1 = Sh uhj + g h

(13.40)

where Sh is the iteration matrix associated with one smoothing step. As was seen in
earlier chapters, the above iteration can always be rewritten in the ‘preconditioning’
form:
uhj+1 = uhj + Bh (f h − Ah uhj )
(13.41)
where
Sh ≡ I − Bh Ah ,

Bh ≡ (I − Sh )A−1
h

g h ≡ Bh f h .

(13.42)

13.4. STANDARD MULTIGRID TECHNIQUES

441

The error dhν and residual rνh resulting from ν smoothing steps satisfy
dhν = (Sh )ν dh0 = (I − Bh Ah )ν dh0 ;

rhν = (I − Ah Bh )ν r0h .

It will be useful later to make use of the following observation. When f h = 0 then
gh is also zero and as a result, one step of the iteration (13.40) will provide the result
of one product with the operator Sh .
Example 13.3. For example, setting f ≡ 0 in (13.17), yields the Jacobi iteration
matrix,
B = (I − D −1 (E + F ))A−1 = D −1 (D − E − F )A−1 = D −1 .
In a similar way one finds that for the Gauss-Seidel iteration, B = (D − E)−1 F and
for Richardson iteration B = ωI.
Nested iteration was mentioned earlier as a means of obtaining good initial
guesses from coarser meshes in a recursive way. The algorithm, presented here to illustrate the notation just introduced is described below. The assumption is that there
are p + 1 grids, with mesh sizes h, 2h, . . . , 2p n ≡ h0 .
A LGORITHM 13.1 Nested Iteration

1.
2.
3.
4.
5.
6.

Set h := h0 . Given an initial guess uh0 , set uh = smoothνp (Ah , uh0 , f h )
For l = p − 1, . . . , 0 Do
h/2
uh/2 = Ih uh
h := h/2;
uh := smoothνl (Ah , uh , f h )
End

In practice, nested iteration is not much used in this form. However, it provides
the foundation for one of the most effective multigrid algorithms, namely the Full
Multi-Grid (FMG) which will be described in a later section.

13.4.2

Two-grid cycles

When a smoother is applied to a linear system at a fine level, the residual
r h = f h − Auh
obtained at the end of the smoothing step will typically still be large. However, it
will have small components in the space associated with the high-frequency modes.
If these components are removed by solving the above system (exactly) at the lower
level, then a better approximation should result. Two-grid methods are rarely practical because the coarse-mesh problem may still be too large to be solved exactly.
However, they are useful from a theoretical point of view. In the following algorithm
H = 2h.

CHAPTER 13. MULTIGRID METHODS

442

A LGORITHM 13.2 Two-Grid cycle

1.
2.
3.
4.
5.
6.

Pre-smooth:
Get residual:
Coarsen:
Solve:
Correct:
Post-smooth:

uh := smoothν1 (Ah , uh0 , f h )
r h = f h − Ah uh
r H = IhH r h
AH δH = r H
h δH
uh := uh + IH
h
u := smoothν2 (Ah , uh , f h )

It is clear that the result of one iteration of the above algorithm corresponds to
some iteration process of the form
uhnew = Mh uh0 + gMh .
In order to determine the operator Mh we exploit the observation made above that
taking f h = 0 provides the product Mh uh0 . When f h = 0, then in line 1 of the
algorithm, uh becomes Shν1 uh0 . In line 3, we have r H = IhH (fh − Ah Shν1 ) =
IhH (−Ah Shν1 ). Following this process, the vector uh resulting from one cycle of
the algorithm becomes
h −1 H
AH Ih (−Ah Shν1 uh0 )].
uhnew = Shν2 [Shν1 uh0 + IH

Therefore, the 2-grid iteration operator is given by
h
h −1 H
AH Ih Ah ]Shν1 .
= Shν2 [I − IH
MH

The matrix inside the brackets,
h −1 H
ThH = I − IH
AH Ih Ah ,

(13.43)

acts as another iteration by itself known as the coarse grid correction, which can be
viewed as a particular case of the two-grid operator with no smoothing, i.e., with
ν1 = ν2 = 0. Note that the B preconditioning matrix associated with this iteration
h A−1 I H .
is, according to (13.42), Bh = IH
H h
An important property of the coarse grid correction operator is discussed in the
following lemma. It is assumed that Ah is symmetric positive definite.
Lemma 13.1 When the coarse grid matrix is defined via (13.39), then the coarse
grid correction operator (13.43) is a projector which is orthogonal with respect to
the Ah -inner product. In addition, the range of ThH is Ah -orthogonal to the range of
IhH .
h A−1 I H A is a projector:
Proof. It suffices to show that I − ThH = IH
h
H h
h −1 H
h
h −1
h −1 H
h −1 H
AH Ih Ah .
) A−1 I H A = IH
AH (IhH Ah IH
AH Ih Ah ) = IH
(IH
AH Ih Ah )×(IH
| {z } H h h
AH

13.4. STANDARD MULTIGRID TECHNIQUES

443

h A−1 I H A is an A-orthogonal projector follows from its self-adjointness
That IH
h
H h
with respect to the Ah -inner product (see Chapter 1):
h −1 H
h −1 H
AH Ih Ah y) = (x, ThH y)Ah .
(ThH x, y)Ah = (Ah IH
AH Ih Ah x, y) = (x, Ah IH

Finally, the statement that Ran(ThH ) is orthogonal to Ran(IhH ) is equivalent to stating that for all x of the form x = ThH y, we have IhH Ah x = 0 which is readily
verified.

13.4.3

V-cycles and W-cycles

Anyone familiar with recursivity will immediately think of the following practical
version of the 2-grid iteration: apply the 2-grid cycle recursively until a coarse
enough level is reached and then solve exactly (typically using a direct solver). This
gives the algorithm described below, called the V-cycle multigrid. In the algorithm,
H stands for 2h and h0 for the coarsest mesh-size.
A LGORITHM 13.3 uh = V-cycle(Ah , uh0 , f h )

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

Pre-smooth: uh := smoothν1 (Ah , uh0 , f h )
Get residual: r h = f h − Ah uh
Coarsen:
r H = IhH r h
If (H == h0 )
Solve:
AH δH = r H
Else
Recursion:
δH = V-cycle(AH , 0, r H )
EndIf
h δH
uh := uh + IH
Correct:
Post-smooth: uh := smoothν2 (Ah , uh , f h )
Return uh

Consider the cost of one cycle, i.e., one iteration of the above algorithm. A few
simple assumptions are needed along with new notation. The number of nonzero
elements of Ah is denoted by nnzh . It is assumed that nnzh ≤ αnh , where α does
not depend on h. The cost of each smoothing step is equal to nnzh while the cost of
the transfer operations (interpolation and restriction) is of the form βnh where again
β does not depend on h. The cost at the level where the grid size is h, is given by
C(nh ) = (α(ν1 + ν2 ) + 2β)nh + C(n2h ) .
Noting that n2h = nh /2 in the one-dimensional case, This gives the recurrence
relation
C(n) = ηn + C(n/2)
(13.44)
in which η = (α(ν1 + ν2 ) + 2β). The solution of this recurrence relations yields
C(n) ≤ 2ηn. For 2-dimensional problems, nh = 4n2h and in this case the cost
becomes ≤ 7/3ηn.

CHAPTER 13. MULTIGRID METHODS

444

We now introduce the general multigrid cycle which generalizes the V-cycle seen
above. Once more, the implementation of the multigrid cycle is of a recursive nature.
A LGORITHM 13.4 uh = MG (Ah , uh0 , f h , ν1 , ν2 , γ)

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

Pre-smooth: uh := smoothν1 (Ah , uh0 , f h )
Get residual: r h = f h − Ah uh
Coarsen:
r H = IhH r h
If (H == h0 )
Solve:
AH δH = r H
Else
Recursion:
δH = MGγ (AH , 0, r H , ν1 , ν2 , γ)
EndIf
h δH
Correct:
uh := uh + IH
h
Post-smooth: u := smoothν2 (Ah , uh , f h )
Return uh

Notice now that there is a new parameter, γ, which determines how many times MG
is iterated in Line 7. Each of the MG iterations in Line 7 takes the form
H
δnew
= M G(AH , δH , rH , ν1 , ν2 , γ)

(13.45)

and this is iterated γ times. The initial guess for the iteration is δH = 0 the second
argument to the MG call in line 7 shows. The case γ = 1 yields the V-cycle multigrid.
The case γ = 2 is known as the W-cycle multigrid. The resulting inter-grid up and
down moves can be complex as is illustrated by the diagrams in Figure 13.6. The
case γ = 3 is rarely used.
Now consider the cost of the general multigrid cycle. The only significant difference with the V-cycle algorithm is that the recursive call to MG is iterated γ times
instead of only once for the V-cycle. Therefore, the cost formula (13.44) becomes
C(n) = ηn + γC(n/2),

(2-D case) .
(13.46)
It can easily be shown that the cost of each loop is still linear when γ < 2 in 1-D and
γ < 4 in the 2-D case, see Exercise 12. In other cases, the cost per cycle increases to
O(n log2 n).
(1-D case)

C(n) = ηn + γC(n/4),

Example 13.4. This example illustrates the convergence behavior of the V-cycle
multigrid for solving a model Poisson problem with Dirichlet boundary conditions
in two-dimensional space. The problem considered is of the form :
−∆u = 13 sin(2πx) × sin(3πy)

(13.47)

and has the exact solution u(x, y) = sin(2πx) × sin(3πy). The Poisson equation is
set on a square grid and discretized using nx = ny = 33 points, including the two

13.4. STANDARD MULTIGRID TECHNIQUES
lev=1,γ=1

lev=1,γ=2

lev=2,γ=1

lev=3,γ=1

lev=2,γ=2

445
lev=4,γ=1

lev=3,γ=2

lev=3,γ=3

Figure 13.6: Representations of Various V-cycles and W-cycles
boundary points in each direction. This leads to a linear system of dimension N =
312 = 961. The V-cycle multigrid was tested with three smoothers: (1) The weighted
Jacobi relaxation with ω = 2/3; (2) Gauss-Seidel relaxation, and (3) the red-black
Gauss-Seidel relaxation. Various values of ν1 and ν2 , the number of pre- and postsmoothing steps, respectively, were used. Table 13.1 shows the convergence factors
ρ as estimated from the expression,


1
krk k2
log
,
ρ = exp
k
kr0 k2
for each of the smoothers. Here k is the total number of smoothing steps taken.
The convergence was stopped as soon as the 2-norm of the residual was reduced by
a factor of tol = 10−8 . The overall winner is clearly the Red-Black Gauss Seidel
smoother. It is remarkable that even with a number of total smoothing steps ν1 + ν2
as small as two, a reduction factor of less than 0.1 is achieved with RB-GS. Also,
it is worth pointing out that when ν1 + ν2 is constant, the red-black Gauss-Seidel
smoother tends to perform better when ν1 and ν2 are more or less balanced (compare
the case (ν1 , ν2 ) = (0, 2) versus (ν1 , ν2 ) = (1, 1) for example). In the asymptotic
regime (or very large k), the two ratios should be identical in theory.

CHAPTER 13. MULTIGRID METHODS

446
(ν1 , ν2 )

smoother

ρ

(ν1 , ν2 )

smoother

ρ

(0,1)
(0,1)
(0,1)

w-Jac
GS
RB-GS

0.570674
0.308054
0.170635

(1,1)
(1,1)
(1,1)

w-Jac
GS
RB-GS

0.387701
0.148234
0.087510

(0,2)
(0,2)
(0,2)

w-Jac
GS
RB-GS

0.358478
0.138477
0.122895

(1,2)
(1,2)
(1,2)

w-Jac
GS
RB-GS

0.240107
0.107802
0.069331

(0,3)
(0,3)
(0,3)

w-Jac
GS
RB-GS

0.213354
0.105081
0.095490

(1,3)
(1,3)
(1,3)

w-Jac
GS
RB-GS

0.155938
0.083473
0.055480

Table 13.1: Tests with V-cycle multigrid for a model Poisson equation using three
smoothers and various number of pre-smoothing steps (ν1 ), and post-smoothing steps
(ν2 ).
It is important to determine the iteration operator corresponding to the application of one Multigrid loop. We start with the 2-grid operator seen earlier, which
is
h
h −1 H
MH
= Shν2 [I − IH
AH Ih Ah ]Shν1 .
The only difference between this operator and the sought MG operator is that the
inverse of AH is replaced by an application of γ steps of MG on the grid ΩH . Each
of these steps is of the form (13.45). However, the above formula uses the inverse of
AH , so it is necessary to replace AH by the corresponding B-form (preconditioned
form) of the MG operator, which, according to (13.42) is given by
(I − MH )A−1
H .
Therefore,
ν1
H
h
Mh = Shν2 [I − IH
(I − MH )A−1
H Ih Ah ]Sh

ν1
H
h
h −1 H
MH A−1
= Shν2 [I − IH
AH Ih Ah + IH
H Ih Ah ]Sh
ν1
H
h
h
= MH
+ Shν2 IH
MH A−1
H Ih Ah Sh

showing that the MG operator Mh can be viewed as a perturbation of the 2-grid
operator MhH .

13.4. STANDARD MULTIGRID TECHNIQUES

447

lev=3,γ=1

lev=2,γ=1

lev=3,γ=2
Figure 13.7: Representation of various FMG cycles (with µ = 1). The doubled lines
correspond to the FMG interpolation.

13.4.4

Full Multigrid

The Full Multigrid (FMG), sometimes also referred to as nested iteration, takes a
slightly different approach from the MG algorithms seen in the previous section.
FMG can be viewed as an improvement of nested iteration seen earlier whereby the
smoothing step in Line 5 is replaced by an MG cycle. The difference in viewpoint is
that it seeks to find an approximation to the solution with only one sweep through the
levels, going from bottom to top. The error of the resulting approximation is guaranteed, under certain conditions, to be of the order of the discretization. In practice, no
more accuracy than this should ever be required. The algorithm is described below.
A LGORITHM 13.5 Full Multigrid

1.
2.
3.
4.
5.
6.

Set h := h0 . Solve Ah uh = f h
For l = 1, . . . , p, Do
h/2
uh/2 = Iˆh uh
h := h/2;
uh := M Gµ (Ah , uh , f h , ν1 , ν2 , γ)
End

Notice that the interpolation operator in Line 2 is denoted with a hat. This is in order
to distinguish it from the interpolation operator used in the MG loop, which is sometimes different, typically of a lower order. The tasks and transfer operations of FMG
are illustrated in Figure 13.7. The MG iteration requires the standard parameters
nu1 , ν2 , gamma, in addition to the other choices of smoothers and interpolation operators.
In the following uh represents the exact (discrete) solution of the problem on grid
Ωh and ũh will be the approximation resulting from the FMG cycle on the grid Ωh .

CHAPTER 13. MULTIGRID METHODS

448

Thus, ũh is the result of Line 5 in Algorithm 13.5. One of the main assumptions made
in analyzing FMG is that the exact solution of the discrete linear system Ah uh = f h
is close, within the discretization accuracy, to the exact solution of the PDE problem:
ku − uh k ≤ chκ .

(13.48)

The left-hand side represents the norm of the difference between the exact solution
uh of the discrete problem and the solution of the continuous problem sampled at the
grid points of Ωh . Any norm on Ωh can be used, and the choice of the norm will
reexamined shortly. Using an argument based on the triangle inequality, a particular
h uH should also be close since
consequence of the above assumption is that uh and IˆH
they are close to the same (continuous) function u. Specifically, the assumption
(13.48) is replaced by:
h H
kuh − IˆH
u k ≤ c1 hκ .
(13.49)

A bound of this type can be shown by making a more direct assumption on the
interpolation operator, see Exercise 13. The next important assumption to make is
that the MG iteration operator is uniformly bounded,
kMh k ≤ ξ<1 .

(13.50)

h must also be bounded, a condition which is convenient
Finally, the interpolation IˆH
to state as follows,
h
kIˆH
k ≤ c2 2−κ .
(13.51)

Theorem 13.2 Assume that (13.49), (13.50), and (13.51) are satisfied, and that µ is
sufficiently large that
c2 ξ µ < 1 .
(13.52)
Then the FMG iteration produces approximations ũh , which at each level satisfy,
kuh − ũh k ≤ c3 c1 hκ

(13.53)

c3 = ξ µ /(1 − c2 ξ µ ) .

(13.54)

with

Proof. The proof is by induction. At the lowest level, equation (13.53) is clearly
satisfied because the solution ũh is exact at the coarsest level and so the error is
zero. Consider now the problem associated with the mesh size h and assume that the
theorem is valid for the mesh size H. The error vector is given by
uh − ũh = (Mh )µ (uh − uh0 ).

(13.55)

h ũH . Therefore,
The initial guess is defined by uh0 = IˆH
h H
h
kuh − uh0 k = kuh − IˆH
u + IˆH
(uH − ũH )k
≤ kuh − Iˆh uH k + kIˆh (uH − ũH )k
H

H

h
≤ c1 h + kIˆH
kc1 c3 H κ
κ

κ

−κ

≤ h (c1 + 2
κ

κ

c2 H c1 c3 )

≤ h c1 (1 + c2 c3 ) .

(by (13.49) and induction hypothesis
(by (13.51))

13.4. STANDARD MULTIGRID TECHNIQUES

449

Combining the above with (13.55) and (13.50) yields
kuh − ũh k ≤ ξ µ hκ c1 (1 + c2 c3 ) .
From the relation (13.54), we get ξ µ = c3 /(1+c2 c3 ) and this shows the result (13.53)
for the next level and completes the induction proof.
In practice it is accepted that taking µ = 1 is generally sufficient to satisfy the ash k ≤ 1, and κ = 1, then c = 4. In this
sumptions of the theorem. For example, if kIˆH
2
case, with µ = 1, the result of the theorem will be valid provided ξ < 0.25, which is
easily achieved by a simple V-cycle using Gauss-Seidel smoothers.
Example 13.5. This example illustrates the behavior of the full multigrid cycle
when solving the same model Poisson problem as in Example 13.4. As before, the
Poisson equation is set on a square grid and discretized with centered differences.
The problem is solved using the mesh sizes nx = ny = 9, 17, 33, 65, and 129 points
(including the two boundary points) in each direction. Thus, for example, the last
problem leads to a linear system of dimension N = 1272 = 16, 129.
Figure 13.8 shows in log scale the 2-norm of the actual error achieved for three
FMG schemes as a function of log(nx − 1). It also shows the 2-norm of the discretization error. Note that when nx = 9, all methods show the same error as the
discretization error because the system is solved exactly at the coarsest level, i.e.,
when nx = 9. The first FMG scheme uses a weighted Jacobi iteration with the
weight ω = 2/3, and (ν1 , ν2 ) = (1, 0). As can be seen the error achieved becomes
too large relative to the discretization error when the number of levels increases. On
the other hand, the other two schemes, RB-GS with (ν1 , ν2 ) = (4, 0) and GS with
(ν1 , ν2 ) = (2, 0) perform well. It is remarkable that the error achieved by RB-GS is
actually slightly smaller than the discretization error itself.
The result of the above theorem is valid in any norm. However, it is important to
note that the type of bound obtained will depend on the norm used.
Example 13.6. It is useful to illustrate the basic discretization error bound (13.48)
for the 1-D model problem. As before, we abuse the notation slightly by denoting by
u the vector in Ωh whose values at the grid points are the values of the (continuous)
solution u of the differential equation (13.1–13.2). Now the discrete L2 -norm on
Ωh , denoted by kvkh will be used. In this
√particular case, this norm is also equal to
h1/2 kvk2 , the Euclidean norm scaled by h. Then we note that,
kuh − ukh = k(Ah )−1 Ah (uh − u)kh = k(Ah )−1 [f h − Ah u]kh
≤ k(Ah )−1 kh kf h − Ah ukh .

(13.56)

Assuming that the continuous u is in C 4 , (four times differentiable with continuous
fourth derivative), Equation (2.12) from Chapter 2 gives
(f − Ah u)i = fi + u′′ (xi ) +

h2 (4)
h2 (4)
u (ξi ) =
u (ξi )
12
12

CHAPTER 13. MULTIGRID METHODS

450

Discretization & FMG errors vs mesh−size nx

0

10

−1

Error Norm

10

−2

10

−3

10

Discr. error norm
FMG error, w−Jac(1,0)
FMG error, GS(2,0)
FMG error, RB−GS(4,0)

−4

10

3

3.5

4

4.5

5

5.5

log (n −1)
2

6

6.5

7

x

Figure 13.8: FMG error norms with various smoothers versus the discretization
error as a function of the mesh size.
where ξi is in the interval (xi −h, xi +h). Since u ∈ C 4 (Ω), we have |u(4) (ξi )| ≤ K
where K is the maximum of u(4) over Ω, and therefore,


k u(4) (ξi )
kh ≤ h1/2 k (K)i=1,...,n k2 ≤ K .
i=1,...,n

This provides the bound kf h − Ah ukh ≤ Kh2 /12 for the second term in (13.56).
The norm k(Ah )−1 kh in (13.56) can be computed by noting that
k(Ah )−1 kh = k(Ah )−1 k2 = 1/λmin (Ah ) .
According to (13.7),
λmin (Ah ) =

2
4
2
2 sin (πh/2)
sin
(πh/2)
=
π
.
h2
(πh/2)2

It can be shown that when, for example, x < 1, then 1 ≥ sin(x)/x ≥ 1 − x2 /6.
Therefore, when πh < 2, we have
1
1

≤ k(Ah )−1 kh ≤
2  .
2
π
π 2 1 − 1 πh
6

2

13.5. ANALYSIS FOR THE TWO-GRID CYCLE

451

Putting these results together yields the inequality:
kuh − ukh ≤

K

12π 2 1 − 16


πh 2
2

 h2 .

Exercise 16 considers an extension of this argument to 2-D problems. Exercise 17
explores what happens if other norms are used.

13.5

Analysis for the two-grid cycle

The two-grid correction cycle is at the basis of most of the more complex multigrid
cycles. For example, it was seen that the general MG cycle can be viewed as a
perturbation of a 2-Grid correction cycle. Similarly, practical FMG schemes use a
V-cycle iteration for their inner loop. This section will take a in-depth look at the
convergence of the 2-grid cycle, for the case when the coarse grid problem is defined
by the Galerkin approximation (13.39). This case is important in particular because
it is at the basis of all the algebraic multigrid techniques which will be covered in the
next section.

13.5.1

Two important subspaces

Consider the two-grid correction operator ThH defined by (13.43). As was seen in
Section 13.4.2, see Lemma 13.1, this is an Ah -orthogonal projector onto the subspace
Ωh . It is of the form I − Qh where
h −1 H
AH Ih Ah .
Q h = IH

Clearly, Qh is also an Ah -orthogonal projector (since I − Qh is, see Chapter 1), and
we have
Ωh = Ran(Qh ) ⊕ Null(Qh ) ≡ Ran(Qh ) ⊕ Ran(I − Qh ) .

(13.57)

The definition of Qh implies that
h
Ran(Qh ) ⊂ Ran(IH
).

As it turns out, the inclusion also holds in the other direction, which means that the
h , so
two subspaces are the same. To show this, take a vector z in the range of IH
h y for a certain y ∈ Ω . Remembering that A = I H A I h , we obtain
z = IH
H
h
h H
h
h
h
h −1 H
y = IH
y=z,
Q h z = IH
AH Ih Ah IH

which shows that z belongs to Ran(Qh ). Hence,
h
Ran(Qh ) = Ran(IH
).

CHAPTER 13. MULTIGRID METHODS

452

h ), while
This says that Qh is the Ah - orthogonal projector onto the space Ran(IH
ThH is the Ah - orthogonal projector onto the orthogonal complement. This orthogonal complement, which is the range of I − Qh , is also the null space of Qh according to the fundamental relation (1.58) of Chapter 1. Finally, the null space of
Qh is identical with the null space of the restriction operator IhH . It is clear that
Null(IhH ) ⊂ Null(Qh ). The reverse inclusion is not as clear and may be derived
from the fundamental relation (1.18) seen in Chapter 1. This relation implies that




h T
h
h T
.
)
Ωh = Ran(IH
) ⊕ Null (IH
) = Ran(Qh ) ⊕ Null (IH

h )T = Null(I H ). Comparing this with the decomHowever, by (13.37), Null (IH
h
position (13.57), it follows that

Null(Qh ) = Null(IhH ) .
In summary, if we set
Sh ≡ Ran(Qh ) ,

Th ≡ Ran(ThH )

(13.58)

then the following relations can be stated:
Ωh = Sh ⊕ Th

(13.59)

Th =

(13.61)

Sh =

h
Ran(Qh ) = Null(Th ) = Ran(IH
)
H
Null(Qh ) = Ran(Th ) = Null(Ih ) .

(13.60)

These two subspaces are fundamental when analyzing MG methods. Intuitively,
it can be guessed that the null space of ThH is somewhat close to the space of smooth
modes. This is because it is constructed so that its desired action on a smooth component is to annihilate it. On the other hand it should leave an oscillatory component
more or less unchanged. If s is a smooth mode and t an oscillatory one, then this
translates into the rough statements,
ThH s ≈ 0,

ThH t ≈ t .

Clearly, opposite relations are true with Qh , namely Qh t ≈ 0 and Qh s ≈ s.
Example 13.7. Consider the case when the prolongation operator IhH corresponds
to the case of full weighting in the one-dimensional case. Consider the effect of this
operator on any eigenmode wkh , which has components sin(jθk ) for j = 1, . . . , n.
where θk = kπ/(n + 1). Then, according to (13.33)
(IhH wkh )j

1
[sin((2j − 1)θk ) + 2 sin(2jθk ) + sin((2j + 1)θk )]
4
1
=
[2 sin(2jθk ) cos θk + 2 sin(2jθk )]
4
1
(1 + cos θk ) sin(2jθk )
=
2  
θk
= cos2
sin(2jθk ) .
2
=

13.5. ANALYSIS FOR THE TWO-GRID CYCLE

453

Consider a mode wk where k is large, i.e., close to n. Then, θk ≈ π. In this case, the
restriction operator will transform this mode into a constant times the same mode on
the coarser grid. The multiplicative constant, which is cos2 (θk /2), is close to zero
in this situation, indicating that IhH wk ≈ 0, i.e., that wk is near the null space of
IhH . Oscillatory modes are close to being in the null space of IhH , or equivalently the
range of ThH .
When k is small, i.e., for smooth modes, the constant cos2 (θk /2) is close to
one. In this situation the interpolation produces the equivalent smooth mode in ΩH
without damping it.

13.5.2

Convergence analysis

When analyzing convergence for the Galerkin case, the Ah norm is often used. In
addition, 2-norms weighted by D 1/2 , or D −1/2 , where D is the diagonal of A, are
convenient. For example, we will use the notation,
kxkD = (Dx, x)1/2 ≡ kD 1/2 xk2 .
The following norm also plays a significant role,
kekAh D−1 Ah = (D −1 Ah e, Ah e)1/2 ≡ kAh ekD−1 .
To avoid burdening the notation unnecessarily we simply use kAh ekD−1 to denote
this particular norm of e. It can be shown that standard 2-grid cycles satisfy an
inequality of the form,
kSh eh k2Ah ≤ keh k2Ah − αkAeh k2D−1

∀ eh ∈ Ωh

(13.62)

independently of h. This is referred to as the smoothing property.
In addition to the above requirement which characterizes the smoother, another
assumption will be made which characterizes the discretization. This assumption is
referred to as the approximation property, and can be stated as follows:
h H 2
min keh − IH
e kD ≤ βkeh k2Ah ,

uH ∈ΩH

(13.63)

where β does not depent on h. In the following theorem, it is assumed that A is SPD,
and that the restriction and prolongation operators are linked by a relation of the form
h being of full rank.
(13.37), with IH
Theorem 13.3 Assume that inequalities (13.62) and (13.63) are satisfied for a certain smoother, where α > 0 and β > 0. Then α ≤ β, the two-level iteration
converges, and the norm of its operator is bounded as follows:
r
α
(13.64)
kSh ThH kAh ≤ 1 − .
β

CHAPTER 13. MULTIGRID METHODS

454

Proof. It was seen in the previous section that Ran(ThH ) = Th is Ah -orthogonal to
h ) = S . As a result, (eh , I h eH )
h
H
Ran(IH
Ah = 0 for any e ∈ Ran(Th ), and so,
h
H
h H
keh k2Ah = (Ah eh , eh − IH
e ) ∀ eh ∈ Ran(ThH ).

For any eh ∈ Ran(ThH ), the cauchy-schwarz inequality gives
h H
keh k2Ah = (D −1/2 Ah eh , D 1/2 (eh − IH
e ))

h H
≤ kD −1/2 Ah eh k2 kD 1/2 (eh − IH
e )k2

h H
e kD .
= kAh eh kD−1 keh − IH
√
By (13.63), this implies that keh kAh ≤ βkAh eh kD−1 for any eh ∈ Ran(THh ), or
equivalently, kThH eh k2Ah ≤ βkAh THh eh k2D−1 for any eh in Ωh . The proof is completed by exploiting the smoothing property, i.e., inequality (13.62),

0 ≤ kSh ThH eh k2Ah

≤ kThH eh k2Ah − αkAh ThH eh k2D−1
α
≤ kThH eh k2Ah − kThH eh k2Ah
β


α
kThH eh k2Ah
=
1−
β


α
≤
1−
keh k2Ah .
β

The fact that ThH is an Ah -orthogonal projector was used to show the last step.
Example 13.8. As an example, we will explore the smoothing property (13.62) in
the case of the weighted Jacobi iteration. The index h is now dropped for clarity.
From (13.19) the smoothing operator in this case is
S(ω) ≡ I − ωD −1 A .
When A is SPD, then the weighted Jacobi iteration will converge for 0 < ω <
2/ρ(D −1 A). For any vector e we have
kS(ω)ek2A = (A(I − ωD −1 A)e, (I − ωD −1 Ae))

= (Ae, e) − 2ω(AD −1 Ae, e) + ω 2 (AD −1 Ae, D −1 Ae)


1
1
1
1
1
1
= (Ae, e) − 2ω(D − 2 Ae, D − 2 Ae) + ω 2 (D − 2 AD − 2 )D − 2 Ae, D − 2 Ae
i

h
1
1
1
1
= (Ae, e) − ω(2I − ωD − 2 AD − 2 ) D − 2 Ae, D − 2 Ae
i
h
1
1
(13.65)
≤ kek2A − λmin ω(2I − ωD − 2 AD − 2 ) kAek2D−1 .
1

1

Let γ = ρ(D − 2 AD − 2 ) = ρ(D −1 A). Then the above restriction on ω implies
that 2 − ωγ > 0, and the matrix in the brackets in (13.65) is positive definite with
minimum eigenvalue ω(2 − ωγ). Then, it suffices to take
α = ω(2 − ωγ)

13.6. ALGEBRAIC MULTIGRID

455

to satisfy the requirement (13.62). Note that (13.62) is also valid with α replaced
by any positive number that does not exceed the above value, but inequality which
would result would be less sharp. Exercise 15 explores the same question when
Richardson’s iteration is used instead of weighted Jacobi.

13.6

Algebraic Multigrid

Throughout the previous sections of this chapter, it was seen that multigrid methods
depend in a fundamental way on the availability of an underlying mesh. In addition to this, the performance of multigrid deteriorates for problems with anisotropic
coefficients or discontinuous coefficients. It is also difficult to define multigrid on
domains that are not rectangular, especially in three dimensions. Given the success
of these techniques, it is clear that it is important to consider alternatives which use
similar principles which do not face the same disadvantages. Algebraic multigrid
methods have been defined to fill this gap. The main strategy used in AMG is to
exploit the Galerkin approach, see Equation (13.39), in which the interpolation and
prolongation operators are defined in an algebraic way, i.e., only from the knowledge
of the matrix.
In this section the matrix A is assumed to be positive definite. Since meshes
are no longer available, the notation must be changed, or interpreted differently, to
reflect levels rather than grid sizes. Here h is no longer a mesh-size but an index to
a certain level, and H is used to index a coarser level. The mesh Ωh is now replaced
by a subspace Xh of Rn at a certain level and XH denotes the subspace of the coarse
problem. Since there are no meshes, one might wonder how the coarse problems can
be defined.
In AMG, the coarse problem is typically defined using the Galerkin approach,
which we restate here:
h
AH = IhH Ah IH
,

f H = IhH f h

(13.66)

h the prolongation operator, both defined
where IhH the restriction operator, and IH
algebraically. The prolongation and restriction operators are now related by transposition:
h T
IhH = (IH
) .
(13.67)

A minimum assumption made on the prolongation operator is that it is of full rank.
It can therefore be said that only two ingredients are required to generalize the
multigrid framework:
1. A way to define the ‘coarse’ subspace XH from a fine subspace Xh ;
2. A way to define the interpolation operator IhH from Xh to XH .
In other words, all that is required is a scheme for coarsening a fine space along with
an interpolation operator which would map a coarse node into a fine one.

CHAPTER 13. MULTIGRID METHODS

456

In order to understand the motivations for the choices made in AMG when defining the above two components, it is necessary to extend the notion of smooth and
oscillatory modes. This is examined in the next section.
Note that Lemma 13.1 is valid and it implies that ThH is a projector, which is
orthogonal when the Ah inner product is used. The corresponding relations (13.59
– 13.61) also hold. Therefore, Theorem 13.3 is also valid and this is a fundamental
tool used in the analysis of AMG.

13.6.1

Smoothness in AMG

By analogy with multigrid, an error is decomposed into smooth and oscillatory components. However, these concepts are now defined with respect to the ability or inability of the smoother to reduce these modes. Specifically, an error is smooth when
its convergence with respect to the smoother is slow. The common way to state this
is to say that, for a smooth error s,
kSh skA ≈ kskA .
Note the use of the energy norm which simplifies the analysis. If the smoother satisfies the smoothing property (13.62), then this means that for a smooth error s, we
would have
kAskD−1 ≪ kskAh .
Expanding the norms and using the Cauchy-Schwarz inequality gives
ksk2Ah

= (D −1/2 Ah s, D 1/2 s)
≤ kD −1/2 Ah sk2 kD 1/2 sk2

= kAh skD−1 kskD .

Since kAskD−1 ≪ kskAh this means that kskAh ≪ kskD , or
(As, s) ≪ (Ds, s) .

(13.68)

It simplifies the analysis to set v = D 1/2 s. Then,
1

1

(D − 2 AD − 2 v, v) ≪ (v, v) .
1

1

The matrix Â ≡ D − 2 AD − 2 is a scaled version of A in which the diagonal entries
are transformed into ones. The above requirement states that the Rayleigh quotient
of D 1/2 s is small. This is in good agreement with standard multigrid since, a small
Rayleigh quotient implies that the vector v is a linear combination of the eigenvectors
of A with smallest eigenvalues. In particular, (As, s) ≈ 0 also implies that As ≈ 0,
i.e.,
X
aii si ≈ −
aij sj .
(13.69)
j6=i

13.6. ALGEBRAIC MULTIGRID

457

It is also interesting to see how to interpret smoothness in terms of the matrix coefficients. A common argument held in AMG methods exploits the following expansion
of (As, s):
X
aij si sj
(As, s) =
i,j


1X
−aij (sj − si )2 − s2i − s2j
2
i,j


X X
1X

−aij (sj − si )2 +
aij  s2i .
2

=

=

i,j

i

j

The condition (13.68) can be rewritten as (As, s) = ǫ(Ds, s), in which 0 < ǫ ≪ 1.
For the special case when the row-sums of the matrix are zero, and the off-diagonal
elements are negative, then this gives,



2
X
X
X
X
1
|aij | si − sj
|aij |(sj −si )2 = ǫ
aii s2i →
aii s2i 
− 2ǫ = 0 .
2
aii
si
i,j

i

i

j6=i

A weighted sum, with nonnegative weights, of the bracketed terms must vanish. It
cannot be rigorously argued that the bracketed term must be of the order 2ǫ, but one
can say that on average this will be true, i.e.,
X |aij |  si − sj 2
≪1.
(13.70)
aii
si
j6=i

For the above relation to hold, |si − sj |/|si | must be small when |aji /aii | is large. In
other words, the components of s vary slowly in the direction of the strong connections. This observation is used in AMG when defining interpolation operators and
for coarsening.

13.6.2

Interpolation in AMG

The argument given at the end of the previous section is at the basis of many AMG
techniques. Consider a coarse node i and its adjacent nodes j, i.e., those indices
such that aij 6= 0. The argument following (13.70) makes it possible to distinguish
between weak couplings, |aij /aii | is smaller than a certain threshold σ, and strong
couplings, when it is larger. Therefore, there are three types of nodes among the
nearest neighbors of a fine node i. First there is a set of coarse nodes, denoted by Ci .
Then among the fine nodes we have a set Fis of nodes that are strongly connected
with i, and a set Fiw of nodes that are weakly connected with i. An illustration is
shown in Figure 13.9. The smaller filled circles represent the fine nodes, and the thin
dashed lines represent the weak connections. The thick dash-dot lines represent the
strong connections.

CHAPTER 13. MULTIGRID METHODS

458

According to the argument given above, a good criterion for finding an interpolation formula is to use the relation (13.69) which heuristically characterizes a smooth
error. This is because interpolation should average out, i.e., eliminate, highly oscillatory elements in Xh , and produce a function that is smooth in the coarser space.
Then we rewrite (13.69) as
X
X
X
aij sj .
(13.71)
aij sj −
aii si ≈ −
aij sj −
j ∈ Fiw

j ∈ Fis

j ∈ Ci

Consider eliminating the weak connections first. Instead of just removing them from
the picture, it is natural to lump their action and add the result into the diagonal term,
in a manner similar to the compensation strategy used in ILU. This gives,


X
X
X
aii +
aij sj .
(13.72)
aij  si ≈ −
aij sj −
j ∈ Fiw

j ∈ Fis

j ∈ Ci

F
C

F

C

F

C

C

F

Figure 13.9: Example of nodes adjacent to a fine node i (center). Fine mesh nodes
are labeled with F, coarse nodes with C.
The end result should be a formula in which the right-hand side depends only on
coarse points. Therefore, there remains to express each of the terms of the second
sum in the right-hand side of the above equation, in terms of values at coarse points.
Consider the term sj for j ∈ Fis . At node j, the following expression can be written
that is similar to (13.69)
X
X
X
ajl sl .
ajl sl −
ajj sj ≈ −
ajl sl −
l ∈ Cj

l ∈ Fjs

l ∈ Fjw

If the aim is to invoke only those nodes in Ci , then a rough approximation is to
remove all other nodes from the formula, so the first sum is replaced by a sum over

13.6. ALGEBRAIC MULTIGRID

459

all k ∈ Ci (in effect l will belong to Ci ∩ Cj ), and write
X
ajj sj ≈ −
ajl sl .
l ∈ Ci

However, this would not be a consistent formula in the sense that it would lead to incorrect approximations for constant functions. To remedy this, ajj should be changed
to the opposite of the sum of the coefficients ajl . This gives,


X
X
X
X ajl
−
sl ; with δj ≡
ajl .
ajl  sj ≈ −
ajl sl → sj ≈
δj
l ∈ Ci

l ∈ Ci

l ∈ Ci

l ∈ Ci

Substituting this into (13.72) yields,


X ajl
X
X
X
aii +
aij  si ≈ −
aij
sl .
aij sj −
δj
w
s
j ∈ Fi

j ∈ Ci

j ∈ Fi

(13.73)

l ∈ Ci

This is the desired formula since it expresses the new fine value si in terms of coarse
values sj and sl , for j, l in Ci . A little manipulation will help put it in a ‘matrix-form’
in which si is expressed as a combination of the sj ’s for j ∈ Ci :
P
a a
X
aij + k ∈ F s ikδk kj
i
P
si =
wij sj
with
wij ≡ −
.
(13.74)
aii + k ∈ F w aik
j ∈ Ci

i

Once the weights are determined, the resulting interpolation formula generalizes
the formulas seen for standard multigrid:

xi
if i ∈ XH
h
.
(IH x)i = P
w
x
j ∈ Ci ij j otherwise

Example 13.9. Consider the situation depicted in Figure 13.10 which can correspond to a 9-point discretization of some convection-diffusion equation on a regular
grid. The coarse and fine nodes can be obtained by a red-black coloring of the corresponding 5-point graph. For example black nodes can be the coarse nodes and red
nodes the fine nodes.

CHAPTER 13. MULTIGRID METHODS

460
NW

-3

-2

-4

W

-4

N
-3

20

-1

-4

-4

-3

E

-1

-3
SW

-2

-4

-3

NE

-4

-3
S

SE

Figure 13.10: Darker filled circles represent the fine nodes. Thick dash-dot lines
represent the strong connections. Values on edges are the aij ’s. The value 20 at the
center (fine) point is aii .
In this case, Equation (13.73) yields,


3sN + 4sE
3sN + 4sW
1
+2
4sS + 4sN + 3sW + 3sE + 2
si =
18
7
7






 
1
12
8
8
=
4sS + 4 +
sN + 3 +
sW + 3 +
sE .
18
7
7
7
Notice that, as is expected from an interpolation formula, the weights are all nonnegative and they add up to one.

13.6.3

Defining coarse spaces in AMG

Coarsening, i.e., the mechanism by which the coarse subspace XH is defined from
Xh can be achieved in several heuristic ways. One of the simplest methods, mentioned in the above example, uses the ideas of multicoloring, or independent set orderings seen in Chapter 3. These techniques do not utilize information about strong
and weak connections seen in the previous section. A detailed description of these
techniques is beyond the scope of this book. However some of the guiding principles
used to defined coarsening heuristics are formulated below.
• When defining the coarse problem, it is important to ensure that it will provide
a good representation of smooth functions. In addition, interpolation of smooth
functions should be accurate.
• The number of points is much smaller than on the finer problem.
• Ensure that strong couplings are not lost in coarsening. For example, if i is
strongly coupled with j then j must be either a C node or an F node that is
strongly coupled with a C-node.

13.6. ALGEBRAIC MULTIGRID

461

• The process should reach a balance between the size of XH and the accuracy
of the interpolation/ restriction functions.

13.6.4

AMG via Multilevel ILU

It was stated in the introduction of this section that the main ingredients needed for
defining an Algebraic Multigrid method are a coarsening scheme and an interpolation operator. A number of techniques have been recently developed which attempt
to use the framework of incomplete factorizations to define AMG preconditioners.
Let us consider coarsening first. Coarsening can be achieved by using variations of
independent set orderings which were covered in Chapter 3. Often the independent
set is called the fine set and the complement is the coarse set, though this naming is
now somewhat arbitrary.
Recall that independent set orderings transform the original linear system into a
system of the form
   

x
f
B F
=
(13.75)
E C
y
g
in which the B block is a diagonal matrix. A block LU factorization will help establish the link with AMG-type methods.

 


B F
I
0
B F
=
E C
EB −1 I
0 S

where S is the Schur complement,
S = C − EB −1 F .
The above factorization, using independent sets, was at the basis of the ILU factorization with Multi-elimination (ILUM) seen in Chapter 12. Since the Schur complement
matrix S is sparse and the above procedure can be repeated recursively for a few levels. Clearly, dropping is applied each time to prune the Schur complement S which
becomes denser as the number of levels increases. In this section we consider this
factorization again from the angle of AMG and will define block generalizations.

No Coupling

Figure 13.11: Group- (or Block-) -Independent sets.

462

CHAPTER 13. MULTIGRID METHODS

Figure 13.12: Group-independent set reorderings of a 9-point matrix: Left: Small
groups (fine-grain), Right: large groups (coarse-grain).
Factorizations that generalize the one shown above are now considered in which
B is not necessarily diagonal. Such generalizations use the concept of block or group
independent sets which generalize standard independent sets. A group-independent
set is a collection of subsets of unknowns such that there is no coupling between
unknowns of any two different groups. Unknowns within the same group may be
coupled. An illustration is shown in Figure 13.11.
If the unknowns are permuted such that those associated with the group-independent
set are listed first, followed by the other unknowns, the original coefficient system
will take the form (13.75) where now the matrix B is no longer diagonal but block
diagonal. An illustration of two such matrices is given in Figure 13.12. Consider
now an LU factorization (exact or incomplete) of B,
B = LU + R .
Then the matrix A can be factored as follows,
 



B F
L
0
I 0
U
≈
−1
E C
EU
I
0 S
0

L−1 F
I



.

(13.76)

The above factorization, which is of the form A = LDU , gives rise to an analogue of
a 2-grid cycle. Solving with the L matrix, would take a vector with components u, y
in the fine and coarse space, respectively to produce the vector yH = y − EU −1 u
in the coarse space. The Schur complement system can now be solved in some
unspecified manner. Once this is done, we need to back-solve with the U matrix.
This takes a vector from the coarse space and produces the u-variable from the fine
space, u := u − L−1 F y.
A LGORITHM 13.6 Two-level Block-Solve

13.6. ALGEBRAIC MULTIGRID
1.
2.
3.
4.
5.

463

f := L−1 f
g := g − EU −1 f1
Solve Sy = g
f := f − L−1 F y
x = U −1 f

The above solution steps are reminiscent of the two-grid cycle algorithm (Algorithm 13.2). The interpolation and restriction operations are replaced by those in
lines 2 and 4, respectively.
A few strategies have recently been developed based on this parallel between a
recursive ILU factorization and AMG. One such technique is the Algebraic Recursive Multilevel Solver [253]. In ARMS, the block factorization (13.76) is repeated
recursively on the Schur complement S which is kept sparse by dropping small elements. At the l-th level, we would write

 

 
 
Ll
0
Bl Fl
I
0
Ul L−1
l Fl
×
, (13.77)
≈
×
El Cl
0 Al+1
El Ul−1 I
0
I
where Ll Ul ≈ Bl , and Al+1 ≈ Cl − (El Ul−1 )(L−1
l Fl ).
In a nutshell the ARMS procedure consists of essentially three steps: first, obtain
a group-independent set and reorder the matrix in the form (13.75); second, obtain
an ILU factorization Bl ≈ Ll Ul for Bl ; third, obtain approximations to the matrices
−1
L−1
l Fl , El Ul , and Al+1 , and use these to compute an approximation to the Schur
complement Al+1 . The process is repeated recursively on the matrix Al+1 until a
selected number of levels is reached. At the last level, a simple ILUT factorization,
possibly with pivoting, or an approximate inverse method can be applied.
Each of the Ai ’s is sparse but will become denser as the number of levels increases, so small elements are dropped in the block factorization to maintain sparsity.
The matrices Gl ≡ El Ul−1 , and Wl ≡ L−1
l Fl are only computed in order to obtain
the Schur complement
Al+1 ≈ Cl − Gl Wl .
(13.78)
Once Al+1 is available, Wl and Gl are discarded to save storage. Subsequent opera−1
are performed using Ul , Ll and the blocks El and Fl . It
tions with L−1
l Fl and El Ul
is important to distinguish between possible variants. To conform with the Galerkin
approach, we may elect not to drop terms once Al+1 is obtained from (13.78). In this
case (13.78) is not an approximation but an exact equality.
There are also many possible variations in the solution phase which can be
viewed as a recursive version of Algorithm 13.6. Step 3 of the algorithm now reads
3.

Solve Al+1 yl = gl

which essentially means solve in some unspecified way. At the l-th level, this recursive solution step, which we call RSolve for reference, would be replaced by a
sequence of statements like

CHAPTER 13. MULTIGRID METHODS

464
3.0
3.1
3.2
3.3
3.4

If lev = last
Solve Al+1 yl = gl
Else
RSolve (Al+1 , gl )
End

Iterative processes can be used in step 3.3. The preconditioner for this iterative process can, for example, be defined using the next, (l + 2)-th level (without iterating at
each level). This is the simplest approach. It is also possible to use an iterative procedure at each level preconditioned (recursively) with the ARMS preconditioner below
that level. This variation leads to a procedure similar the MG-cycle, if the number
of steps γ is specificed. Finally, the local Bl block can be used to precondition the
system of the l-th level.

13.7

Multigrid vs Krylov methods

The main differences between preconditioned Krylov subspace methods and the
multigrid approach may now have become clearer to the reader. In broef, Krylov
methods take a matrix A and a right-hand side b and try to produce a solution, using
no other information. The term black box is often used for those methods which require minimal input from the user, a good example being that of sparse direct solvers.
Preconditioned Krylov subspace methods attempt to duplicate this attribute of direct
solvers, but they are not ‘black-box’ solvers since they require parameters and do not
always succeed in solving the problem.
The approach taken by Multigrid methods is to tackle the original problem, e.g.
the PDE, directly instead. By doing so, it is possible to exploit properties which are
not always readily available from the data A, b. For example, what makes multigrid
work in the Poisson equation case, is the strong relation between eigenfunctions of
the iteration matrix M and the mesh. It is this strong relation that makes it possible
to take advantage of coarser meshes and to exploit a divide-and-conquer principle
based on the spectral decomposition of M . AMG methods try to recover similar
relationships directly from A, but this is not always easy.
The answer to the question “which method to use?”, cannot be a simple one because it is related to two other important and subjective considerations. The first is
the cost of the coding effort. Whether or not one is willing to spend a substantial
amount of time coding and testing, is now a factor. The second is how important it is
to develop an “optimal” code for the problem at hand. If the goal is to solve a single
linear system then a direct solver (assuming enough memory is available) or a preconditioned Krylov solver (in case memory is an issue) may be best. Here, optimality
is a secondary consideration. On the other extreme, the best possible performance
may be required from the solver if it is meant to be part of a large simulation code
which may take, say, days on a high-performance computer to complete one run. In
this case, it may be worth the time and cost to build the best solver possible, because
this cost will be amortized over the lifetime of the simulation code. Here, multilevel techniques can constitute a significant part of the solution scheme. A wide grey

13.7. MULTIGRID VS KRYLOV METHODS

465

zone lies in between these two extremes wherein Krylov subspace methods are often
invoked.
It may be important to comment on another practical consideration, which is that
most industrial solvers are not monolithic schemes based on one single approach.
Rather, they are comprised of building blocks which include tools extracted from
various methodologies: direct sparse techniques, multilevel methods, ILU type preconditioners, as well as strategies that exploit the specificity of the problem. For
example, a solver could utilize the knowledge of the problem to reduce the system
by eliminating part of the unknowns, then invoke an AMG or multigrid scheme to
solve the resulting reduced system in cases when it is known to be Poisson-like and an
ILU-Krylov approach combined with some reordering schemes (from sparse direct
solvers) in other cases. Good iterative solvers must rely on a battery of techniques
if they are to be robust and efficient at the same time. To ensure robustness, industrial codes may include an option to resort to direct solvers for those, hopefully rare,
instances when the main iterative scheme fails.

P ROBLEMS
P-13.1 The following notation will be used. Given a vector z of size n.m denote by
Z = [z]n,m
the matrix of dimension n × m with entries Zij = z(j−1)∗n+i . When there is no ambiguity
the subscripts n, m are omitted. In other words n consecutive entries of z will form the
columns of Z. The opposite operation, which consists of stacking the consecutive columns
of a matrix Z into a vector z, is denoted by
z = Z| .
a. Let u ∈ Rm , v ∈ Rn . What is the matrix Z = [z]n,m when z = u ⊗ v?

b. Show that

(I ⊗ A)z = (A.[z])|
c. Show, more generally, that

and


(A ⊗ I)z = [z].AT |


(A ⊗ B)z = B.[z].AT |

d. What becomes of the above relation when z = u ⊗ v? Find an eigenvector of A ⊗ B
based on this.
e. Show that (A ⊗ B)T = (AT ⊗ B T ).
P-13.2 Establish that the eigenvectors of the Gauss-Seidel operator given by (13.29) are
indeed a set of n linearly independent vectors. (Hint: notice that the eigenvalues other than
for k = (n + 1)/2 are all double, it suffices to show that the two eigenvectors defined by
the formula are independent.) What happens if the absolute values are removed from the
expression (13.29)?

466

CHAPTER 13. MULTIGRID METHODS

P-13.3 Consider the Gauss-Seidel iteration as a smoother for the 1-D model problem, when
n = 11 (spectrum illustrated in Figure 13.4.) For each eigenvector ui of the original matrix
A, compute the norm reduction kGui k/kuik, where G is the Gauss-Seidel iteration matrix.
Plot these ratios against i, in a way that is similar to Figure 13.4. What can you conclude?
Repeat for the powers G2 , and G4 , and G8 . What can you conclude (see the statement made
at end of Section 13.2.3)?
P-13.4 Show relation (13.31). Consider as an example, a 7 × 5 grid and illustrate for this
h
h
case the semi-interpolation operators Ix,2h
and Iy,2h
. Then derive the relation by seeing how
the 2-D interpolation operator was defined in Section 13.3.1.
P-13.5 Show the relation (13.38). Consider first as an example, a 7 × 5 grid and illustrate
2h
2h
for this case the semi-restriction operators Ix,h
and Iy,h
. Then use (13.31) (see previous
exercise) and part (e) of Exercise 1.
h
P-13.6 What is the matrix IhH Ah IH
for the 2-D model problem when Full Weighting is
used? [Hint: Use the tensor product notation and the results of Exercises 5 and 4.]

P-13.7 Consider the matrix Jω given by (13.20). Show that it is possible to find ω > 1 such
that ρ(Jω ) > 1. Similar question for ω < 0.
P-13.8 Derive the full weighting formula by applying the trapezoidal rule to approximate
the numerator and denominator in the following approximation:
R x+h
u(t)dt
u(x) ≈ x−h
.
R x+h
x−h 1.dt
P-13.9 Derive the B-form (or preconditioning form, see (13.41)) of the weighted Jacobi
iteration.

P-13.10 Do the following experiment using an interactive package such as Matlab - (or
code in FORTRAN or C). Consider the linear system Ax = 0 where A arises from the
discretization of −u′′ on [0, 1] using 64 internal points. Take u0 to be the average of the two
modes un/4 = u16 and u3n/4 = u48 . Plot the initial error (Hint: the error is just u0 ), then the
error after 2 steps of the Richardson process, then the error after 5 steps of the Richardson
process. Plot also the components of the final error after the 5 Richardson steps, with respect
to the eigenbasis. Now obtain the residual on the grid Ω2h , and plot the residual obtained
after 2 and 5 Richardson steps on the coarse-grid problem. Show also the components of the
error in the eigenbasis of the original problem (on the fine mesh). Finally, interpolate to the
fine grid and repeat the process again, doing 2 and then 5 steps of the Richardson process.
P-13.11 Repeat Exercise 10 using the Gauss-Seidel iteration instead of the Richardson iteration.
P-13.12 Consider the cost of the general MG algorithm as given by the recurrence formula
(13.46). Solve the recurrence equation (in terms of η and γ) for the 1-D case. You may
assume that n = 2k + 1 and that the maximum number of levels are used so that the cost of
the last system to solve is zero. For the 2-D case, you may assume that n = m = 2k + 1.
Under which condition is the cost O(n log n) where n is the size of the finest grid under
consideration? What would be the situation for 3-D problems?
P-13.13 It was stated in Section 13.4.4 that condition (13.48) implies the condition (13.49)
h
provided an assumption is made on the interpolation IˆH
. Prove a rigorous bound of the type
(13.49) (i.e., find c1 ) by assuming the conditions (13.48) (13.51) and
h
ku − IˆH
uk ≤ c4 hκ

13.7. MULTIGRID VS KRYLOV METHODS

467

in which as before u represents the discretization of the the solution of the continuous problem (i.e., the continuous solution sampled at the grid points of Ωh or ΩH ).
P-13.14 Justify the definition of the norm kvkh in Example 13.6 by considering that the
integral
Z
1

v(t)2 dt

0

is approximated by the Trapezoidal rule. It is assumed that v(x0 ) = v(xn+1 ) = 0 and the
composite trapezoidal rule uses all points x0 , . . . , xn+1 .

P-13.15 Find the constant α in the smoothing property (13.62), for the case of Richardon’s
iteration when A is SPD. [Hint: Richardson’s iteration is like a Jacobi iteration where the
diagonal is replaced by the identity.]
P-13.16 Extend the argument of Example 13.6 to the 2-D case. Start with the case of
the square (0, 1)2 which uses the same discretization in each direction. Then consider the
more general situation. Define the norm kvkh from the discrete L2 norm (see also previous
exercise).
P-13.17 Establish a bound of the type shown in Example 13.6 using the 2-norm instead of
the discrete L2 norm. What if the Ah norm is used?
P-13.18 The energy norm can be used to establish a result similar to that of Theorem 13.2
leading to a slightly simpler argument. It is now assumed that (13.49) is satisfied with respect
to the Ah -norm, i.e., that
h H
kuh − IˆH
u k Ah ≤ c 1 h κ .
a. Show that for any vector v in ΩH we have
h
kIH
vkAh = kvkAH .

b. Let uh0 the initial guess at grid Ωh in FMG and assume that the error achieved by the
system at level H = 2h satisfies kuH − ũH kAH ≤ c1 c3 H κ , in which c3 is to be
determined. Follow the argument of the proof of Theorem (13.2) and use the relation
established in (a) to show that
h H
kuh − uh0 kAh ≤ kuh − IˆH
u kAh + kuH − ũH kAH ≤ c1 hκ + c1 c3 H κ .

c. Show a result analogous to that of Theorem 13.2 which uses the Ah -norm, i.e., find c3
such that kuh − ũh kAh ≤ c1 c3 hκ , on each grid.
P-13.19 Starting from the relation (13.73), establish (13.74).
N OTES AND R EFERENCES . The material presented in this chapter is based on several sources. Foremost among these are the references [65, 207, 163, 286, 301]. A highly recommended reference is the
“Multigrid tutorial, second edition” by Briggs, Van Hansen, and Mc Cormick [65], for its excellent
introduction to the subject. This tutorial includes enough theory to understand how multigrid methods work. More detailed volumes include the books by Mc Cormick et al. [207], Hackbusch [162],
Hackbusch [163], Wesseling [311], and the more recent book by Trottenberg and al. [286].
Early work on multigrid methods dates back to the 1960s and includes the papers by Brakhage [46],
Fedorenko [124, 125], Bakhvalov [23], and Kronsjö and Dahlquist [193]. However, Multigrid methods have seen much of their modern development in the 1970s and early 1980s, essentially under the
pioneering work of Brandt [54, 55, 56]. Brandt played a key role in promoting the use of MG by establishing their overwhelming superiority over existing techniques for elliptic PDEs and by introducing

468

CHAPTER 13. MULTIGRID METHODS

many new concepts which are now widely use in MG literature. Algebraic multigrid methods were
later developed to attempt to obtain similar performance. These methods were introduced in [58] and
analyzed in a number of papers, see e.g., [57, 235].
Closely related to the multigrid approach is the Aggregation-Disaggregation technique which is
popular in Markov chain modeling. A recommended book for these methods and others used in the
context of Markov chain modeling is [275].
Today MG methods are still among the most efficient techniques available for solving Elliptic
PDEs on regularly structured problems. Their Algebraic variants do not seem to have proven as effective and the search for the elusive “black-box” iterative solver is still under way, with research on
multilevel methods in general and AMG in particular still quite active. With computer power constantly improving, problems are becoming larger and more complex, and this makes mesh-independent
convergence look ever more attractive.
The paper [253] describes a scalar version of the Algebraic Recursive Multilevel Solver and the
report [203] describes a parallel implementation. The related method named MLILU described in [28]
also exploits the connection between ILU and AMG. The parallel version of ARMS (called pARMS)
is available from the author’s web site: www.cs.umn.edu/∼saad.
Resources for Multigrid are available in www.mgnet.org which provides bibliographical references, software, and a newsletter. In particular, Examples 13.4 and 13.5 have been run with the
MGLAB matlab codes (contributed by James Bordner and Faisal Saied) available from this site. A
parallel code named HYPRE which is available from the Lawrence Livermore National Lab, includes
implementations of AMG.

Chapter 14

DOMAIN DECOMPOSITION METHODS

As multiprocessing technology is steadily gaining ground, new classes of numerical methods
that can take better advantage of parallelism are emerging. Among these techniques, domain
decomposition methods are undoubtedly the best known and perhaps the most promising for
certain types of problems. These methods combine ideas from Partial Differential Equations,
linear algebra, mathematical analysis, and techniques from graph theory. This chapter is devoted
to “decomposition” methods, which are based on the general concepts of graph partitionings.

14.1

Introduction

Domain decomposition methods refer to a collection of techniques which revolve
around the principle of divide-and-conquer. Such methods have been primarily developed for solving Partial Differential Equations over regions in two or three dimensions. However, similar principles have been exploited in other contexts of science
and engineering. In fact, one of the earliest practical uses for domain decomposition
approaches was in structural engineering, a discipline which is not dominated by Partial Differential Equations. Although this chapter considers these techniques from a
purely linear algebra view-point, the basic concepts, as well as the terminology, are
introduced from a model Partial Differential Equation.
Consider the problem of solving the Laplace Equation on an L-shaped domain
Ω partitioned as shown in Figure 14.1. Domain decomposition or substructuring
methods attempt to solve the problem on the entire domain
Ω=

s
[

Ωi ,

i=1

from problem solutions on the subdomains Ωi . There are several reasons why such
techniques can be advantageous. In the case of the above picture, one obvious reason is that the subproblems are much simpler because of their rectangular geometry.
For example, fast Poisson solvers can be used on each subdomain in this case. A
second reason is that the physical problem can sometimes be split naturally into a
small number of subregions where the modeling equations are different (e.g., Euler’s
equations on one region and Navier-Stokes in another).
Substructuring can also be used to develop “out-of-core” solution techniques.
As already mentioned, such techniques were often used in the past to analyze very
469

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

470

Ω3
Γ13

Ω1

Γ12

Ω2

Figure 14.1: An L-shaped domain subdivided into three subdomains.
large mechanical structures. The original structure is partitioned into s pieces, each
of which is small enough to fit into memory. Then a form of block-Gaussian elimination is used to solve the global linear system from a sequence of solutions using
s subsystems. More recent interest in domain decomposition techniques has been
motivated by parallel processing.

14.1.1

Notation

In order to review the issues and techniques in use and to introduce some notation,
assume that the following problem is to be solved:
∆u = f in Ω
u = uΓ on Γ = ∂Ω.
Domain decomposition methods are all implicitly or explicitly based on different
ways of handling the unknown at the interfaces. From the PDE point of view, if the
value of the solution is known at the interfaces between the different regions, these
values could be used in Dirichlet-type boundary conditions and we will obtain s
uncoupled Poisson equations. We can then solve these equations to obtain the value
of the solution at the interior points. If the whole domain is discretized by either
finite elements or finite difference techniques, then this is easily translated into the
resulting linear system.
Now some terminology and notation will be introduced for use throughout this
chapter. Assume that the problem associated with domain shown in Figure 14.1 is
discretized with centered differences. We can label the nodes by subdomain as shown

14.1. INTRODUCTION

471

in Figure 14.3. Note that the interface nodes are labeled last. As a result, the matrix
associated with this problem will have the structure shown in Figure 14.4.
For a general partitioning into s subdomains, the linear system associated with
the problem has the following structure:

   
f1
B1
E1
x1

B2
E2   x2   f2 

 .   . 
.. 
..

 .   . 
(14.1)
.
. 

 .  =  . 






Bs Es
xs
fs
F1 F2 · · · Fs C
y
g
where each xi represents the subvector of unknowns that are interior to subdomain
Ωi and y represents the vector of all interface unknowns. It is useful to express the
above system in the simpler form,
 
 


x
f
B E
A
=
with A =
.
(14.2)
y
g
F C

Thus, E represents the subdomain to interface coupling seen from the subdomains,
while F represents the interface to subdomain coupling seen from the interface
nodes.
(b)

(a)
9

10

11

12

9

10

11

12

6

7

8

Ω1
5

6

7

8

5

Ω2
1

3

2

4

1

2

10

11

12

6

7

8

3

4

(c)
9

Ω1
5

Ω2
1

2

3

4

Figure 14.2: (a) Vertex-based, (b) edge-based, and (c) element-based partitioning of
a 4 × 3 mesh into two subregions.

472

14.1.2

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

Types of Partitionings

When partitioning a problem, it is common to use graph representations. Since the
subproblems obtained from a given partitioning will eventually be mapped into distinct processors, there are some restrictions regarding the type of partitioning needed.
For example, in Element-By-Element finite element techniques, it may be desirable
to map elements into processors instead of vertices. In this case, the restriction means
no element should be split between two subdomains, i.e., all information related to
a given element is mapped to the same processor. These partitionings are termed
element-based. A somewhat less restrictive class of partitionings are the edge-based
partitionings, which do not allow edges to be split between two subdomains. These
may be useful for finite volume techniques where computations are expressed in
terms of fluxes across edges in two dimensions. Finally, vertex-based partitionings
work by dividing the origin vertex set into subsets of vertices and have no restrictions
on the edges, i.e., they allow edges or elements to straddle between subdomains. See
Figure 14.2, (a), (b), and (c).

14.1.3

Types of Techniques

The interface values can be obtained by employing a form of block-Gaussian elimination which may be too expensive for large problems. In some simple cases, using
FFT’s, it is possible to explicitly obtain the solution of the problem on the interfaces
inexpensively.
Other methods alternate between the subdomains, solving a new problem each
time, with boundary conditions updated from the most recent subdomain solutions.
These methods are called Schwarz Alternating Procedures, after the Swiss mathematician who used the idea to prove the existence for a solution of the Dirichlet
problem on irregular regions.
The subdomains may be allowed to overlap. This means that the Ωi ’s are such
that
[
Ω=
Ωi , Ωi ∩ Ωj 6= φ.
i=1,s

For a discretized problem, it is typical to quantify the extent of overlapping by the
number of mesh-lines that are common to the two subdomains. In the particular case
of Figure 14.3, the overlap is of order one.
The various domain decomposition techniques are distinguished by four features:
1. Type of Partitioning. For example, should partitioning occur along edges, or
along vertices, or by elements? Is the union of the subdomains equal to the
original domain or a superset of it (fictitious domain methods)?
2. Overlap. Should sub-domains overlap or not, and by how much?
3. Processing of interface values. For example, is the Schur complement approach used? Should there be successive updates to the interface values?

14.1. INTRODUCTION

473

4. Subdomain solution. Should the subdomain problems be solved exactly or
approximately by an iterative method?

30

31

32

33

26

27

28

29

22

23

24

25

40

39

38

37

19

20

21

7

8

9

36

16

17

18

4

5

6

35

13

14

15

1

2

3

34

10

11

12

Figure 14.3: Discretization of problem shown in Figure 14.1.

Figure 14.4: Matrix associated with the finite difference mesh of Figure 14.3.

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

474

The methods to be discussed in this chapter will be classified in four distinct
groups. First, direct methods and the substructuring approach are useful for introducing some definitions and for providing practical insight. Second, among the simplest and oldest techniques are the Schwarz Alternating Procedures. Then, there are
methods based on preconditioning the Schur complement system. The last category
groups all the methods based on solving the linear system with the matrix A, by using
a preconditioning derived from Domain Decomposition concepts.

14.2

Direct Solution and the Schur Complement

One of the first divide-and-conquer ideas used in structural analysis exploited the
partitioning (14.1) in a direct solution framework. This approach, which is covered
in this section, introduces the Schur complement and explains some of its properties.

14.2.1

Block Gaussian Elimination

Consider the linear system written in the form (14.2), in which B is assumed to be
nonsingular. From the first equation the unknown x can be expressed as
x = B −1 (f − Ey).

(14.3)

Upon substituting this into the second equation, the following reduced system is obtained:
(C − F B −1 E)y = g − F B −1 f.
(14.4)
The matrix
S = C − F B −1 E

(14.5)

is called the Schur complement matrix associated with the y variable. If this matrix
can be formed and the linear system (14.4) can be solved, all the interface variables
y will become available. Once these variables are known, the remaining unknowns
can be computed, via (14.3). Because of the particular structure of B, observe that
any linear system solution with it decouples in s separate systems. The parallelism
in this situation arises from this natural decoupling.
A solution method based on this approach involves four steps:
1. Obtain the right-hand side of the reduced system (14.4).
2. Form the Schur complement matrix (14.5).
3. Solve the reduced system (14.4).
4. Back-substitute using (14.3) to obtain the other unknowns.
One linear system solution with the matrix B can be saved by reformulating the
algorithm in a more elegant form. Define
E ′ = B −1 E

and

f ′ = B −1 f.

14.2. DIRECT SOLUTION AND THE SCHUR COMPLEMENT

475

The matrix E ′ and the vector f ′ are needed in steps (1) and (2). Then rewrite step (4)
as
x = B −1 f − B −1 Ey = f ′ − E ′ y,
which gives the following algorithm.
A LGORITHM 14.1 Block-Gaussian Elimination

1.
2.
3.
4.
5.

Solve BE ′ = E , and Bf ′ = f for E ′ and f ′ , respectively
Compute g′ = g − F f ′
Compute S = C − F E ′
Solve Sy = g′
Compute x = f ′ − E ′ y .

In a practical implementation, all the Bi matrices are factored and then the systems Bi Ei′ = Ei and Bi fi′ = fi are solved. In general, many columns in Ei will
be zero. These zero columns correspond to interfaces that are not adjacent to subdomain i. Therefore, any efficient code based on the above algorithm should start by
identifying the nonzero columns.

14.2.2

Properties of the Schur Complement

Now the connections between the Schur complement and standard Gaussian elimination will be explored and a few simple properties will be established. Start with
the block-LU factorization of A,

 


B E
I
O
B E
=
(14.6)
F C
F B −1 I
O S
which is readily verified. The Schur complement can therefore be regarded as the
(2,2) block in the U part of the block-LU factorization of A. From the above relation,
note that if A is nonsingular, then so is S. Taking the inverse of A with the help of
the above equality yields

 −1


−1
I
O
B
−B −1 ES −1
B E
=
O
S −1
−F B −1 I
F C
 −1

B + B −1 ES −1 F B −1 −B −1 ES −1
=
. (14.7)
−S −1 F B −1
S −1
Observe that S −1 is the (2,2) block in the block-inverse of A. In particular, if the
original matrix A is Symmetric Positive Definite, then so is A−1 . As a result, S is
also Symmetric Positive Definite in this case.
Although simple to prove, the above properties are nonetheless important. They
are summarized in the following proposition.

476

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

Proposition 14.1 Let A be a nonsingular matrix partitioned as in (14.2) and such
that the submatrix B is nonsingular and let Ry be the restriction operator onto the
interface variables, i.e, the linear operator defined by
 
x
Ry
= y.
y
Then the following properties are true.
1. The Schur complement matrix S is nonsingular.
2. If A is SPD, then so is S.
3. For any y, S −1 y = Ry A−1

 
0
y

.

The first property indicates that a method that uses the above block Gaussian
elimination algorithm is feasible since S is nonsingular. A consequence of the second property is that when A is positive definite, an algorithm such as the Conjugate
Gradient algorithm can be used to solve the reduced system (14.4). Finally, the third
property establishes a relation which may allow preconditioners for S to be defined
based on solution techniques with the matrix A.

14.2.3

Schur Complement for Vertex-Based Partitionings

The partitioning used in Figure 14.3 is edge-based, meaning that a given edge in the
graph does not straddle two subdomains, or that if two vertices are coupled, then they
cannot belong to the two distinct subdomains. From the graph theory point of view,
this is perhaps less common than vertex-based partitionings in which a vertex is not
shared by two partitions (except when domains overlap). A vertex-based partitioning
is illustrated in Figure 14.5.
We will call interface edges all edges that link vertices that do not belong to the
same subdomain. In the case of overlapping, this needs clarification. An overlapping
edge or vertex belongs to the same subdomain. Interface edges are only those that
link a vertex to another vertex which is not in the same subdomain already, whether in
the overlapping portion or elsewhere. Interface vertices are those vertices in a given
subdomain that are adjacent to an interface edge. For the example of the figure, the
interface vertices for subdomain one (bottom, left subsquare) are the vertices labeled
10 to 16. The matrix shown at the bottom of Figure 14.5 differs from the one of
Figure 14.4, because here the interface nodes are not relabeled the last in the global
labeling as was done in Figure 14.3. Instead, the interface nodes are labeled as the
last nodes in each subdomain. The number of interface nodes is about twice that of
the edge-based partitioning.
Consider the Schur complement system obtained with this new labeling. It can
be written similar to the edge-based case using a reordering in which all interface
variables are listed last. The matrix associated with the domain partitioning of the
variables will have a natural s-block structure where s is the number of subdomains.

14.2. DIRECT SOLUTION AND THE SCHUR COMPLEMENT

41

42

43

44

37

38

39

40

33

34

35

36

45

46

47

48

16

15

14

13

32

26

27

28

7

8

9

12

31

23

24

25

4

5

6

11

30

20

21

22

1

2

3

10

29

17

18

19

477

Figure 14.5: Discretization of problem shown in Figure 14.1 and associated matrix.

478

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

For example, when s = 3 (as is the case in the above illustration), the matrix has the
block structure defined by the solid lines in the figure, i.e.,


A1 A12 A13
A =  A21 A2 A23  .
(14.8)
A31 A32 A3
In each subdomain, the variables are of the form
 
xi
,
zi =
yi

where xi denotes interior nodes while yi denotes the interface nodes associated with
subdomain i. Each matrix Ai will be called the local matrix.
The structure of Ai is as follows:


Bi Ei
(14.9)
Ai =
Fi Ci
in which, as before, Bi represents the matrix associated with the internal nodes of
subdomain i and Ei and Fi represent the couplings to/from local interface nodes. The
matrix Ci is the local part of the interface matrix C defined before, and represents the
coupling between local interface points. A careful look at the matrix in Figure 14.5
reveals an additional structure for the blocks Aij j 6= i. Partitioning Aij according
to the variables xi , yi on the one hand (rows) and xj , yj on the other, reveals that it is
comprised of only one nonzero block. Indeed, there is no coupling between xi and
xj , between xi and yj , or between yi and xj . Therefore, the submatrix Aij has the
following structure,


0 0
.
(14.10)
Aij =
0 Eij
In addition, most of the Eij matrices are zero since only those indices j of the subdomains that have couplings with subdomain i will yield a nonzero Eij .
Now write the part of the linear system that is local to subdomain i, as
Bi xi + Ei yi
= fi
P
.
Fi xi + Ci yi +
E
y
=
gi
j∈Ni ij j

(14.11)

The term Eij yj is the contribution to the equation from the neighboring subdomain
number j, and Ni is the set of subdomains that are adjacent to subdomain i. Assuming that Bi is nonsingular, the variable xi can be eliminated from this system by
extracting from the first equation xi = Bi−1 (fi − Ei yi ) which yields, upon substitution in the second equation,
X
Si y i +
Eij yj = gi − Fi Bi−1 fi , i = 1, . . . , s
(14.12)
j∈Ni

in which Si is the “local” Schur complement
Si = Ci − Fi Bi−1 Ei .

(14.13)

14.2. DIRECT SOLUTION AND THE SCHUR COMPLEMENT

479

When written for all subdomains i, the equations (14.12) yield a system of equations
which involves only the interface points yj , j = 1, 2, . . . , s and which has a natural
block structure associated with these vector variables


S1 E12 E13 · · · E1s
 E21 S2 E23 · · · E2s 
 .
.. 
..
.
.
S = 
.
(14.14)
. 
 ..
.. 
..
 ..

.
.
Es1 Es2 Es3 · · · Ss

The diagonal blocks in this system, namely, the matrices Si , are dense in general,
but the offdiagonal blocks Eij are sparse and most of them are zero. Specifically,
Eij 6= 0 only if subdomains i and j have at least one equation that couples them.
A structure of the global Schur complement S has been unraveled which has the
following important implication: For vertex-based partitionings, the Schur complement matrix can be assembled from local Schur complement matrices (the Si ’s) and
interface-to-interface information (the Eij ’s). The term “assembled” was used on
purpose because a similar idea will be exploited for finite element partitionings.

14.2.4

Schur Complement for Finite-Element Partitionings

In finite-element partitionings, the original discrete set Ω is subdivided into s subsets
Ωi , each consisting of a distinct set of elements. Given a finite element discretization of the domain Ω, a finite dimensional space Vh of functions over Ω is defined,
e.g., functions that are piecewise linear and continuous on Ω, and that vanish on the
boundary Γ of Ω. Consider now the Dirichlet problem on Ω and recall that its weak
formulation on the finite element discretization can be stated as follows (see Section
2.3):
Find u ∈ Vh such that a(u, v) = (f, v), ∀ v ∈ Vh ,
where the bilinear form a(., .) is defined by

Z 
Z
∂u ∂u
∂u ∂v
+
dx.
∇u.∇v dx =
a(u, v) =
∂x2 ∂x2
Ω ∂x1 ∂x1
Ω
It is interesting to observe that since the set of the elements of the different Ωi ’s are
disjoint, a(., .) can be decomposed as
a(u, v) =

s
X

ai (u, v),

i=1

where
ai (u, v) =

Z

Ωi

∇u.∇v dx.

In fact, this is a generalization of the technique used to assemble the stiffness matrix from element matrices, which corresponds to the extreme case where each Ωi
consists of exactly one element.

480

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

If the unknowns are ordered again by subdomains and the interface nodes are
placed last as was done in Section 14.1, immediately the system shows the same
structure,
   

f1
x1
B1
E1

B2
E2   x2   f2 
 .   . 

.. 
..
 .   . 

(14.15)
.
. 
 .  =  . 







xs
Bs Es
fs
y
F1 F2 · · · Fs C
g

where each Bi represents the coupling between interior nodes and Ei and Fi represent the coupling between the interface nodes and the nodes interior to Ωi . Note that
each of these matrices has been assembled from element matrices and can therefore
be obtained from contributions over all subdomain Ωj that contain any node of Ωi .
In particular, assume that the assembly is considered only with respect to Ωi .
Then the assembled matrix will have the structure


Bi Ei
Ai =
,
Fi Ci
where Ci contains only contributions from local elements, i.e., elements that are in
Ωi . Clearly, C is the sum of the Ci ’s,
C=

s
X

Ci .

i=1

The Schur complement associated with the interface variables is such that
S = C − F B −1 E
s
X
Fi Bi−1 Ei
= C−
i=1

=

s
X
i=1

=

Ci −

s
X

i=1

s
X

Fi Bi−1 Ei

i=1


Ci − Fi Bi−1 Ei .

Therefore, if Si denotes the local Schur complement
Si = Ci − Fi Bi−1 Ei ,
then the above proves that,
S=

s
X

Si ,

(14.16)

i=1

showing again that the Schur complement can be obtained easily from smaller Schur
complement matrices.

14.2. DIRECT SOLUTION AND THE SCHUR COMPLEMENT

481

Another important observation is that the stiffness matrix Ak , defined above by
restricting the assembly to Ωk , solves a Neumann-Dirichlet problem on Ωk . Indeed,
consider the problem

  
 
Bk Ek
xk
fk
=
.
(14.17)
Fk Ck
yk
gk
The elements of the submatrix Ck are the terms ak (φi , φj ) where φi , φj are the basis
functions associated with nodes belonging to the interface Γk . As was stated above,
the matrix C is the sum of these submatrices. Consider the problem of solving the
Poisson equation on Ωk with boundary conditions defined as follows: On Γk0 , the
part of the boundary which belongs to Γk , use the original boundary conditions;
on the interfaces Γkj with other subdomains, use a Neumann boundary condition.
According to Equation (2.47) seen in Section 2.3, the j-th equation will be of the
form,
Z
Z
Z
∂u
ds.
(14.18)
φj
f φj dx +
∇u.∇φj dx =
∂~n
Γk
Ωk
Ωk

This gives rise to a system of the form (14.17) in which the gk part of the right-hand
side incorporates the Neumann data related to the second integral on the right-hand
side of (14.18).
It is interesting to note that if a problem were to be solved with all-Dirichlet conditions, i.e., if the Neumann conditions at the interfaces were replaced by Dirichlet
conditions, the resulting matrix problem would be of the form,
 
  

fk
xk
Bk Ek
(14.19)
=
gk
yk
0
I

where gk represents precisely the Dirichlet data. Indeed, according to what was
seen in Section 2.3, Dirichlet conditions are handled simply by replacing equations
associated with boundary points by identity equations.

14.2.5

Schur Complement for the model problem

An explicit expression for the Schur complement can be found in the simple case of
a rectangular region partitioned into two sub-domains as illustrated in Figure 14.6.
The figure shows a vertex based partitioning but what follows is also valid for edgebased partitionings since we will only compute the local Schur complements S1 , S2
from which the the global Schur complement is constituted. For an edge-based partitioning, the Schur complement S is the sum of the local Schur complements S1 and
S2 . For a vertex-based partitioning, S is of the form (14.14), with s = 2.

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

482

Figure 14.6:
domain.

4

8

12

16

32

28

24

20

3

7

11

15

31

27

23

19

2

6

10

14

30

26

22

18

1

5

9

13

29

25

21

17

A two-domain partitioning of the model problem on a rectangular

To determine S1 , start by writing the discretized matrix for the model problem
in the subdomain Ω1 :




B −I
4 −1
 −I B −I

 −1 4 −1





.
.
.
.
.
.
 with B = 
..
..
..
.
..
..
..
A=







−I B −I
−1 4 −1 
−I B
−1 4

Assume that the size of each block (i.e., the number of points in the vertical direction
in Ω1 ) is m with the number of blocks (i.e., the number of points in the horizontal
direction in Ω1 ) is n. Also the points are ordered naturally, with the last vertical line
forming the interface. Then A is factored in the following block LU decomposition:



I
T1 −I
 −T −1 I


T2 −I
1





.
.
.
.
 .
.
.
.
.
A=

.
.
.
.



−1


Tn−1 −I 
−Tj−1
I
−1
Tn
−Tn−1
I
The matrices Ti satisfy the recurrence:
T1 = B;

Tk+1 = B − Tk−1 ,

k = 1, . . . , n − 1.

(14.20)

It can easily be shown that the above recurrence does not break down, i.e., that each
inverse does indeed exist. Also, the matrix Tn is the desired local Schur complement
S1 .
Each Tk is a rational function of B, i.e., Tk = fk (B) where fk is a rational
function defined by
1
.
fk+1 (µ) = µ −
fk (µ)

14.2. DIRECT SOLUTION AND THE SCHUR COMPLEMENT

483

To each eigenvalue µ of B, is associated an eigenvalue λk . This sequence of eigenvalues satisfies the recurrence
1
.
λk+1 = µ −
λk
To calculate fn it is sufficient to calculate λk in terms of µ. The above difference
equation, differs from the ones we have encountered in other chapters, in that it is
nonlinear. It can be solved by defining the auxiliarly unknown
ηk =

k
Y

λj .

j=0

By definition λ0 = 1, λ1 = µ so that η0 = 1, η1 = µ. The sequence ηk satisfies the
recurrence:
ηk+1 = µηk − ηk−1
which is now
p a linear difference equation. The characteristic roots of the equation
are (µ ± µ2 − 4)/2. Let ρ denote the largest root and note that the other root is
equal to 1/ρ. The general solution of the difference equation is therefore,
"
#k
#k
"
p
p
µ + µ2 − 4
µ − µ2 − 4
k
−k
ηk = αρ + βρ = α
+β
.
2
2
The condition at k = 0 yields α + β = 1. Then, writing the condition η1 = µ, yields,
p
p
µ2 − 4 + µ
µ2 − 4 − µ
p
p
;
β=
.
α=
2 µ2 − 4
2 µ2 − 4

Therefore,

ηk = p

1

µ2 − 4

i
h
ρk+1 − ρ−k−1 .

The sequence λk is ηk /ηk−1 , which yields,
λk = ρ

1 − ρ−2(k+1)
.
1 − ρ−2k

This gives the desired expression for fn , and Tn . Specifically, if we define
√
B + B 2 − 4I
Ŝ =
,
2
then,
S1 = Tn = ŜX

where

−1


.
X = I − B̂ −2(k+1) I − B̂ −2k

Despite the apparent nonsymmetry of the above expression, it is worth noting that the
operator thus defined is symmetric positive definite. In addition, the factor X is usually very close to the identity matrix because the powers B −2j decay exponentially
to zero (the eigenvalues of B are all larger then 2).

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

484

The result can be stated in terms of the one dimensional finite difference operator
T instead of B because B = T + 2I. Either way, the final expression is a rather
complex one, since it involves a square root, even when Ŝ, the approximation to S1
is used. It is possible, however, to use FFTs or sine transforms to perform a solve
with the matrix Ŝ. This is because if the spectral decomposition of B is written
as B = QΛQT , then S1 = Qfn (Λ)QT , and the products with Q and QT can be
performed with FFT, see Section 2.2.6.

14.3

Schwarz Alternating Procedures

The original alternating procedure described by Schwarz in 1870 consisted of three
parts: alternating between two overlapping domains, solving the Dirichlet problem
on one domain at each iteration, and taking boundary conditions based on the most
recent solution obtained from the other domain. This procedure is called the Multiplicative Schwarz procedure. In matrix terms, this is very reminiscent of the block
Gauss-Seidel iteration with overlap defined with the help of projectors, as seen in
Chapter 5. The analogue of the block-Jacobi procedure is known as the Additive
Schwarz procedure.

14.3.1

Multiplicative Schwarz Procedure

In the following, assume that each subdomain Ωi extends into its neighboring subdomains by one level, which will be used as a boundary for Ωi . The boundary of
subdomain Ωi that is included in subdomain j is denoted by Γij .
Γ3,0

Ω3
Γ1,3

Γ3,1
Γ1,0

Γ2,1

Γ1,2

Ω2

Γ2,0

Ω1

Figure 14.7: An L-shaped domain subdivided into three overlapping subdomains.
This is illustrated in Figure 14.7 for the L-shaped domain example. A more spe-

14.3. SCHWARZ ALTERNATING PROCEDURES

485

cific illustration is in Figure (14.5), where, for example, Γ12 = {29, 30, 31, 32} and
Γ31 = {13, 14, 15, 16}. Call Γi the boundary of Ωi consisting of its original boundary (which consists of the Γi0 pieces in the figure) and the Γij ’s, and denote by uji
the restriction of the solution u to the boundary Γji . Then the Schwarz Alternating
Procedure can be described as follows.
A LGORITHM 14.2 SAP

1.
2.
3.
4.
5.
6.
7.

Choose an initial guess u to the solution
Until convergence Do:
For i = 1, · · · , s Do:
Solve ∆u = f in Ωi with u = uij in Γij
Update u values on Γji , ∀j
EndDo
EndDo

The algorithm sweeps through the s subdomains and solves the original equation in
each of them by using boundary conditions that are updated from the most recent
values of u. Since each of the subproblems is likely to be solved by some iterative
method, we can take advantage of a good initial guess. It is natural to take as initial
guess for a given subproblem the most recent approximation. Going back to the
expression (14.11) of the local problems, observe that each of the solutions in line 4
of the algorithm will be translated into an update of the form
ui := ui + δi ,
where the correction δi solves the system
Ai δi = ri .
Here, ri is the local part of the most recent global residual vector b − Ax, and the
above system represents the system associated with the problem in line 4 of the
algorithm when a nonzero initial guess is used in some iterative procedure. The
matrix Ai has the block structure (14.9). Writing




 
rx,i
δx,i
xi
,
, ri =
, δi =
ui =
ry,i
δy,i
yi
the correction to the current solution step in the algorithm leads to
 
  
−1 

xi
xi
Bi Ei
rx,i
:=
+
.
yi
yi
Fi Ci
ry,i

(14.21)

After this step is taken, normally a residual vector r would have to be computed
again to get the components associated with domain i + 1 and to proceed with a
similar step for the next subdomain. However, only those residual components that
have been affected by the change of the solution need to be updated. Specifically,

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

486

employing the same notation used in equation (14.11), we can simply update the
residual ry,j for each subdomain j for which i ∈ Nj as
ry,j := ry,j − Eji δy,i .
This amounts implicitly to performing Step 5 of the above algorithm. Note that since
the matrix pattern is assumed to be symmetric, then the set of all indices j such that
i ∈ Nj , i.e., Ni∗ = {j |i ∈ Ni }, is identical to Ni . Now the loop starting in line 3
of Algorithm 14.2 and called domain sweep can be restated as follows.
A LGORITHM 14.3 Multiplicative Schwarz Sweep – Matrix Form

1.
2.
3.
4.
5.

For i = 1, · · · , s Do:
Solve Ai δi = ri
Compute xi := xi + δx,i , yi := yi + δy,i , and set ri := 0
For each j ∈ Ni Compute ry,j := ry,j − Eji δy,i
EndDo

Considering only the y iterates, the above iteration would resemble a form of GaussSeidel procedure on the Schur complement matrix (14.14). In fact, it is mathematically equivalent, provided a consistent initial guess is taken. This is stated in the next
result established by Chan and Goovaerts [73]:
 (0) 
xi
Theorem 14.2 Let the guess
for the Schwarz procedure in each subdomain
(0)
yi

be chosen such that

(0)

xi

(0)

= Bi−1 [fi − Ei yi ].

(14.22)

Then the y iterates produced by the Algorithm 14.3 are identical to those of a GaussSeidel sweep applied to the Schur complement system (14.12).
Proof. We start by showing that with the choice (14.22), the y components of the
initial residuals produced by the algorithm are identical to those of the Schur complement system (14.12). Refer to Section 14.2.3 and the relation (14.10) which defines the Eij ’s from
the block structure (14.8) of the global matrix. Observe that

0
Aij uj = Eij yj and note from (14.11) that for the global system the y components
of the initial residual vectors are
X
(0)
(0)
(0)
(0)
ry,i = gi − Fi xi − Ci yi −
Eij yj
=
=

j∈Ni
X
(0)
(0)
(0)
gi − Fi B −1 [fi − Ei yi ] − Ci yi −
Eij yj
j∈Ni
X
(0)
(0)
−1
Eij yj .
gi − Fi B fi − Si yi −
j∈Ni

This is precisely the expression of the residual vector associated with the Schur com(0)
plement system (14.12) with the initial guess yi .

14.3. SCHWARZ ALTERNATING PROCEDURES

487
(0)

Now observe that the initial guess has been selected so that rx,i = 0 for all i.
Because only the y components of the residual vector are modified, according to line
4 of Algorithm 14.3, this property remains valid throughout the iterative process. By
the updating equation (14.21) and the relation (14.7), we have
yi := yi + Si−1 ry,i ,
which is precisely a Gauss-Seidel step associated with the system (14.14). Note that
the update of the residual vector in the algorithm results in the same update for the y
components as in the Gauss-Seidel iteration for (14.14).
It is interesting to interpret Algorithm 14.2, or rather its discrete version, in terms
of projectors. For this we follow the model of the overlapping block-Jacobi technique
seen in the previous chapter. Let Si be an index set
Si = {j1 , j2 , . . . , jni },
where the indices jk are those associated with the ni mesh points of the interior of
the discrete subdomain Ωi . Note that as before, the Si ’s form a collection of index
sets such that
[
Si = {1, . . . , n},
i=1,...,s

and the Si ’s are not necessarily disjoint. Let Ri be a restriction operator from Ω
to Ωi . By definition, Ri x belongs to Ωi and keeps only those components of an
arbitrary vector x that are in Ωi . It is represented by an ni × n matrix of zeros and
ones. The matrices Ri associated with the partitioning of Figure 14.4 are represented
in the three diagrams of Figure 14.8, where each square represents a nonzero element
(equal to one) and every other element is a zero. These matrices depend on the
ordering chosen for the local problem. Here, boundary nodes are labeled last, for
simplicity. Observe that each row of each Ri has exactly one nonzero element (equal
to one). Boundary points such as the nodes 36 and 37 are represented several times
in the matrices R1 , R2 , and R3 because of the overlapping of the boundary points.
Thus, node 36 is represented in matrices R1 and R2 , while 37 is represented in all
three matrices.
From the linear algebra point of view, the restriction operator Ri is an ni × n
matrix formed by the transposes of columns ej of the n × n identity matrix, where
j belongs to the index set Si . The transpose RiT of this matrix is a prolongation
operator which takes a variable from Ωi and extends it to the equivalent variable in
Ω. The matrix
Ai = Ri ARiT
of dimension ni × ni defines a restriction of A to Ωi . Now a problem associated with
Ai can be solved which would update the unknowns in the domain Ωi . With this
notation, the multiplicative Schwarz procedure can be described as follows:

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

488

1.
2.
3.

For i = 1, . . . , s Do
x := x + RiT A−1
i Ri (b − Ax)
EndDo

R1 =

R2 =

R3 =

Figure 14.8: Patterns of the three matrices Ri associated with the partitioning of
Figure 14.4.
We change notation and rewrite step 2 as
xnew = x + RiT A−1
i Ri (b − Ax).

(14.23)

If the errors d = x∗ − x are considered where x∗ is the exact solution, then notice
that b − Ax = A(x∗ − x) and, at each iteration the following equation relates the
new error dnew and the previous error d,
dnew = d − RiT A−1
i Ri Ad.
Starting from a given x0 whose error vector is d0 = x∗ − x, each sub-iteration
produces an error vector which satisfies the relation
di = di−1 − RiT A−1
i Ri Adi−1 ,
for i = 1, . . . , s. As a result,
di = (I − Pi )di−1

14.3. SCHWARZ ALTERNATING PROCEDURES

489

in which
Pi = RiT A−1
i Ri A.

(14.24)

Observe that the operator Pi ≡ RiT A−1
i Ri A is a projector since
−1
2
T −1
T
T −1
(RiT A−1
i Ri A) = Ri Ai (Ri ARi )Ai Ri A = Ri Ai Ri A.

Thus, one sweep produces an error which satisfies the relation
ds = (I − Ps )(I − Ps−1 ) . . . (I − P1 )d0 .

(14.25)

In the following, we use the notation
Qs ≡ (I − Ps )(I − Ps−1 ) . . . (I − P1 ).

14.3.2

(14.26)

Multiplicative Schwarz Preconditioning

Because of the equivalence of the multiplicative Schwarz procedure and a block
Gauss-Seidel iteration, it is possible to recast one Multiplicative Schwarz sweep in
the form of a global fixed-point iteration of the form xnew = Gx + f . Recall that
this is a fixed-point iteration for solving the preconditioned system M −1 Ax = M −1 b
where the preconditioning matrix M and the matrix G are related by G = I −M −1 A.
To interpret the operation associated with M −1 , it is helpful to identify the result of the error vector produced by this iteration with that of (14.25), which is
xnew − x∗ = Qs (x − x∗ ). This comparison yields,
xnew = Qs x + (I − Qs )x∗ ,
and therefore,
G = Qs

f = (I − Qs )x∗ .

Hence, the preconditioned matrix is M −1 A = I − Qs . This result is restated as
follows.
Proposition 14.3 The multiplicative Schwarz procedure is equivalent to a fixedpoint iteration for the “preconditioned” problem
M −1 Ax = M −1 b,
in which
M −1 A = I − Qs
M

−1

(14.27)
−1

b = (I − Qs )x∗ = (I − Qs )A

b.

(14.28)

The transformed right-hand side in the proposition is not known explicitly since it
is expressed in terms of the exact solution. However, a procedure can be found to
compute it. In other words, it is possible to operate with M −1 without invoking
A−1 . Note that M −1 = (I − Qs )A−1 . As the next lemma indicates, M −1 , as well
as M −1 A, can be computed recursively.

490

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

Lemma 14.4 Define the matrices
Zi = I − Q i

(14.29)

−1

Mi = Zi A

−1

Ti = Pi A

(14.30)
= RiT A−1
i Ri

(14.31)

for i = 1, . . . , s. Then M −1 = Ms , M −1 A = Zs , and the matrices Zi and Mi
satisfy the recurrence relations
Z1 = P1 ,
Zi = Zi−1 + Pi (I − Zi−1 ),

i = 2, . . . , s

(14.32)

i = 2, . . . , s.

(14.33)

and
M1 = T1 ,
Mi = Mi−1 + Ti (I − AMi−1 ),

Proof. It is clear by the definitions (14.29) and (14.30) that Ms = M −1 and that
M1 = T1 , Z1 = P1 . For the cases i > 1, by definition of Qi and Qi−1
Zi = I − (I − Pi )(I − Zi−1 ) = Pi + Zi−1 − Pi Zi−1 ,

(14.34)

which gives the relation (14.32). Multiplying (14.34) to the right by A−1 yields,
Mi = Ti + Mi−1 − Pi Mi−1 .
Rewriting the term Pi as Ti A above yields the desired formula (14.33).
Note that (14.32) yields immediately the important relation
Zi =

i
X

Pj Qj−1 .

(14.35)

j=1

If the relation (14.33) is multiplied to the right by a vector v and if the vector Mi v is
denoted by zi , then the following recurrence results.
zi = zi−1 + Ti (v − Azi−1 ).
Since zs = (I − Qs )A−1 v = M −1 v, the end result is that M −1 v can be computed
for an arbitrary vector v, by the following procedure.
A LGORITHM 14.4 Multiplicative Schwarz Preconditioner

1.
2.
3.
4.
5.

Input: v ; Output: z = M −1 v .
z := T1 v
For i = 2, . . . , s Do:
z := z + Ti (v − Az)
EndDo

14.3. SCHWARZ ALTERNATING PROCEDURES

491

By a similar argument, a procedure can be found to compute vectors of the form
z = M −1 Av. In this case, the following algorithm results:
A LGORITHM 14.5 Multiplicative Schwarz Preconditioned Operator

1.
2.
3.
4.
5.

Input: v , Output: z = M −1 Av .
z := P1 v
For i = 2, . . . , s Do
z := z + Pi (v − z)
EndDo

In summary, the Multiplicative Schwarz procedure is equivalent to solving the
“preconditioned system”
(I − Qs )x = g
(14.36)
where the operation z = (I − Qs )v can be computed from Algorithm 14.5 and g =
M −1 b can be computed from Algorithm 14.4. Now the above procedures can be used
within an accelerator such as GMRES. First, to obtain the right-hand side g of the
preconditioned system (14.36), Algorithm 14.4 must be applied to the original righthand side b. Then GMRES can be applied to (14.36) in which the preconditioned
operations I − Qs are performed by Algorithm 14.5.
Another important aspect of the Multiplicative Schwarz procedure is that multicoloring can be exploited in the same way as it is done traditionally for block SOR.
Finally, note that symmetry is lost in the preconditioned system but it can be recovered by following the sweep 1, 2, . . . , s by a sweep in the other direction, namely,
s − 1, s − 2, . . . , 1. This yields a form of the block SSOR algorithm.

14.3.3

Additive Schwarz Procedure

The additive Schwarz procedure is similar to a block-Jacobi iteration and consists
of updating all the new (block) components from the same residual. Thus, it differs
from the multiplicative procedure only because the components in each subdomain
are not updated until a whole cycle of updates through all domains are completed.
The basic Additive Schwarz iteration would therefore be as follows:

1.
2.
3.
4.

For i = 1, . . . , s Do
Compute δi = RiT A−1
i Ri (b − Ax)
EndDo
P
xnew = x + si=1 δi

The new approximation (obtained after a cycle of the s substeps in the above
algorithm are applied) is
xnew = x +

s
X
i=1

RiT A−1
i Ri (b − Ax).

492

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

Each instance of the loop redefines different components of the new approximation
and there is no data dependency between the subproblems involved in the loop.
The preconditioning matrix is rather simple to obtain for the additive Schwarz
procedure. Using the matrix notation defined in the previous section, notice that the
new iterate satisfies the relation
!
s
s
s
X
X
X
Ti b.
Pi x +
Ti (b − Ax) = I −
xnew = x +
i=1

i=1

i=1

Thus, using the same analogy as in the previous section, this iteration corresponds to
a fixed-point iteration xnew = Gx + f with
G=I−

s
X

Pi ,

f=

s
X

Ti b.

i=1

i=1

With the relation G = I − M −1 A, between G and the preconditioning matrix M ,
the result is that
s
X
Pi ,
M −1 A =
i=1

and

M −1 =

s
X

Pi A−1 =

i=1

s
X

Ti .

i=1

Now the procedure for applying the preconditioned operator M −1 becomes clear.
A LGORITHM 14.6 Additive Schwarz Preconditioner

1.
2.
3.
4.
5.

Input: v ; Output: z = M −1 v .
For i = 1, . . . , s Do:
Compute zi := Ti v
EndDo
Compute z := z1 + z2 . . . + zs .

Note that the do loop can be performed in parallel. Step 5 sums up the vectors zi
in each domain to obtain a global vector z. In the nonoverlapping case, this step is
parallel and consists of just forming these different components since the addition is
trivial. In the presence of overlap, the situation is similar except that the overlapping
components are added up from the different results obtained in each subdomain.
The procedure for computing M −1 Av is identical to the one above except that
Ti in line 3 is replaced by Pi .

14.3.4

Convergence

Throughout this section, it is assumed that A is Symmetric Positive Definite. The
projectors Pi defined by (14.24) play an important role in the convergence theory of
both additive and multiplicative Schwarz. A crucial observation here is that these

14.3. SCHWARZ ALTERNATING PROCEDURES

493

projectors are orthogonal with respect to the A-inner product. Indeed, it is sufficient
to show that Pi is self-adjoint with respect to the A-inner product,
T −1
(Pi x, y)A = (ARiT A−1
i Ri Ax, y) = (Ax, Ri Ai Ri Ay) = (x, Pi y)A .

Consider the operator,
AJ =

s
X

Pi .

(14.37)

i=1

Since each Pj is self-adjoint with respect to the A-inner product, i.e., A-self-adjoint,
their sum AJ is also A-self-adjoint. Therefore, it will have real eigenvalues. An immediate consequence of the fact that the Pi ’s are projectors is stated in the following
theorem.
Theorem 14.5 The largest eigenvalue of AJ is such that
λmax (AJ ) ≤ s,
where s is the number of subdomains.
Proof. For any matrix norm, λmax (AJ ) ≤ kAJ k. In particular, if the A-norm is
used, we have
s
X
kPi kA .
λmax (AJ ) ≤
i=1

Each of the A-norms of Pi is equal to one since Pi is an A-orthogonal projector. This
proves the desired result.

This result can be improved substantially by observing that the projectors can be
grouped in sets that have disjoint ranges. Graph coloring techniques seen in Chapter 3 can be used to obtain such colorings of the subdomains. Assume that c sets
of indices Θi , i = 1, . . . , c are such that all the subdomains Ωj for j ∈ Θi have no
intersection with one another. Then,
X
PΘi =
Pj
(14.38)
j ∈ Θi

is again an orthogonal projector.
This shows that the result of the previous theorem can be improved trivially into
the following.
Theorem 14.6 Suppose that the subdomains can be colored in such a way that two
subdomains with the same color have no common nodes. Then, the largest eigenvalue
of AJ is such that
λmax (AJ ) ≤ c,
where c is the number of colors.

In order to estimate the lowest eigenvalue of the preconditioned matrix, an assumption must be made regarding the decomposition of an arbitrary vector x into components of Ωi .

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

494
Assumption 1.

There exists a constant K0 such that the inequality
s
X
(Aui , ui ) ≤ K0 (Au, u),
i=1

is satisfied by the representation of u ∈ Ω as the sum
u=

s
X

ui ,

i=1

ui ∈ Ω i .

The following theorem has been proved by several authors in slightly different forms
and contexts.
Theorem 14.7 If Assumption 1 holds, then
λmin (AJ ) ≥

1
.
K0

Proof. Unless otherwise stated, all summations
in this proof are from 1 to s. Start
P
with an arbitrary u decomposed as u = ui and write
X
X
X
(u, u)A =
(ui , u)A =
(Pi ui , u)A =
(ui , Pi u)A .

The last equality is due to the fact that Pi is an A-orthogonal projector onto Ωi and
it is therefore self-adjoint. Now, using Cauchy-Schwarz inequality, we get
(u, u)A =

X

(ui , Pi u)A ≤

By Assumption 1, this leads to

1/2
1/2 X
X
(Pi u, Pi u)A
.
(ui , ui )A

1/2
kuk2A ≤ K0 kukA

which, after squaring, yields
kuk2A ≤ K0

1/2
X
(Pi u, Pi u)A
,

X
(Pi u, Pi u)A .

Finally, observe that since each Pi is an A-orthogonal projector, we have

X
X
X
Pi u, u .
(Pi u, Pi u)A =
(Pi u, u)A =
A

Therefore, for any u, the inequality

(AJ u, u)A ≥

1
(u, u)A
K0

holds, which yields the desired upper bound by the min-max theorem.

14.3. SCHWARZ ALTERNATING PROCEDURES

495

Note that the proof uses the following form of the Cauchy-Schwarz inequality:
p
X
(xi , yi ) ≤
i=1

!1/2
p
X
(xi , xi )
i=1

!1/2
p
X
(yi , yi )
.
i=1

See Exercise 1 for a proof of this variation.
We now turn to the analysis of the Multiplicative Schwarz procedure. We start
by recalling that the error after each outer iteration (sweep) is given by
d = Qs d0 .
We wish to find an upper bound for kQs kA . First note that (14.32) in Lemma 14.4
results in
Qi = Qi−1 − Pi Qi−1 ,
from which we get, using the A-orthogonality of Pi ,
kQi vk2A = kQi−1 vk2A − kPi Qi−1 vk2A .
The above equality is valid for i = 1, provided Q0 ≡ I. Summing these equalities
from i = 1 to s gives the result,
kQs vk2A = kvk2A −

s
X
i=1

kPi Qi−1 vk2A .

(14.39)

This indicates that the A-norm of the error will not increase at each substep of the
sweep.
Now a second assumption must be made to prove the next lemma.
Assumption 2. For any subset S of {1, 2, . . . , s}2 and ui , vj ∈ Ω, the following
inequality holds:
X

(i,j) ∈ S

(Pi ui , Pj vj )A ≤ K1

s
X
i=1

1/2
!1/2  s
X

kPj vj k2A  .
kPi ui k2A

(14.40)

j=1

Lemma 14.8 If Assumptions 1 and 2 are satisfied, then the following is true,
s
X
i=1

kPi vk2A ≤ (1 + K1 )2

s
X
i=1

kPi Qi−1 vk2A .

(14.41)

Proof. Begin with the relation which follows from the fact that Pi is an A-orthogonal
projector,
(Pi v, Pi v)A = (Pi v, Pi Qi−1 v)A + (Pi v, (I − Qi−1 )v)A ,

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

496

which yields, with the help of (14.35),
s
X
i=1

kPi vk2A =

i−1
s X
s
X
X
(Pi v, Pj Qj−1 v)A .
(Pi v, Pi Qi−1 v)A +

(14.42)

i=1 j=1

i=1

For the first term of the right-hand side, use the Cauchy-Schwarz inequality to obtain
!1/2
!1/2
s
s
s
X
X
X
kPi Qi−1 vk2A
.
kPi vk2A
(Pi v, Pi Qi−1 v)A ≤
i=1

i=1

i=1

For the second term of the right-hand side of (14.42), use the assumption (14.40) to
get
1/2
!1/2  s
s
s X
i−1
X
X
X

kPi vk2A )
kPj Qj−1 vk2A ) .
(Pi v, Pj Qj−1 v)A ≤ K1
i=1

i=1 j=1

j=1

Adding these two inequalities, squaring the result, and using (14.42) leads to the
inequality (14.41).

From (14.39), it can be deduced that if Assumption 2 holds, then,
s

kQs vk2A ≤ kvk2A −

X
1
kPi vk2A .
2
(1 + K1 )

(14.43)

i=1

Assumption 1 can now be exploited to derive a lower bound on
will yield the following theorem.
Theorem 14.9 Assume that Assumptions 1 and 2 hold. Then,
1/2

1
.
kQs kA ≤ 1 −
K0 (1 + K1 )2

Ps

2
i=1 kPi vkA . This

(14.44)

Proof. Using the notation of Section 14.3.3, the relation kPi vk2A = (Pi v, v)A yields
!
s
s
X
X
Pi v, v
kPi vk2A =
= (AJ v, v)A .
i=1

i=1

A

According to Theorem 14.7, λmin (AJ ) ≥ K10 , which implies (AJ v, v)A ≥ (v, v)A /K0 .
Thus,

s
X
i=1

kPi vk2A ≥

(v, v)A
,
K0

which upon substitution into (14.43) gives the inequality
kQs vk2A
1
.
≤1−
2
K0 (1 + K1 )2
kvkA
The result follows by taking the maximum over all vectors v.

14.4. SCHUR COMPLEMENT APPROACHES

497

This result provides information on the speed of convergence of the multiplicative Schwarz procedure by making two key assumptions. These assumptions are not
verifiable from linear algebra arguments alone. In other words, given a linear system, it is unlikely that one can establish that these assumptions are satisfied. However, they are satisfied for equations originating from finite element discretization
of elliptic Partial Differential Equations. For details, refer to Dryja and Widlund
[102, 103, 104] and Xu [320].

14.4

Schur Complement Approaches

Schur complement methods are based on solving the reduced system (14.4) by some
preconditioned Krylov subspace method. Procedures of this type involve three steps.

1.
2.
3.

Get the right-hand side g′ = g − F B −1 f .
Solve the reduced system Sy = g′ via an iterative method.
Back-substitute, i.e., compute x via (14.3).

The different methods relate to the way in which step 2 is performed. First
observe that the matrix S need not be formed explicitly in order to solve the reduced
system by an iterative method. For example, if a Krylov subspace method without
preconditioning is used, then the only operations that are required with the matrix
S are matrix-by-vector operations w = Sv. Such operations can be performed as
follows.

1.
2.
3.

Compute v ′ = Ev ,
Solve Bz = v ′
Compute w = Cv − F z .

The above procedure involves only matrix-by-vector multiplications and one linear system solution with B. Recall that a linear system involving B translates into
s-independent linear systems. Also note that the linear systems with B must be
solved exactly, either by a direct solution technique or by an iterative technique with
a high level of accuracy.
While matrix-by-vector multiplications with S cause little difficulty, it is much
harder to precondition the matrix S, since this full matrix is often not available explicitly. There have been a number of methods, derived mostly using arguments
from Partial Differential Equations to precondition the Schur complement. Here, we
consider only those preconditioners that are derived from a linear algebra viewpoint.

14.4.1

Induced Preconditioners

One of the easiest ways to derive an approximation to S is to exploit Proposition 14.1
and the intimate relation between the Schur complement and Gaussian elimination.

498

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

This proposition tells us that a preconditioning operator M to S can be defined from
the (approximate) solution obtained with A. To precondition a given vector v, i.e.,
to compute w = M −1 v, where M is the desired preconditioner to S, first solve the
system
   
x
0
A
=
,
(14.45)
y
v
then take w = y. Use any approximate solution technique to solve the above system.
Let MA be any preconditioner for A. Using the notation defined earlier, let Ry
represent the restriction operator on the interface variables, as defined in Proposition
14.1. Then the preconditioning operation for S which is induced from MA is defined
by
 
0
−1
−1
MS v = Ry MA
= Ry MA−1 RyT v.
v
Observe that when MA is an exact preconditioner, i.e., when MA = A, then according to Proposition 14.1, MS is also an exact preconditioner, i.e., MS = S. This
induced preconditioner can be expressed as
−1
.
(14.46)
MS = Ry MA−1 RyT

It may be argued that this uses a preconditioner related to the original problem to
be solved in the first place. However, even though the preconditioning on S may be
defined from a preconditioning of A, the linear system is being solved for the interface variables. That is typically much smaller than the original linear system. For
example, GMRES can be used with a much larger dimension of the Krylov subspace
since the Arnoldi vectors to keep in memory are much smaller. Also note that from
a Partial Differential Equations viewpoint, systems of the form (14.45) correspond
to the Laplace equation, the solutions of which are “Harmonic” functions. There are
fast techniques which provide the solution of such equations inexpensively.
In the case where MA is an ILU factorization of A, MS can be expressed in an
explicit form in terms of the entries of the factors of MA . This defines a preconditioner to S that is induced canonically from an incomplete LU factorization of A.
Assume that the preconditioner MA is in a factored form MA = LA UA , where




LB
0
UB L−1
B E
LA =
U
=
.
A
F UB−1 LS
0
US
Then, the inverse of MA will have the following structure:
MA−1 = UA−1 L−1
A



⋆
0
⋆
⋆
=
⋆ L−1
0 US−1
S


⋆
⋆
=
⋆ US−1 L−1
S
where a star denotes a matrix whose actual expression is unimportant. Recall that by
definition,
Ry = ( 0 I ) ,

14.4. SCHUR COMPLEMENT APPROACHES

499

where this partitioning conforms to the above ones. This means that
Ry MA−1 RyT = US−1 L−1
S
and, therefore, according to (14.46), MS = LS US . This result is stated in the following proposition.
Proposition 14.10 Let MA = LA UA be an ILU preconditioner for A. Then the
preconditioner MS for S induced by MA , as defined by (14.46), is given by
MS = LS US ,

with

LS = Ry LA RyT ,

US = Ry UA RyT .

In words, the proposition states that the L and U factors for MS are the (2, 2) blocks
of the L and U factors of the ILU factorization of A. An important consequence of
the above idea is that the parallel Gaussian elimination can be exploited for deriving
an ILU preconditioner for S by using a general purpose ILU factorization. In fact,
the L and U factors of MA have the following structure:
A = LA UA − R

L1


LA = 


F1 U1−1

UA





= 



with,
L2

..

.

.

Ls
· · · Fs Us−1

L−1
1 E1
−1
L2 E2 
.. 
. 
.
−1
Us Ls Es 
U

F2 U2−1

U1

U2

..


L







Each Li , Ui pair is an incomplete LU factorization of the local Bi matrix. These ILU
factorizations can be computed independently. Similarly, the matrices L−1
i Ei and
−1
Fi Ui can also be computed independently once the LU factors are obtained. Then
each of the matrices
S̃i = Ci − Fi Ui−1 L−1
i Ei ,
which are the approximate local Schur complements, is obtained. Note that since an
incomplete LU factorization is being performed, some drop strategy is applied to the
elements in S̃i . Let Ti be the matrix obtained after this is done,
Ti = S̃i − Ri .
Then a final stage would be to compute the ILU factorization of the matrix (14.14)
where each Si is replaced by Ti .

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

500

14.4.2

Probing

To derive preconditioners for the Schur complement, another general purpose technique exploits ideas used in approximating sparse Jacobians when solving nonlinear
equations. In general, S is a dense matrix. However, it can be observed, and there
are physical justifications for model problems,
that its entries decay away from the main diagonal. Assume that S is nearly
tridiagonal, i.e., neglect all diagonals apart from the main diagonal and the two codiagonals, and write the corresponding tridiagonal approximation to S as


a 1 b2

 c2 a2
b3


.
.
.
.
..
..
..
T =



cm−1 am−1 bm 
cm
am
Then, it is easy to recover T by applying it to three well-chosen vectors. Consider
the three vectors
w1 = (1, 0, 0, 1, 0, 0, 1, 0, 0, . . . , )T ,
w2 = (0, 1, 0, 0, 1, 0, 0, 1, 0, . . . , )T ,
w3 = (0, 0, 1, 0, 0, 1, 0, 0, 1, . . . , )T .
Then we have
T w1 = (a1 , c2 , b4 , a4 , c5 , . . . , b3i+1 , a3i+1 , c3i+2 , . . .)T ,
T w2 = (b2 , a2 , c3 , b5 , a5 , c6 , . . . , b3i+2 , a3i+2 , c3i+3 , . . .)T ,
T w3 = (b3 , a3 , c4 , b6 , a6 , c7 , . . . , b3i , a3i , c3i+1 , . . .)T .
This shows that all the coefficients of the matrix T are indeed all represented in the
above three vectors. The first vector contains the nonzero elements of the columns
1, 4, 7, . . ., 3i + 1, . . ., in succession written as a long vector. Similarly, T w2
contains the columns 2, 5, 8, . . ., and T w3 contains the columns 3, 6, 9, . . .. We can
easily compute Swi , i = 1, 3 and obtain a resulting approximation T which can be
used as a preconditioner to S. The idea can be extended to compute any banded
approximation to S. For details and analysis see [74].

14.4.3

Preconditioning Vertex-Based Schur Complements

We now discuss some issues related to the preconditioning of a linear system with
the matrix coefficient of (14.14) associated with a vertex-based partitioning. As was
mentioned before, this structure is helpful in the direct solution context because it
allows the Schur complement to be formed by local pieces. Since incomplete LU
factorizations will utilize the same structure, this can be exploited as well.
Note that multicolor SOR or SSOR can also be exploited and that graph coloring can be used to color the interface values yi in such a way that no two adjacent

14.5. FULL MATRIX METHODS

501

interface variables will have the same color. In fact, this can be achieved by coloring
the domains. In the course of a multicolor block-SOR iteration, a linear system must
be solved with the diagonal blocks Si . For this purpose, it is helpful to interpret the
Schur complement. Call P the canonical injection matrix from the local interface
points to the local nodes. If ni points are local and if mi is the number of the local
interface points, then P is an ni × mi matrix whose columns are the last mi columns
of the ni × ni identity matrix. Then it is easy to see that
−1
Si = (P T A−1
loc,i P ) .

(14.47)

If Aloc,i = LU is the LU factorization of Aloc,i then it can be verified that
Si−1 = P T U −1 L−1 P = P T U −1 P P T L−1 P,

(14.48)

which indicates that in order to operate with P T L−1 P , the last mi × mi principal
submatrix of L must be used. The same is true for P T U −1 P which requires only a
back-solve with the last mi × mi principal submatrix of U . Therefore, only the LU
factorization of Aloc,i is needed to solve a system with the matrix Si . Interestingly,
approximate solution methods associated with incomplete factorizations of Aloc,i can
be exploited.

14.5

Full Matrix Methods

We call any technique that iterates on the original system (14.2) a full matrix method.
In the same way that preconditioners were derived from the LU factorization of A
for the Schur complement, preconditioners for A can be derived from approximating
interface values.
Before starting with preconditioning techniques, we establish a few simple relations between iterations involving A and S.
Proposition 14.11 Let
LA =



I
F B −1

O
I



,

UA =



B
O

E
I



(14.49)

and assume that a Krylov subspace method is applied to the original system (14.1)
with left preconditioning LA and right preconditioning UA , and with an initial guess
of the form

   −1
B (f − Ey0 )
x0
=
.
(14.50)
y0
y0
Then this preconditioned Krylov iteration will produce iterates of the form

  −1

B (f − Eym )
xm
=
ym
ym

(14.51)

in which the sequence ym is the result of the same Krylov subspace method applied
without preconditioning to the reduced linear system Sy = g ′ with g′ = g − F B −1 f
starting with the vector y0 .

502

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

Proof. The proof is a consequence of the factorization

 


B E
I
O
I O
B
=
F C
F B −1 I
O S
O

E
I



.

(14.52)

Applying an iterative method (e.g., GMRES) on the original system, preconditioned
from the left by LA and from the right by UA , is equivalent to applying this iterative
method to


I O
−1
−1
LA AUA =
≡ A′ .
(14.53)
O S
The initial residual for the preconditioned system is
 
 
x0
−1 f
−1
−1
LA
− (LA AUA )UA
y0
g

 
 

f
I
O
f
=
−
−F B −1 I
F B −1 (f − Ey0 ) + Cy0
g

  
0
0
=
≡
.
g′ − Sy0
r0

As a result, the Krylov vectors obtained from the preconditioned linear system associated with the matrix A′ have the form
  



0
0
0
,
···,
(14.54)
r0
Sr0
S m−1 r0
and the associated approximate solution will be of the form



   −1

x0
xm
0
B
−B −1 E
Pm−1
+
=
i
O
I
y
ym
i=0 αi S r0
 0−1
−1
B (f − Ey0 ) − B E(ym − y0 )
=
ym
 −1

B (f − Eym )
=
.
ym
Finally, the scalars αi that express the approximate solution in the Krylov basis are
obtained implicitly via inner products of vectors among the vector sequence (14.54).
These inner products are identical to those of the sequence r0 , Sr0 , · · · , S m−1 r0 .
Therefore, these coefficients will achieve the same result as the same Krylov method
applied to the reduced system Sy = g′ , if the initial guess gives the residual guess
r0 .
A version of this proposition should allow S to be preconditioned. The following
result is an immediate extension that achieves this goal.
Proposition 14.12 Let S = LS US − R be an approximate factorization of S and
define




I
O
B E
LA =
, UA =
.
(14.55)
F B −1 LS
O US

14.5. FULL MATRIX METHODS

503

Assume that a Krylov subspace method is applied to the original system (14.1) with
left preconditioning LA and right preconditioning UA , and with an initial guess of
the form
   −1

x0
B (f − Ey0 )
=
.
(14.56)
y0
y0

Then this preconditioned Krylov iteration will produce iterates of the form

  −1

xm
B (f − Eym )
=
.
ym
ym

(14.57)

Moreover, the sequence ym is the result of the same Krylov subspace method applied
to the reduced linear system Sy = g − F B −1 f , left preconditioned with LS , right
preconditioned with US , and starting with the vector y0 .
Proof. The proof starts with the equality

 

I
I
O
B E
=
O
F B −1 LS
F C

O
−1
L−1
S SUS



B
O

E
US



.

(14.58)

The rest of the proof is similar to that of the previous result and is omitted.
Also there are two other versions in which S is allowed to be preconditioned
from the left or from the right. Thus, if MS is a certain preconditioner for S, use the
following factorizations






B E
I
O
I
O
B E
=
(14.59)
F C
F B −1 MS
O MS−1 S
O I




I
O
B E
I
O
=
, (14.60)
F B −1 I
O MS
O SMS−1
to derive the appropriate left or right preconditioners. Observe that when the preconditioner MS to S is exact, i.e., when M = S, then the block preconditioner LA , UA
to A induced from MS is also exact.
Although the previous results indicate that a Preconditioned Schur Complement
iteration is mathematically equivalent to a certain preconditioned full matrix method,
there are some practical benefits in iterating with the nonreduced system. The main
benefit involves the requirement in the Schur Complement techniques to compute Sx
exactly at each Krylov subspace iteration. Indeed, the matrix S represents the coefficient matrix of the linear system, and inaccuracies in the matrix-by-vector operation
may result in loss of convergence. In the full matrix techniques, the operation Sx is
never needed explicitly. In addition, this opens up the possibility of preconditioning
the original matrix with approximate solves with the matrix B in the preconditioning
operation LA and UA .

504

14.6

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

Graph Partitioning

The very first task that a programmer faces when solving a problem on a parallel
computer, be it a dense or a sparse linear system, is to decide how to subdivide and
map the data into the processors. Distributed memory computers allow mapping the
data in an arbitrary fashion but this added flexibility puts the burden on the user to
find good mappings. When implementing Domain Decomposition - type ideas on a
parallel computer, efficient techniques must be available for partitioning an arbitrary
graph. This section gives an overview of the issues and covers a few techniques.

14.6.1

Basic Definitions

Consider a general sparse linear system whose adjacency graph is G = (V, E).
Graph partitioning algorithms aim at subdividing the original linear system into
smaller sets of equations which will be assigned to different processors for their
parallel solution.
This translates into partitioning the graph intp p subgraphs, with the underlying
goal to achieve a good load balance of the work among the processors as well as
ensure that the ratio of communication over computation is small for the given task.
We begin with a general definition.
Definition 14.13 We call a map of V , any set V1 , V2 , . . . , Vs , of subsets of the vertex
set V , whose union is equal to V :
[
Vi = V.
Vi ⊆ V,
i=1,s

When all the Vi subsets are disjoint, the map is called a proper partition; otherwise
we refer to it as an overlapping partition.
The most general way to describe a node-to-processor mapping is by setting up
a list for each processor, containing all the nodes that are mapped to that processor.
Three distinct classes of algorithms have been developed for partitioning graphs. An
overview of each of these three approaches is given next.

9

10

11

P3
5

P4
6

7

2

3

P1
1

12

8

P2
4

Figure 14.9: Mapping of a simple 4 × 3 mesh to 4 processors.

14.6. GRAPH PARTITIONING

14.6.2

505

Geometric Approach

The geometric approach works on the physical mesh and requires the coordinates of
the mesh points. In the simplest case, for a 2-dimensional rectangular grid, stripes in
the horizontal and vertical direction can be defined to get square subregions which
have roughly the same number of points. Other techniques utilize notions of moment
of inertia to divide the region recursively into two roughly equal-sized subregions.
Next is a brief description of a technique based on work by Miller, Teng, Thurston, and Vavasis [211]. This technique finds good separators for a mesh using projections into a higher space. Given a mesh in Rd , the method projects the mesh points
into a unit sphere centered at the origin in Rd+1 . Stereographic projection is used: A
line is drawn from a given point p in the plane to the North Pole (0, . . . , 0, 1) and the
stereographic projection of p is the point where this line intersects the sphere. In the
next step, a centerpoint of the projected points is found. A centerpoint c of a discrete
set S is defined as a point where every hyperplane passing through c will divide S
approximately evenly.
Once the centerpoint is found, the points of the sphere are rotated so that the
centerpoint is aligned with the North Pole, i.e., so that coordinates of c are transformed into (0, . . . , 0, r). The points are further transformed by dilating them so that
the centerpoint becomes the origin. Through all these transformations, the point c
remains a centerpoint. Therefore, if any hyperplane is taken that passes through the
centerpoint which is now the origin, it should cut the sphere into two roughly equalsized subsets. Any hyperplane passing through the origin will intersect the sphere
along a large circle C. Transforming this circle back into the original space will give
a desired separator. Notice that there is an infinity of circles to choose from.
One of the main ingredients in the above algorithm is a heuristic for finding
centerpoints in Rd space (actually, Rd+1 in the algorithm). The heuristic that is used
repeatedly replaces randomly chosen sets of d + 2 points by their centerpoint, which
are easy to find in this case. There are a number of interesting results that analyze
the quality of geometric graph partitionings based on separators. With some minimal
assumptions on the meshes, it is possible to show that there exist “good” separators.
In addition, the algorithm discussed above constructs such separators. We start with
two definitions.
Definition 14.14 A k-ply neighborhood system in Rd is a set of n closed disks Di ,
i = 1, . . . , n in Rd such that no point in Rd is (strictly) interior to more than k disks.
Definition 14.15 Let α ≥ 1 and let D1 , . . . , Dn be a k-ply neighborhood system in
Rd . The (α, k)-overlap graph for the neighborhood system is the graph with vertex
set V = {1, 2, . . . , n} and edge set, the subset of V × V defined by
{(i, j) : (Di ∩ (α.Dj ) 6= φ) and (Dj ∩ (α.Di ) 6= φ)}.
A mesh in Rd is associated with an overlap graph by assigning the coordinate of the
center ci of disk i to each node i of the graph. Overlap graphs model computational
meshes in d dimensions. Indeed, every mesh with bounded aspect ratio elements

506

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

(ratio of largest to smallest edge length of each element) is contained in an overlap
graph. In addition, any planar graph is an overlap graph. The main result regarding
separators of overlap graphs is the following theorem [211].
Theorem 14.16 Let G be an n-vertex (α, k) overlap graph in d dimensions. Then
the vertices of G can be partitioned into three sets A, B, and C such that:
1. No edge joins A and B.
2. A and B each have at most n(d + 1)/(d + 2) vertices.
3. C has only O(α k1/d n(d−1)/d ) vertices.
Thus, for d = 2, the theorem states that it is possible to partition the graph into two
subgraphs A and B, with a separator C, such that the number of nodes for each of A
and B does not exceed 34 n vertices in the worst case and such that the separator has
a number of nodes of the order O(α k1/2 n1/2 ).

14.6.3

Spectral Techniques

Spectral bisection refers to a technique which exploits some known properties of the
eigenvectors of the Laplacean of a graph. Given an adjacency graph G = (V, E),
we associate to it a Laplacian matrix L which is a sparse matrix having the same
adjacency graph G and defined as follows:

if(vi , vj ) ∈ E and i 6= j
 −1
deg(i) if i = j
lij =

0
otherwise.

These matrices have some interesting fundamental properties. When the graph is
undirected L is symmetric. It can be shown to be also negative semi definite (see
Exercise 11). Zero is an eigenvalue and it is the smallest one. An eigenvector associated with this eigenvalue is any constant vector, and this eigenvector bears little
interest. The second smallest eigenvector, called the Fiedler vector, has the useful
property that the signs of its components divide the domain into roughly two equal
subdomains.
The Recursive Spectral Bisection (RSB) algorithm consists of sorting the components of the Fiedler vector and assigning the first half of the sorted vertices to
the first subdomain and the second half to the second subdomain. The two subdomains are then partitioned in two recursively, until a desirable number of domains is
reached.
A LGORITHM 14.7 RSB (Recursive Spectral Bisection)

1.
2.
3.
4.
5.

Compute the Fiedler vector f of the graph G.
Sort the components of f , e.g., increasingly.
Assign first ⌊n/2⌋ nodes to V1 , and the rest to V2 .
Apply RSB recursively to V1 , V2 , until the desired number of partitions
is reached.

14.6. GRAPH PARTITIONING

507

The main theoretical property that is exploited here is that the differences between the components of the Fiedler vector represent some sort of distance between
the corresponding nodes. Thus, if these components are sorted they would be effectively grouping the associated node by preserving nearness. Another interesting fact
is that the algorithm will also tend to minimize the number nc of edge-cuts, i.e., the
number of edges (vi , vj ) such that vi ∈ V1 and vj ∈ V2 . Assume that V1 and V2
are of equal size and define a partition vector define p whose i-th component is +1
if vi ∈ V1 , and −1 if vi ∈ V2 . By the assumptions the sum of all pi ’s is zero. Then
notice that
(Lp, p) = 4nc , (p, e) = 0.
Ideally, the objective function (Lp, p) should be minimized subject to the constraint
(p, e) = 0. Here p is a vector of signs. If, instead, the objective function (Lx, x)/(x, x)
were minimized for x real, subject to (x, e) = 0, the solution would be the Fiedler
vector, since e is the eigenvector associated with the eigenvalue zero. The Fiedler
vector can be computed by the Lanczos algorithm or any other method efficient for
large sparse matrices. Recursive Specrtal Bisection gives excellent partitionings. On
the other hand, it is rather unattractive because it requires computing an eigenvector.

14.6.4

Graph Theory Techniques

A number of other techniques exist which, like spectral techniques, are also based
on the adjacency graph only. The simplest idea is one that is borrowed from the
technique of nested dissection in the context of direct sparse solution methods, see
Sections 3.6.2 and 3.3.3. An initial node is given which constitutes the level zero.
Then, the method recursively traverses the k-th level (k ≥ 1), which consists of the
neighbors of all the elements that constitute level k−1. A simple idea for partitioning
the graph in two traverses enough levels to visit about half of all the nodes. The
visited nodes will be assigned to one subdomain and the others will constitute the
second subdomain. The process can then be repeated recursively on each of the
subdomains.
A key ingredient for this technique to be successful is to determine a good initial
node from which to start the traversal. Often, a heuristic is used for this purpose.
Recall that d(x, y) is the distance between vertices x and y in the graph, i.e., the
length of the shortest path between x and y.
If the diameter of a graph is defined as
δ(G) = max{d(x, y) | x ∈ V, y ∈ V }
then, ideally, one of two nodes in a pair (x, y) that achieves the diameter can be used
as a starting node. These peripheral nodes, are expensive to determine. Instead, a
pseudo-peripheral node, as defined through the following procedure, is often employed [144]

508

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

Figure 14.10: The RGB algorithm (top) and the double-striping algorithm (bottom)
for partitioning a graph into 16 subgraphs.

14.6. GRAPH PARTITIONING

509

A LGORITHM 14.8 Pseudo-Peripheral Node

1.
2.
3.
4.
5.
6.
7.
8.

Select an initial node x. Set δ = 0.
Do a level set traversal from x
Select a node y in the last level set, with minimum degree
If d(x, y) > δ then
Set x := y and δ := d(x, y)
GoTo 2
Else Stop: x is a pseudo-peripheral node.
EndIf

The distance d(x, y) in line 5 is the number of levels in the level set traversal needed
in Step 2. The algorithm traverses the graph from a node of the last level in the
previous traversal, until the number of levels stabilizes. It is easy to see that the
algorithm does indeed stop after a finite number of steps, typically small.
A first heuristic approach based on level set traversals is the recursive dissection
procedure mentioned above and described next.
A LGORITHM 14.9 Recursive Graph Bisection

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

Set G∗ := G, S := {G}, ndom := 1
While ndom < s Do:
Select in S the subgraph G∗ with largest size.
Find a pseudo-peripheral node p in G∗ and
Do a level set traversal from p. Let lev := number of levels.
Let G1 the subgraph of G∗ consisting of the first lev/2
levels, and G2 the subgraph containing the rest of G∗ .
Remove G∗ from S and add G1 and G2 to it
ndom := ndom + 1
EndWhile

The cost of this algorithm is rather small. Each traversal of a graph G = (V, E) costs
around |E|, where |E| is the number of edges (assuming that |V | = O(|E|)). Since
there are s traversals of graphs whose size decreases by 2 at each step, it is clear that
the cost is O(|E|), the order of edges in the original graph. As can be expected, the
results of such an algorithm are not always good. Typically, two qualities that are
measured are the sizes of the domains as well as the number of edge-cuts.
Ideally, the domains should be equal. In addition, since the values at the interface
points should be exchanged with those of neighboring processors, their total number,
as determined by the number of edge-cuts, should be as small as possible. The first
measure can be easily controlled in a recursive Graph Bisection Algorithm — for
example, by using variants in which the number of nodes is forced to be exactly half
that of the original subdomain. The second measure is more difficult to control.
As an example, the top part of Figure 14.10 shows the result of the RGB algorithm on a sample finite-element mesh. Thus, the top part of Figure 14.10 shows the
result of the RGB algorithm on a sample finite-element mesh. This is a vertex-based
partitioning. The dashed lines represent the edge-cuts.

510

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

An approach that is competitive with the one described above is that of double striping. This method uses two parameters p1 , p2 such that p1 p2 = s. The
original graph is first partitioned into p1 large partitions, using one-way partitioning, then each of these partitions is subdivided into p2 partitions similarly. Oneway partitioning into p subgraphs consists of performing a level set traversal from a
pseudo-peripheral node and assigning each set of roughly n/p consecutive nodes in
the traversal to a different subgraph. The result of this approach with p1 = p2 = 4 is
shown in Figure 14.10 on the same graph as before.
As can be observed, the subregions obtained by both methods have elongated
and twisted shapes. This has the effect of giving a larger number of edge-cuts. There
are a number of heuristic ways to remedy this. One strategy is based on the fact that
a level set traversal from k nodes can be defined instead of only one node. These k
nodes are called the centers or sites. Each subdomain will expand from one of these
k centers and the expansion will stop when it is no longer possible to acquire another
point that is not already assigned. The boundaries of each domain that are formed this
way will tend to be more “circular.” To smooth the boundaries of an initial partition,
find some center point of each domain and perform a level set expansion from the set
of points. The process can be repeated a few times.
A LGORITHM 14.10 Multinode Level-Set Expansion Algorithm

1.
2.
3.
4.
5.
6.
7.
8.
9.

Find a partition S = {G1 , G2 , . . . , Gs }.
For iter = 1, . . . , nouter Do:
For k = 1, . . . , s Do:
Find a center ck of Gk . Set label(ck ) = k.
EndDo
Do a level set traversal from {c1 , c2 , . . . , cs }. Label each child
in the traversal with the same label as its parent.
For k = 1, . . . , s set Gk := subgraph of all nodes having label k
EndDo

For this method, a total number of edge-cuts equal to 548 and a rather small
standard deviation of 0.5 are obtained for the example seen earlier. Still to be decided
is how to select the center nodes mentioned in line 4 of the algorithm. Once more,
the pseudo-peripheral algorithm will be helpful. Find a pseudo-peripheral node, then
do a traversal from it until about one-half of the nodes have been traversed. Then,
traverse the latest level set (typically a line or a very narrow graph), and take the
middle point as the center.
A typical number of outer steps, nouter, to be used in line 2, is less than five.
This heuristic works well in spite of its simplicity. For example, if this is applied to
the graph obtained from the RGB algorithm, with nouter = 3, the partition shown
in Figure 14.11 is obtained. With this technique, the resulting total number of edgecuts is equal to 441 and the standard deviation is 7.04. As is somewhat expected, the
number of edge-cuts has decreased dramatically, while the standard deviation of the
various sizes has increased.

14.6. GRAPH PARTITIONING

511

Figure 14.11: Multinode expansion starting with the partition obtained in Figure
14.10.

P ROBLEMS
P-14.1 In the proof of Theorem 14.7, the following form of the Cauchy-Schwarz inequality
was used:
!1/2
!1/2
p
p
p
X
X
X
(yi , yi )
(xi , xi )
.
(xi , yi ) ≤
i=1

i=1

i=1

(a) Prove that this result is a consequence of the standard Cauchy-Schwarz inequality. (b)
Extend the result to the A-inner product. (c) Assume that the xi ’s and yi ’s are the columns
of two n × p matrix X and Y . Rewrite the result in terms of these matrices.
P-14.2 Using Lemma 14.4, write explicitly the vector M −1 b for the Multiplicative Schwarz
procedure, in terms of the matrix A and the Ri ’s, when s = 2, and then when s = 3.
P-14.3 Justify Algorithm (14.5), i.e., show that it does indeed compute the vector M −1 Av
for an input vector v, where M is the multiplicative Schwarz preconditioner. Then find a
similar algorithm which computes AM −1 v (right preconditioning).
P-14.4
P-14.5 (a) Show that in the multiplicative Schwarz procedure, the residual vectors ri =
b − Axi obtained at each step satisfy the recurrence,
ri = ri−1 − ARiT A−1
i Ri ri−1

512

CHAPTER 14. DOMAIN DECOMPOSITION METHODS

for i = 1, . . . , s. (b) Consider the operator Qi ≡ ARiT A−1
i Ri . Show that Qi is a projector.
(c) Is Qi an orthogonal projector with respect to the A-inner product? With respect to which
inner product is it orthogonal?
P-14.6 The analysis of the Additive Schwarz procedure assumes that A−1
is “exact,” i.e.,
i
that linear systems Ai x = b are solved exactly, each time A−1
is
applied.
Assume
that A−1
i
i
−1
is replaced by some approximation Θi . (a) Is Pi still a projector? (b) Show that if Θi is
Symmetric Positive Definite, then so is Pi . (c) Now make the assumption that λmax (Pi ) ≤
ω∗ . What becomes of the result of Theorem 14.5?
P-14.7 In Element-By-Element (EBE) methods, the extreme cases of the Additive or the
Multiplicative Schwarz procedures are considered in which the subdomain partition corresponds to taking Ωi to be an element. The advantage here is that the matrices do not have to
be assembled. Instead, they are kept in unassembled form (see Chapter 2). Assume that Poisson’s equation is being solved. (a) What are the matrices Ai ? (b) Are they SPD? (c) Write
down the EBE preconditioning corresponding to the multiplicative Schwarz procedure, its
multicolor version, and the additive Schwarz procedure.
P-14.8 Theorem 14.2 was stated only for the multiplicative version of the Schwarz procedure. There is a similar result for the additive Schwarz procedure. State this result and prove
it.
P-14.9 Show that the matrix defined by (14.38) is indeed a projector. Is it possible to formulate Schwarz procedures in terms of projection processes as seen in Chapter 5?
P-14.10 It was stated at the end of the proof of Theorem 14.7 that if
(AJ u, u)A ≥

1
(u, u)A
C

for any nonzero u, then λmin (AJ ) ≥ C1 . (a) Prove this result without invoking the min-max
theory. (b) Prove a version of the min-max theorem with the A-inner product, i.e., prove that
the min-max theorem is valid for any inner product for which A is self-adjoint.
P-14.11 Consider the Laplacean of a graph as defined in Section 14.6. Show that
X
(xi − xj )2 .
(Lx, x) =
(i,j) ∈ E

P-14.12 Consider a rectangular finite difference mesh, with mesh size ∆x = h in the xdirection and ∆y = h closest to the y-direction.
a. To each mesh point p = (xi , yj ), associate the closed disk Dij of radius h centered at
pi . What is the smallest k such that the family {Dij } is a k-ply system?
b. Answer the same question for the case where the radius is reduced to h/2. What is the
overlap graph (and associated mesh) for any α such that
√
1
2
<α<
?
2
2
What about when α = 2?
P-14.13 Determine the cost of a level set expansion algorithm starting from p distinct centers.
P-14.14 Write recursive versions of the Recursive Graph Partitioning algorithm and Recursive Spectral Bisection algorithm. [Hint: Recall that a recursive program unit is a subprogram or function, say foo, which calls itself, so foo is allowed to make a subroutine call to

14.6. GRAPH PARTITIONING

513

foo within its body.] (a) Give a pseudo-code for the RGB algorithm which processes the
subgraphs in any order. (b) Give a pseudo-code for the RGB algorithm case when the larger
subgraph is to be processed before the smaller one in any dissection. Is this second version
equivalent to Algorithm 14.9?
P-14.15 Write a FORTRAN-90 subroutine or (C function) which implements the Recursive
Graph Partitioning algorithm.
N OTES AND R EFERENCES . To start with, the original paper by Schwarz is the reference [261], but an
earlier note appeared in 1870. In recent years, research on Domain Decomposition techniques has been
very active and productive. This rebirth of an old technique has been in large part motivated by parallel
processing. However, the first practical use of Domain Decomposition ideas has been in applications
to very large structures; see [230, 41], and elasticity problems; see, e.g., [234, 283, 269, 76, 40] for
references.
The book by Smith, Bjørstad, and Gropp, [268] gives a thorough survey of domain decomposition
methods. Two other monographs, one by P. Le Tallec [198], and the other by C. Farhat and J. X.
Roux [123], describe the use of Domain Decomposition approaches specifically for solving problems in
structural mechanics. Survey papers include those by Keyes and Gropp [189] and by Chan and Matthew
[75]. The volume [190] discusses the various uses of “domain-based” parallelism in computational
sciences and engineering.
The bulk of recent work on Domain Decomposition methods has been geared toward a Partial
Differential Equations viewpoint. Often, there appears to be a dichotomy between this viewpoint and
that of “applied Domain Decomposition,” in that the good methods from a theoretical point of view are
hard to implement in practice. The additive Schwarz procedure, with overlapping, represents a compromise between good intrinsic properties and ease of implementation. For example, Venkatakrishnan
concludes in [295] that although the use of global coarse meshes may accelerate convergence of local,
domain-based, ILU preconditioners, it does not necessarily reduce the overall time to solve a practical
aerodynamics problem.
Much is known about the convergence of the Schwarz procedure; refer in particular to the work by
Widlund and co-authors [42, 102, 103, 104, 70]. The convergence results of Section 14.3.4 have been
adapted from Xu [320] as well as Hackbusch [163]. The result on the equivalence between Schwarz
and Schur complement iterations stated in Theorem 14.2 seems to have been originally proved by Chan
and Goovaerts [73], see also the more recent article by Wilders and Brakkee [315]. The results on
the equivalence between the full matrix techniques and the Schur matrix techniques seen in Section
14.5 have been adapted from results by S. E. Eisenstat, reported in [189]. These connections are rather
interesting and useful in practice since they provide some flexibility on ways to implement a method.
A number of preconditioners have also been derived using similar connections in the PDE framework
[48, 47, 49, 50, 51].
Research on graph partitioning has slowed in recent years, no doubt due to the appearance of
Metis, a well-designed and efficient graph partitioning code [185]. Variations of the Recursive Spectral
Bisection algorithm [229] seem to give the best results in terms of overall quality of the subgraphs.
However, the algorithm is rather expensive, and the less costly multilevel techniques such as the ones
in the codes Metis [185] and Chaco [166], are usually preferred. The description of the geometric
partitioning techniques in Section 14.6.2 is based on the papers [145] and [211]. Earlier approaches
have been developed in [81, 82, 83].

Bibliography
[1] J. A BAFFY AND E. S PEDICATO, ABS Projection Methods, Halstead Press, 1989.
[2] L. M. A DAMS, Iterative algorithms for large sparse linear systems on parallel computers, PhD thesis, Applied Mathematics, University of Virginia, Charlottsville, VA,
1982. Also NASA Contractor Report 166027.
[3] L. M. A DAMS AND H. J ORDAN, Is SOR color-blind?, SIAM Journal on Scientific
and Statistical Computing, 6 (1985), pp. 490–506.
[4] L. M. A DAMS AND J. O RTEGA, A multi-color SOR Method for Parallel Computers,
in Proceedings of the 1982 International Conference on Pararallel Processing, 1982,
pp. 53–56.
[5] J. I. A LIAGA , D. L. B OLEY, R. W. F REUND , AND V. H ERN ÁNDEZ, A Lanczos-type
algorithm for multiple starting vectors, Tech. Rep. Numerical Analysis Manuscript
No 95-11, AT&T Bell Laboratories, Murray Hill, NJ, 1995.
[6] F. L. A LVARADO, Manipulation and visualization of sparse matrices, ORSA Journal
on Computing, 2 (1990), pp. 186–206.
[7] E. C. A NDERSON, Parallel implementation of preconditioned conjugate gradient
methods for solving sparse systems of linear equations, Tech. Rep. 805, CSRD, University of Illinois, Urbana, IL, 1988. MS Thesis.
[8] E. C. A NDERSON AND Y. S AAD, Solving sparse triangular systems on parallel computers., International Journal of High Speed Computing, 1 (1989), pp. 73–96.
[9] W. E. A RNOLDI, The principle of minimized iteration in the solution of the matrix
eigenvalue problem, Quart. Appl. Math., 9 (1951), pp. 17–29.
[10] C. C. A SHCRAFT AND R. G. G RIMES, On vectorizing incomplete factorization
and SSOR preconditioners, SIAM Journal on Scientific and Statistical Computing,
9 (1988), pp. 122–151.
[11] O. A XELSSON, A generalized SSOR method, BIT, 12 (1972), pp. 443–467.
[12]

, Conjugate gradient type-methods for unsymmetric and inconsistent systems of
linear equations, Linear Algebra and its Applications, 29 (1980), pp. 1–16.

[13]

, A generalized conjugate gradient, least squares method, Numerische Mathematik, 51 (1987), pp. 209–227.

[14]

, Iterative Solution Methods, Cambridge University Press, New York, 1994.

[15] O. A XELSSON AND V. A. BARKER, Finite Element Solution of Boundary Value Problems, Academic Press, Orlando, FL, 1984.

515

516

BIBLIOGRAPHY

[16] O. A XELSSON , S. B RINKKEMPER , AND V. P. I LL’ N, On some versions of incomplete
block-matrix factorization iterative methods, Linear Algebra and its Applications, 58
(1984), pp. 3–15.
[17] O. A XELSSON AND M. N EYTCHEVA, Algebraic multilevel iteration method for stieltjes matrices, Numer. Linear Algebra Appl., 1 (1994), pp. 213–236.
[18] O. A XELSSON AND B. P OLMAN, A robust preconditioner based on algebraic substructuring and two-level grids, in Robust multigrid methods. Proc., Kiel, Jan. 1988.,
W. Hackbusch, ed., Notes on Numerical Fluid Mechanics, Volume 23, Vieweg, Braunschweig, 1988, pp. 1–26.
[19] O. A XELSSON AND P. VASSILEVSKI, Algebraic multilevel preconditioning methods.
I, Numer. Math., 56 (1989), pp. 157–177.
[20]

, A survey of multilevel preconditioned iterative methods, BIT, 29 (1989),
pp. 769–793.

[21]

, Algebraic multilevel preconditioning methods. II, SIAM J. Numer. Anal., 27
(1990), pp. 1569–1590.

[22] O. A XELSSON AND P. S. VASSILEVSKI, A block generalized conjugate gradient
solver with inner iterations and variable step preconditioning, SIAM Journal on Matrix Analysis and Applications, 12 (1991).
[23] N. S. BAKHVALOV, On the convergence of a relaxation method with natural constraints on the elliptic operator, U.S.S.R Computational Math. and Math. Phys., 6
(1966), pp. 101–135.
[24] S. BALAY, W. D. G ROPP, L. C. M C I NNES , AND B. F. S MITH, PETSc 2.0 users manual, Tech. Rep. ANL-95/11 - Revision 2.0.24, Argonne National Laboratory, 1999.
[25] R. BANK , T. D UPONT, AND H. Y SERENTANT, The hierarchical basis multigrid
method, Numer. Math., 52 (1988), pp. 427–458.
[26] R. BANK AND J. X U, The hierarchical basis multigrid method and incomplete LU
decomposition, tech. rep., U.C. San Diego, Dept. of Math., 1994.
[27] R. E. BANK AND T. F. C HAN, An analysis of the composite step biconjugate gradient
method, Numerische Mathematik, 66 (1993), pp. 259–319.
[28] R. E. BANK AND C. WAGNER, Multilevel ILU decomposition, Numerische Mathematik, 82 (1999), pp. 543–576.
[29] T. BARTH AND T. M ANTEUFFEL, Variable metric conjugate gradient methods, in
Advances in Numerical Methods for Large Sparse Sets of Linear Equations, Number
10, Matrix Analysis and Parallel Computing, PCG 94, Keio University, Yokohama,
Japan, 1994, pp. 165–188.
[30] D. BAXTER , J. S ALTZ , M. H. S CHULTZ , S. C. E ISENSTAT, AND K. C ROWLEY, An
experimental study of methods for parallel preconditioned Krylov methods, in Proceedings of the 1988 Hypercube Multiprocessors Conference, Pasadena, CA, Jan.
1988, pp. 1698–1711.
[31] M. B ENANTAR AND J. E. F LAHERTY, A six color procedure for the parallel solution of Elliptic systems using the finite quadtree structure, in Proceedings of the
Fourth SIAM Conference on Parallel Processing for Scientific Computing, J. Dongarra, P. Messina, D. C. Sorenson, and R. G. Voigt, eds., 1990, pp. 230–236.

BIBLIOGRAPHY

517

[32] M. B ENZI , J. C. H AWS , AND M. T UMA, Preconditioning highly indefinite and nonsymmetric matrices, SIAM Journal on Scientific Computing, 22 (2000), pp. 1333–
1353.
[33] M. B ENZI , J. M AR ÍN , AND M. T ŮMA, A two-level parallel preconditioner based on
sparse approximate inverses, in Iterative Methods in Scientific Computation, II, D. R.
Kincaid and A. C. Elster, eds., IMACS, 1999, pp. xx–xx+10.
[34] M. B ENZI , C. D. M EYER , AND M. T ŮMA, A sparse approximate inverse preconditioner for the conjugate gradient method, SIAM Journal on Scientific Computing, 17
(1996), pp. 1135–1149.
[35] M. B ENZI , D. B. S ZYLD , AND A. VAN D UIN, Orderings for incomplete factorizations of nonsymmtric matrices, SIAM Journal on Scientific Computing, 20 (1999),
pp. 1652–1670.
[36] M. B ENZI AND M. T ŮMA, A sparse approximate inverse preconditioner for nonsymmetric linear systems, SIAM Journal on Scientific Computing, 19 (1998), pp. 968–
994.
[37] H. B ERRYMAN , J. S ALTZ , W. G ROPP, AND R. M IRCHANDANEY, Krylov methods
preconditioned with incompletely factored matrices on the CM-2, Journal of Parallel
and Distributed Computing, 8 (1990), pp. 186–190.
[38] G. B IRKHOFF , R. S. VARGA , AND D. M. YOUNG, Alternating direction implicit
methods, in Advances in Computers, F. Alt and M. Rubinov, eds., New York, 1962,
Academic Press, pp. 189–273.
[39] A. B J ÖRCK AND T. E LFVING, Accelerated projection methods for computing pseudoinverse solutions of systems of linear equations, BIT, 19 (1979), pp. 145–163.
[40] P. E. B JØRSTAD AND A. H VIDSTEN, Iterative methods for substructured elasticity
problems in structural analysis, in Domain Decomposition Methods for Partial Differential Equations, R. Glowinski, G. H. Golub, G. A. Meurant, and J. Périaux, eds.,
Philadelphia, PA, 1988, SIAM.
[41] P. E. B JØRSTAD AND O. B. W IDLUND, Solving elliptic problems on regions partitioned into substructures, in Elliptic Problem Solvers II, G. Birkhoff and A. Schoenstadt, eds., New York, NY, 1984, Academic Press, pp. 245–256.
[42]

, Iterative methods for the solution of elliptic problems on regions partitioned
into substructures, SIAM Journal on Numerical Analysis, 23 (1986), pp. 1093–1120.

[43] E. B ODEWIG, Matrix Calculus, North-Holland, Amsterdam, 1956.
[44] M. B OLLH ÖFER, A robust ILU with pivoting based on monitoring the growth of the
inverse factors, Linear Algebra and its Applications, 338 (2001), pp. 201–213.
[45] E. B OTTA , A. P LOEG , AND F. W UBS, Nested grids ILU-decomposition (NGILU), J.
Comp. Appl. Math., 66 (1996), pp. 515–526.
[46] H. B RAKHAGE, Über die numerische Behandlung von integralgleichungen nach der
Quadratureformelmethode, Numerische Mathematik, 2 (1960), pp. 183–196.
[47] J. H. B RAMBLE , J. E. PASCIAK , AND A. H. S CHATZ, The construction of preconditioners for elliptic problems by substructuring, I, Mathematics of Computation, 47
(1986), pp. 103–134.

518

BIBLIOGRAPHY

[48]

, An iterative method for elliptic problems on regions partitioned into substructures, Mathematics of Computation, 46 (1986), pp. 361–369.

[49]

, The construction of preconditioners for elliptic problems by substructuring, II,
Mathematics of Computation, 49 (1987), pp. 1–16.

[50]

, The construction of preconditioners for elliptic problems by substructuring, III,
Mathematics of Computation, 51 (1988), pp. 415–430.

[51]

, The construction of preconditioners for elliptic problems by substructuring, IV,
Mathematics of Computation, 53 (1989), pp. 1–24.

[52] R. B RAMLEY AND A. S AMEH, Row projection methods for large nonsymmetric
linear systems, SIAM Journal on Scientific and Statistical Computing, 13 (1992),
pp. 168–193.
[53]

, A robust parallel solver for block tridiagonal systems, in Proceedings of the
International Conference on Supercomputing, ACM, July 1988, pp. 39–54.

[54] A. B RANDT, Multi-level adaptive technique (MLAT) for fast numerical solutions to
boundary problems., in Proc. 3rd Int. Conf. Numer. Methods in Fluid Mechanics,
Paris, 1972, H. Cabannes and R. Temam, eds., Berlin, 1973, Springer Verlag, pp. 82–
89.
[55]

, Multi-level adaptive solutions to boundary value problems, Mathematics of
Computation, 31 (1977), pp. 333–390.

[56]

, A guide to multigrid development, in Multigrid methods, W. Hackbusch and
U. Trottenberg, eds., Berlin, 1982, Springer Verlag, pp. 220–312.

[57]

, Algebraic multigrid theory: The symmetric case, Appl. Math. Comp., 19
(1985).

[58] A. B RANDT, S. F. M C C ORMICK , AND J. RUGE, Algebraic multigrid (amg) for
sparse matrix equations, in Sparsity and its applications, D. J. Evans, ed., Cambridge,
1984, Cambridge Univ. Press.
[59] C. B REZINSKI, Padé Type Approximation and General Orthogonal Polynomials,
Birkhäuser-Verlag, Basel-Boston-Stuttgart, 1980.
[60] C. B REZINSKI AND M. R EDIVO Z AGLIA, Extrapolation Methods: Theory and Practice, North-Holland, Amsterdam, 1991.
[61] C. B REZINSKI AND M. R EDIVO -Z AGLIA, Hybrid procedures for solving systems of
linear equations, Numerische Mathematik, 67 (1994), pp. 1–19.
[62] C. B REZINSKI , M. R EDIVO -Z AGLIA , AND H. S ADOK, Avoiding breakdown
and near-breakdown in Lanczos-type algorithms, Numerical Algorithms, 1 (1991),
pp. 261–284.
[63]

, A breakdown-free Lanczos-type algorithm for solving linear systems, Numerische Mathematik, 63 (1992), pp. 29–38.

[64] R. B RIDSON AND W. P. TANG, Ordering, anisotropy, and factored sparse approximate inverses, SIAM Journal on Scientific Computing, 21 (1999).
[65] W. L. B RIGGS , V. E. H ENSON , AND S. F. M C C ORMICK, A multigrid tutorial,
SIAM, Philadelphia, PA, 2000. Second edition.

BIBLIOGRAPHY

519

[66] P. N. B ROWN, A theoretical comparison of the Arnoldi and GMRES algorithms,
SIAM Journal on Scientific and Statistical Computing, 12 (1991), pp. 58–78.
[67] P. N. B ROWN AND A. C. H INDMARSH, Matrix-free methods for stiff systems of
ODEs, SIAM Journal on Numerical Analysis, 23 (1986), pp. 610–638.
[68] N. I. B ULEEV, A numerical method for the solution of two-dimensional and threedimensional equations of diffusion, Math. Sb, 51 (1960), pp. 227–238. (in Russian).
[69] O. B UNEMAN, A compact non-iterative Poisson solver, Tech. Rep. 294, Stanford University, Stanford, CA, 1969.
[70] X. C. C AI AND O. W IDLUND, Multiplicative Schwarz algorithms for some nonsymmetric and indefinite problems, SIAM Journal on Numerical Analysis, 30 (1993).
[71] L. C ESARI, Sulla risoluzione dei sistemi di equazioni lineari per approssimazioni
successive, Atti Accad. Naz. Lincei Rend. Cl. Sci. Fis. Mat. Nat., Ser. 6a, 25 (1937),
pp. 422–428.
[72] T. F. C HAN , E. G ALLOPOULOS , V. S IMONCINI , T. S ZETO , AND C. T ONG, A quasiminimal residual variant of the Bi-CGSTAB algorithm for nonsymmetric systems,
SIAM Journal on Scientific Computing, 15 (1994), pp. 338–347.
[73] T. F. C HAN AND D. G OOVAERTS, On the relationship between overlapping and
nonoverlapping domain decomposition methods, SIAM Journal on Matrix Analysis
and Applications, 13 (1992), pp. 663–670.
[74] T. F. C HAN AND T. P. M ATHEW, The interface probing technique in domain decomposition, SIAM Journal on Matrix Analysis and Applications, 13 (1992), pp. 212–238.
[75]

, Domain decomposition algorithms, Acta Numerica, (1994), pp. 61–143.

[76] H. C. C HEN AND A. S AMEH, A matrix decomposition method for orthotropic elasticity problems, SIAM Journal on Matrix Analysis and Applications, 10 (1989), pp. 39–
64.
[77] C. C. C HENEY, Introduction to Approximation Theory, McGraw Hill, NY, 1966.
[78] E. C HOW AND Y. S AAD, Approximate inverse techniques for block-partitioned matrices, SIAM Journal on Scientific Computing, 18 (1997), pp. 1657–1675.
[79]

, ILUS: an incomplete LU factorization for matrices in sparse skyline format,
International Journal for Numerical Methods in Fluids, 25 (1997), pp. 739–748.

[80]

, Approximate inverse preconditioners via sparse-sparse iterations, SIAM Journal on Scientific Computing, 19 (1998), pp. 995–1023.

[81] N. C HRISOCHOIDES , G. F OX , AND J. T HOMPSON, MENUS-PGG mapping environment for numerical unstructured and structured parallel grid generation, in Proceedings of the Seventh International Conference on Domain Decomposition Methods in
Scientific and Engineering Computing, 1993.
[82] N. C HRISOCHOIDES , C. E. H OUSTIS , E. N. H OUSTIS , P. N. PAPACHIOU , S. K.
KORTESIS , AND J. R ICE, DOMAIN DECOMPOSER: a software tool for mapping
PDE computations to parallel architectures, in Domain Decomposition Methods for
Partial Differential Equations, R. G. et. al., ed., SIAM publications, 1991, pp. 341–
357.

520

BIBLIOGRAPHY

[83] N. C HRISOCHOIDES , E. H OUSTIS , AND J. R ICE, Mapping algorithms and software environment for data parallel PDE iterative solvers, Journal of Parallel and Distributed Computing, 21 (1994), pp. 75–95.
[84] P. G. C IARLET, The finite element method for elliptic problems, North-Holland, Amsterdam, 1978.
[85] G. C IMMINO, Calcolo approssimato per le soluzioni dei sistemi di equazioni lineari,
Ricerca Scientifica, II, 9 (1938), pp. 326–333.
[86] A. C LAYTON, Further results on polynomials having least maximum modulus over an
ellipse in the complex plane, Tech. Rep. AEEW-7348, UKAEA, Harewell-UK, 1963.
[87] S. C LIFT AND W. TANG, Weighted graph based ordering techniques for preconditioned conjugate gradient methods, BIT, 35 (1995), pp. 30–47.
[88] P. C ONCUS AND G. H. G OLUB, A generalized conjugate gradient method for nonsymmetric systems of linear equations, in Computing Methods in Applied Sciences
and Engineering, R. Glowinski and J. L. Lions, eds., New York, 1976, Springer Verlag, pp. 56–65.
[89] P. C ONCUS , G. H. G OLUB , AND G. M EURANT, Block preconditioning for the conjugate gradient method, SIAM Journal on Scientific and Statistical Computing, 6
(1985), pp. 220–252.
[90] T. H. C ORMEN , C. E. L EISERSON , AND R. L. R IVEST, Introduction to Algorithms,
Mc Graw Hill, New York, 1990.
[91] J. D. F. C OSGROVE , J. C. D IAZ , AND A. G RIEWANK, Approximate inverse preconditioning for sparse linear systems, Interernaitonal Journal of Computational Mathematics, 44 (1992), pp. 91–110.
[92] J. C ULLUM AND A. G REENBAUM, Relations between Galerkin and norm-minimizing
iterative methods for solving linear systems, SIAM Journal on Matrix Analysis and
Applications, 17 (1996), pp. 223–247.
[93] B. N. DATTA, Numerical Linear Algebra and Applications, second edition, SIAM,
Philadelphia, PA, 2010.
[94] P. J. DAVIS, Interpolation and Approximation, Blaisdell, Waltham, MA, 1963.
[95] T. A. DAVIS, A parallel algorithm for sparse unsymmetric LU factorizations, PhD
thesis, University of Illinois at Urbana Champaign, Urbana, IL., 1989.
[96] E. F. D’A ZEVEDO , F. A. F ORSYTH , AND W. P. TANG, Ordering methods for preconditioned conjugate gradient methods applied to unstructured grid problems, SIAM
Journal on Matrix Analysis and Applications, 13 (1992), pp. 944–961.
[97]

, Towards a cost effective ILU preconditioner with high level fill, BIT, 31 (1992),
pp. 442–463.

[98] M. A. D E L ONG AND J. M. O RTEGA, SOR as a preconditioner, Applied Numerical
Mathematics, 18 (1995), pp. 431–440.
[99] J. W. D EMMEL, Applied Numerical Linear Algebra, SIAM, Philadelphia, PA, 1997.
[100] P. D EUFLHARD , R. W. F REUND , AND A. WALTER, Fast secant methods for the
iterative solution of large nonsymmetric linear systems, IMPACT of Computing in
Science and Engineering, 2 (1990), pp. 244–276.

BIBLIOGRAPHY

521

[101] J. J. D ONGARRA , I. S. D UFF , D. S ORENSEN , AND H. A. VAN DER VORST, Solving
Linear Systems on Vector and Shared Memory Computers, SIAM, Philadelphia, PA,
1991.
[102] M. D RYJA AND O. B. W IDLUND, Some domain decomposition algorithms for elliptic
problems, in Iterative Methods for Large Linear Systems, L. Hayes and D. Kincaid,
eds., New York, NY, 1989, Academic Press, pp. 273–291.
[103]

, Towards a unified theory of domain decomposition algorithms for elliptic
problems, in Third International Symposium on Domain Decomposition Methods for
Partial Differential Equations, held in Houston, TX, March 20-22, 1989, T. Chan,
R. Glowinski, J. Périaux, and O. Widlund, eds., Philadelphia, PA, 1990, SIAM.

[104]

, Additive Schwarz methods for elliptic finite element problems in three dimensions, in Fifth International Symposium on Domain Decomposition Methods for Partial Differential Equations, T. F. Chan, D. E. Keyes, G. A. Meurant, J. S. Scroggs, and
R. G. Voigt, eds., Philadelphia, PA, 1992, SIAM.

[105] P. F. D UBOIS , A. G REENBAUM , AND G. H. RODRIGUE, Approximating the inverse
of a matrix for use on iterative algorithms on vectors processors, Computing, 22
(1979), pp. 257–268.
[106] I. S. D UFF, A survey of sparse matrix research, in Proceedings of the IEEE, 65, New
York, 1977, Prentice Hall, pp. 500–535.
[107] I. S. D UFF , A. M. E RISMAN , AND J. K. R EID, Direct Methods for Sparse Matrices,
Clarendon Press, Oxford, 1986.
[108] I. S. D UFF , R. G. G RIMES , AND J. G. L EWIS, Sparse matrix test problems, ACM
Transactions on Mathematical Software, 15 (1989), pp. 1–14.
[109] I. S. D UFF AND J. KOSTER, The design and use of algorithms for permuting large
entries to the diagonal of sparse matrices, SIAM Journal on Matrix Analysis and
Applications, 20 (1999), pp. 889–901.
[110]

, On algorithms for permuting large entries to the diagonal of a sparse matrix,
SIAM Journal on Matrix Analysis and Applications, 22 (2001), pp. 973–996.

[111] I. S. D UFF AND G. A. M EURANT, The effect of ordering on preconditioned conjugate
gradients, BIT, 29 (1989), pp. 635–657.
[112] L. C. D UTTO, The effect of reordering on the preconditioned GMRES algorithm for
solving the compressible Navier-Stokes equations, International Journal for Numerical
Methods in Engineering, 36 (1993), pp. 457–497.
[113] T. E IROLA AND O. N EVANLINNA, Accelerating with rank-one updates, Linear Algebra and its Applications, 121 (1989), pp. 511–520.
[114] S. E ISENSTAT, Efficient implementation of a class of conjugate gradient methods,
SIAM Journal on Scientific and Statistical Computing, 2 (1988), pp. 1–4.
[115] S. C. E ISENSTAT, M. H. S CHULTZ , AND A. H. S HERMAN, Algorithms and data
structures for sparse symmetric Gaussian elimination, SIAM Journal on Scientific
Computing, 2 (1981), pp. 225–237.
[116] H. C. E LMAN, A stability analysis of incomplete LU factorizations, Mathematics of
Computation, 47 (1986), pp. 191–217.

522

BIBLIOGRAPHY

[117] H. C. E LMAN AND E. AGRON, Ordering techniques for the preconditioned conjugate gradient method on parallel computers, Computer Physics Communications, 53
(1989), pp. 253–269.
[118] H. C. E LMAN AND G. H. G OLUB, Inexact and preconditioned Uzawa algorithms for
saddle point problems, SIAM Journal on Numerical Analysis, 31 (1994), pp. 1645–
1661.
[119] H. C. E LMAN AND D. J. S ILVESTER, Fast nonsymmetric iteration and preconditioning for Navier-Stokes equations, SIAM Journal on Scientific Computing, 17 (1996),
pp. 33–46.
[120] M. E NGLEMAN, FIDAP manuals, Tech. Rep. Vol. 1, 2, and 3, Fluid Dynamics International, Evanston, IL, 1986.
[121] V. FABER AND T. M ANTEUFFEL, Necessary and sufficient conditions for the existence of a conjugate gradient method, SIAM Journal on Numerical Analysis, 21
(1984), pp. 352–361.
[122] K. FAN, Note on M -matrices, Quarterly Journal of Mathematics, Oxford series (2),
11 (1960), pp. 43–49.
[123] C. FARHAT AND F. X. ROUX, Implicit parallel processing in structural mechanics,
Computational Mechanics Advances, 2 (1994), pp. 1–124.
[124] R. P. F EDORENKO, A relaxation method for solving elliptic difference equations,
U.S.S.R Computational Math. and Math. Phys., 1 (1962), pp. 1092–1096.
[125]

, The speed of convergence of one iterative process, U.S.S.R Computational
Math. and Math. Phys., 4 (1964), pp. 227–235.

[126] R. M. F ERENCZ, Element-by-element preconditioning techniques for large scale vectorized finite element analysis in nonlinear solid and structural mechanics, PhD thesis,
Department of Applied Mathematics, Stanford, CA, 1989.
[127] B. F ISCHER AND R. W. F REUND, On the constrained Chebyshev approximation
problem on ellipses, Journal of Approximation Theory, 62 (1990), pp. 297–315.
[128]

, Chebyshev polynomials are not always optimal, Journal of Approximation Theory, 65 (1991), pp. 261–272.

[129] B. F ISCHER AND L. R EICHEL, A stable Richardson iteration method for complex
linear systems, Numerische Mathematik, 54 (1988), pp. 225–241.
[130] R. F LETCHER, Conjugate gradient methods for indefinite systems, in Proceedings of
the Dundee Biennal Conference on Numerical Analysis 1974, G. A. Watson, ed., New
York, 1975, Springer Verlag, pp. 73–89.
[131] I. T. F OSTER, Designing and Building Parallel Programs: Concepts and Tools for
Parallel Software Engineering, Addison-Wesley, 1995.
[132] R. W. F REUND, Conjugate gradient-type methods for linear systems with complex
symmetric coefficient matrices, SIAM Journal on Scientific and Statistical Computing,
13 (1992), pp. 425–448.
[133]

, Quasi-kernel polynomials and convergence results for quasi-minimal residual
iterations, in Numerical Methods of Approximation Theory, Vol 9, D. Braess and
L. L. Schumaker, eds., International series of numerical mathematics, Basel, 1992,
Birkhaüser Verlag, pp. 1–19.

BIBLIOGRAPHY
[134]

523

, A Transpose-Free Quasi-Minimal Residual algorithm for non-Hermitian linear
systems, SIAM Journal on Scientific Computing, 14 (1993), pp. 470–482.

[135] R. W. F REUND , M. H. G UTKNECHT, AND N. M. NACHTIGAL, An implementation
of of the Look-Ahead Lanczos algorithm, SIAM Journal on Scientific and Statistical
Computing, 14 (1993), pp. 470–482.
[136] R. W. F REUND AND N. M. NACHTIGAL, QMR: a quasi-minimal residual method
for non-Hermitian linear systems, Numerische Mathematik, 60 (1991), pp. 315–339.
[137] K. G ALLIVAN , A. S AMEH , AND Z. Z LATEV, A parallel hybrid sparse linear system
solver, Computing Systems in Engineering, 1 (June 1990), pp. 183–195.
[138] E. G ALLOPOULOS AND Y. S AAD, Parallel block cyclic reduction algorithm for the
fast solution of elliptic equations, Parallel Comput., 10 (1989), pp. 143–160.
[139] F. R. G ANTMACHER, The Theory of Matrices, Chelsea, New York, 1959.
[140] N. G ASTINEL, Analyse Numérique Linéaire, Hermann, Paris, 1966.
[141] W. G AUTSCHI, On generating orthogonal polynomials, SIAM Journal on Scientific
and Statistical Computing, 3 (1982), pp. 289–317.
[142] A. G EORGE, Computer implementation of the finite element method, Tech. Rep.
STAN-CS-208, Stanford University, Department of Computer Science, 1971.
[143] A. G EORGE AND J. W.-H. L IU, The evolution of the minimum degree ordering algorithm, SIAM Review, 31 (March 1989), pp. 1–19.
[144] J. A. G EORGE AND J. W. L IU, Computer Solution of Large Sparse Positive Definite
Systems, Prentice-Hall, Englewood Cliffs, NJ, 1981.
[145] J. R. G ILBERT, G. L. M ILLER , AND S.-H. T ENG, Geometric mesh partitioning:
Implementation and experiments, in IPPS 94, Submitted to SIAM SISC, 1995.
[146] J. R. G ILBERT AND T. P EIERLS, Sparse partial pivoting in time proportional to artithmetic operations, SIAM Journal on Scientific Computing, 9 (1988), pp. 862–874.
[147] S. K. G ODUNOV AND G. P. P ROPKOPOV, A method of minimal iteration for evaluating the eigenvalues of an elliptic operator, Zh. Vichsl. Mat. Mat. Fiz., 10 (1970),
pp. 1180–1190.
[148] T. G OEHRING AND Y. S AAD, Heuristic algorithms for automatic graph partitioning,
Tech. Rep. umsi-94-29, University of Minnesota Supercomputer Institute, Minneapolis, MN, February 1994.
[149] G. H. G OLUB AND C. F. V. L OAN, Matrix Computations, Johns Hopkins University
Press, Baltimore, MD, 3rd ed., 1996.
[150] G. H. G OLUB AND M. L. OVERTON, The convergence of inexact Chebyshev and
Richardson iterative methods for solving linear systems, Numerische Mathematik, 53
(1988), pp. 571–593.
[151] G. H. G OLUB AND R. S. VARGA, Chebyshev semi iterative methods successive
overrelaxation iterative methods and second order Richardson iterative methods, Numerische Mathematik, 3 (1961), pp. 147–168.
[152] G. H. G OLUB AND A. J. WATHENS, An iteration for indefinite systems and its application to the Navier-Stokes equations, SIAM Journal on Scientific Computing, 19
(1998), pp. 530–539.

524

BIBLIOGRAPHY

[153] G. H. G OLUB AND Q. Y E, Inexact preconditioned conjugate gradient method with
inner-outer iterations, SIAM Journal on Scientific Computing, 21 (1999).
[154] A. G REENBAUM, Iterative Methods for Solving Linear Systems, SIAM, Philadelpha,
PA, 1997.
[155] A. G REENBAUM , C. L I , AND H. Z. C HAO, Parallelizing preconditioned conjugate
gradient algorithms, Computer Physics Communications, 53 (1989), pp. 295–309.
[156] W. G ROPP, E. L USK , AND A. S KJELLUM, Using MPI: Portable Parallel Programming with the Message Passing Interface, MIT press, 1994.
[157] M. G ROTE AND T. H UCKLE, Effective parallel preconditioning with sparse approximate inverses, in Proceedings of the Seventh SIAM Conference on Parallel Processing
for Scientific Computing, D. H. Bailey, ed., Philadelphia, 1995, SIAM, pp. 466–471.
[158] M. G ROTE AND H. D. S IMON, Parallel preconditioning and approximate inverses on
the connection machine, in Parallel Processing for Scientific Computing – vol. 2, R. F.
Sincovec, D. E. Keyes, L. R. Petzold, and D. A. Reed, eds., SIAM, 1992, pp. 519–523.
[159] M. J. G ROTE AND T. H UCKLE, Parallel preconditionings with sparse approximate
inverses, SIAM Journal on Scientific Computing, 18 (1997), pp. 838–853.
[160] M. H. G UTKNECHT, A completed theory of the unsymmetric Lanczos process and
related algorithms. Part I., SIAM Journal on Matrix Analysis and Applications, 13
(1992), pp. 594–639.
[161]

, A completed theory of the unsymmetric Lanczos process and related algorithms. Part II., SIAM Journal on Matrix Analysis and Applications, 15 (1994),
pp. 15–58.

[162] W. H ACKBUSCH, Multi-Grid Methods and Applications, vol. 4 of Springer Series in
Computational Mathematics, Springer-Verlag, Berlin, 1985.
[163] W. H ACKBUSCH, Iterative Solution of Large Linear Systems of Equations, Springer
Verlag, New York, 1994.
[164] P. R. H ALMOS, Finite-Dimensional Vector Spaces, Springer Verlag, New York, 1958.
[165] S. H AMMOND AND R. S CHREIBER, Efficient iccg on a shared memory multiprocessor, Tech. Rep. 89. 24, RIACS, NASA Ames research center, Moffett Field CA.,
1989.
[166] B. H ENDRICKSON AND R. L ELAND, The Chaco User’s Guide Version 2, Sandia
National Laboratories, Albuquerque NM, 1994.
[167] M. R. H ESTENES AND E. L. S TIEFEL, Methods of conjugate gradients for solving
linear systems, Journal of Research of the National Bureau of Standards, Section B,
49 (1952), pp. 409–436.
[168] C. H IRSCH, Numerical Computation of Internal and External Flows, John Wiley and
Sons, New York, 1988.
[169] R. W. H OCKNEY, A fast direct solution of Poisson’s equation using Fourier analysis,
J. Assoc. Comput. Mach., 12 (1965), pp. 95–113.
[170]

, The potential calculation and some applications, Meth. Comput. Phy., 9
(1970), pp. 135–211.

BIBLIOGRAPHY
[171]

525

, The potential calculation and some applications, Methods Comput. Phys., 9
(1970), pp. 135–211.

[172] R. A. H ORN AND C. R. J OHNSON, Matrix Analysis, Cambridge University Press,
Cambridge, 1985.
[173] A. S. H OUSEHOLDER, Theory of Matrices in Numerical Analysis, Blaisdell Pub. Co.,
Johnson, CO, 1964.
[174] T. J. R. H UGHES , R. M. F ERENCZ , AND J. O. H ALLQUIST, Large-scale vectorized
implicit calculations in solid mechanics on a Cray X-MP/48 utilizing EBE preconditioned conjugate gradients, Computer Methods in Applied Mechanics and Engineering, 61 (1987), pp. 215–248.
[175] K. J BILOU, Projection minimization methods for nonsymmetric linear systems. To
appear, Linear Algebra and its Applications.
[176] K. J BILOU , A. M ESSAOUDI , AND H. S ADOK, Global FOM and GMRES algorithms
for matrix equations, Applied Numerical Mathematics, 31 (1999), pp. 49–63.
[177] K. J BILOU AND H. S ADOK, Analysis of some vector extrapolation methods for solving systems of linear equations, Numerische Mathematik, (1995), pp. 73–89.
[178] K. C. J EA AND D. M. YOUNG, Generalized conjugate gradient acceleration of
nonsymmetrizable iterative methods, Linear Algebra and its Applications, 34 (1980),
pp. 159–194.
[179] C. J OHNSON, Numerical Solutions of Partial Differential Equations by the Finite Element Method, Cambridge University Press, Cambridge, UK, 1987.
[180] O. G. J OHNSON , C. A. M ICCHELLI , AND G. PAUL, Polynomial preconditionings
for conjugate gradient calculations, SIAM Journal on Numerical Analysis, 20 (1983),
pp. 362–376.
[181] S. K ACZMARZ, Angenäherte auflösung von systemen linearer gleichungen, Bulletin
international de l’Académie polonaise des Sciences et Lettres, III, class A (1937),
pp. 355–357.
[182] C. K AMATH AND A. S AMEH, A projection method for solving nonsymmetric linear
systems on multiprocessors, Parallel Computing, 9 (1988), pp. 291–312.
[183] R. M. K ARP, Reducibility among combinatorial problems, in Complexity of Computer Computations, New York, 1972, Plenum Press, pp. 85–104.
[184] T. I. K ARUSH , N. K. M ADSEN , AND G. H. RODRIGUE, Matrix multiplication by
diagonals on vector/parallel processors, Tech. Rep. UCUD, Lawrence Livermore National Lab., Livermore, CA, 1975.
[185] G. K ARYPIS AND V. K UMAR, A fast and high quality multilevel scheme for partitioning irregular graphs, SIAM Journal on Scientific Computing, 20 (1999), pp. 359–392.
[186] C. T. K ELLY, Iterative methods for linear and nonlinear equations, SIAM, Philadelphia, 1995.
[187] D. S. K ERSHAW, The incomplete Choleski conjugate gradient method for the iterative
solution of systems of linear equations, Journal of Computational Physics, 26 (1978),
pp. 43–65.

526

BIBLIOGRAPHY

[188] R. K ETTLER, Analysis and comparison of relaxation schemes in robust multigrid and
preconditioned conjugate gradient methods, in Multigrid methods: Proc., Koln-Porz,
Nov. 1981, W. Hackbusch and U. Trottenberg, eds., Lecture notes in Math. 1228,
Springer Verlag, Berlin, 1982, pp. 502–534.
[189] D. E. K EYES AND W. D. G ROPP, A comparison of domain decomposition techniques
for elliptic partial differential equations and their parallel implementation, SIAM
Journal on Scientific and Statistical Computing, 8 (1987), pp. s166–s202.
[190] D. E. K EYES , Y. S AAD , AND D. G. T RUHLAR, Domain-Based Parallelism and
Problem Decomposition Methods in Computational Science and Engineering, SIAM,
Philadelphia, PA, 1995. (Conference proceedings).
[191] L. Y. KOLOTILINA AND A. Y. Y EREMIN, On a family of two-level preconditionings
of the incomplete block factorization type, Soviet Journal of Numerical Analysis and
Mathematical Modeling, 1 (1986), pp. 293–320.
[192] M. A. K RASNOSELSKII ET AL ., Approximate Solutions of Operator Equations,
Wolters-Nordhoff, Groningen, 1972.
[193] L. K RONSJ Ö AND G. DAHLQUIST, On the design of nested iterations for elliptic
difference equations, BIT, 11 (1971), pp. 63–71.
[194] V. K UMAR , A. G RAMA , A. G UPTA , AND G. K APYRIS, Parallel Computing, 2nd
edition, Benjamin Cummings, Redwood City, CA, 2003.
[195] C. L ANCZOS, An iteration method for the solution of the eigenvalue problem of linear
differential and integral operators, Journal of Research of the National Bureau of
Standards, 45 (1950), pp. 255–282.
[196]

, Chebyshev polynomials in the solution of large-scale linear systems, in Proceedings of the ACM, 1952, pp. 124–133.

[197]

, Solution of systems of linear equations by minimized iterations, Journal of
Research of the National Bureau of Standards, 49 (1952), pp. 33–53.

[198] P. L E TALLEC, Domain decomposition methods in computational mechanics, Computational Mechanics Advances, 1 (1994), pp. 121–220.
[199] R. L EUZE, Independent set orderings for parallel matrix factorizations by Gaussian
elimination, Parallel Computing, 10 (1989), pp. 177–191.
[200] J. G. L EWIS , B. W. P EYTON , AND A. P OTHEN, A fast algorithm for reordering
sparse matrices for parallel factorizations, SIAM Journal on Scientific and Statistical
Computing, 6 (1989), pp. 1146–1173.
[201] J. G. L EWIS AND H. D. S IMON, The impact of hardware scatter-gather on sparse
Gaussian elimination, SIAM Journal on Scientific and Statistical Computing, 9
(1988), pp. 304–311.
[202] N. L I , Y. S AAD , AND E. C HOW, Crout versions of ILU for general sparse matrices,
SIAM Journal on Scientific Computing, 25 (2003), pp. 716–728.
[203] Z. L I , Y. S AAD , AND M. S OSONKINA, pARMS: a parallel version of the algebraic recursive multilevel solver, Tech. Rep. umsi-2001-100, Minnesota Supercomputer Institute, University of Minnesota, Minneapolis, MN, 2001. Appeared in NLAA, 10:485509 (2003).

BIBLIOGRAPHY

527

[204] J. W.-H. L IU, Modification of the minimum degree algorithm by multiple elimination,
ACM Transactions on Mathematical Software, 11 (1985), pp. 141–153.
[205] S. M A, Parallel block preconditioned Krylov subspace methods for Partial Differential Equations, PhD thesis, Department of Computer Science, Minneapolis, MN,
1993.
[206] T. A. M ANTEUFFEL, An incomplete factorization technique for positive definite linear
systems, Mathematics of Computation, 34 (1980), pp. 473–497.
[207] S. F. M C C ORMICK, ed., Multigrid Methods, Philadelphia, PA, 1987, SIAM.
[208] J. A. M EIJERINK AND H. A. VAN DER VORST, An iterative solution method for
linear systems of which the coefficient matrix is a symmetric M-matrix, Mathematics
of Computation, 31 (1977), pp. 148–162.
[209] G. M EURANT, Computer solution of large linear systems, North-Holland, Amsterdam, 1999. Vol 28, Studies in Mathematics and its Applications.
[210] C. D. M EYER, Matrix Analysis and Applied Linear Algebra, SIAM, Philadelphia, PA,
2000.
[211] G. L. M ILLER , S. H. T ENG , W. T HURSTON , AND S. A. VAVASIS, Automatic mesh
partitioning, in Sparse Matrix Computations: Graph Theory Issues and Algorithms,
A. George, J. Gilbert, and J. Liu, eds., 1993. IMA Volumes in Mathematics and Its
Applications.
[212] N. M UNKSGAARD, Solving sparse symmetric sets of linear equations by preconditioned conjugate gradient method, ACM Transactions on Mathematical Software, 6
(1980), pp. 206–219.
[213] N. M. NACHTIGAL, A look-ahead variant of the Lanczos Algorithm and its application to the Quasi-Minimal Residual method for non-Hermitian linear systems, PhD
thesis, Applied Mathematics, Cambridge, 1991.
[214] Y. N OTAY, Flexible conjugate gradient, SIAM Journal on Scientific Computing, 22
(2000), p. 1444=1460.
[215] D. O’L EARY, The block conjugate gradient algorithm and related methods, Linear
Algebra and its Applications, 29 (1980), pp. 243–322.
[216] C. W. O OSTERLEE AND T. WASHIO, An evaluation of parallel multigrid as a solver
and a preconditioner for singularly perturbed problems, SIAM Journal on Scientific
and Statistical Computing, 19 (1991), pp. 87–110.
[217] J. O RTEGA, Efficient implementation of certain iterative methods, SIAM Journal on
Scientific and Statistical Computing, 9 (1988), pp. 882–891.
[218]

, Orderings for conjugate gradient preconditionings, SIAM Journal on Scientific
and Statistical Computing, 12 (1991), pp. 565–582.

[219] J. M. O RTEGA, Introduction to Parallel and Vector Solution of Linear Systems,
Plenum Press, New York, 1988.
[220] J. M. O RTEGA AND R. G. VOIGT, Solution of partial differential equations on vector
and parallel computers, SIAM Review, 27 (1985), pp. 149–240.
[221] O. O STERBY AND Z. Z LATEV, Direct Methods for Sparse Matrices, Springer Verlag,
New York, 1983.

528

BIBLIOGRAPHY

[222] C. C. PAIGE, Computational variants of the Lanczos method for the eigenproblem,
Journal of the Institute of Mathematics and its Applications, 10 (1972), pp. 373–381.
[223] C. C. PAIGE AND M. A. S AUNDERS, Solution of sparse indefinite systems of linear
equations, SIAM Journal on Numerical Analysis, 12 (1975), pp. 617–624.
[224] B. N. PARLETT, The Symmetric Eigenvalue Problem, no. 20 in Classics in Applied
Mathematics, SIAM, Philadelphia, 1998.
[225] B. N. PARLETT, D. R. TAYLOR , AND Z. S. L IU, A look-ahead Lanczos algorithm
for nonsymmetric matrices, Mathematics of Computation, 44 (1985), pp. 105–124.
[226] D. P EACEMAN AND H. R ACHFORD, The numerical solution of elliptic and parabolic
differential equations, Journal of SIAM, 3 (1955), pp. 28–41.
[227] S. P ISSANETZKY, Sparse Matrix Technology, Academic Press, New York, 1984.
[228] E. L. P OOLE AND J. M. O RTEGA, Multicolor ICCG methods for vector computers,
SIAM Journal on Numerical Analysis, 24 (1987), pp. 1394–1418.
[229] A. P OTHEN , H. D. S IMON , AND K. P. L IOU, Partitioning sparse matrices with eigenvectors of graphs, SIAM Journal on Matrix Analysis and Applications, 11 (1990),
pp. 430–452.
[230] J. S. P RZEMIENIECKI, Matrix structural analysis of substructures., Am. Inst. Aero.
Astro. J., 1 (1963), pp. 138–147.
[231] J. K. R EID, On the method of conjugate gradients for the solution of large sparse
systems of linear equations, in Large Sparse Sets of Linear Equations, J. K. Reid, ed.,
Academic Press, 1971, pp. 231–254.
[232] T. J. R IVLIN, The Chebyshev Polynomials: from Approximation Theory to Algebra
and Number Theory, J. Wiley and Sons, New York, 1990.
[233] D. J. ROSE AND R. E. TARJAN, Algorithmic aspects of vertex elimination on directed
graphs, SIAM J. Appl. Math., 34 (1978), pp. 176–197.
[234] F. X. ROUX, Acceleration of the outer conjugate gradient by reorthogonalization for a
domain decomposition method for structural analysis problems, in Proceedings of the
Third International Symposium on Domain Decomposition Methods, Houston March
20-22 1989, T. Chan and R. Glowinski, eds., Philadelphia, PA, 1990, SIAM.
[235] A. RUGE AND K. S T ÜBEN, Algebraic multigrid, in Multigrid Methods, S. McCormick, ed., vol. 3 of Frontiers in Applied Mathematics, SIAM, 1987, ch. 4.
[236] A. RUHE, Implementation aspects of band Lanczos algorithms for computation of
eigenvalues of large sparse symmetric matrices, Mathematics of Computation, 33
(1979), pp. 680–687.
[237] H. RUTISHAUSER, Theory of gradient methods, in Refined Iterative Methods
for Computation of the Solution and the Eigenvalues of Self-Adjoint Boundary
Value Problems, Basel-Stuttgart, 1959, Institute of Applied Mathematics, Zurich,
Birkhäuser Verlag, pp. 24–49.
[238] Y. S AAD, Krylov subspace methods for solving large unsymmetric linear systems,
Mathematics of Computation, 37 (1981), pp. 105–126.

BIBLIOGRAPHY

529

[239]

, The Lanczos biorthogonalization algorithm and other oblique projection methods for solving large unsymmetric systems, SIAM Journal on Numerical Analysis, 19
(1982), pp. 470–484.

[240]

, Iterative solution of indefinite symmetric systems by methods using orthogonal
polynomials over two disjoint intervals, SIAM Journal on Numerical Analysis, 20
(1983), pp. 784–811.

[241]

, Practical use of polynomial preconditionings for the conjugate gradient
method, SIAM Journal on Scientific and Statistical Computing, 6 (1985), pp. 865–
881.

[242]

, Least squares polynomials in the complex plane and their use for solving sparse
nonsymmetric linear systems, SIAM Journal on Numerical Analysis, 24 (1987),
pp. 155–169.

[243]

, On the Lanczos method for solving symmetric linear systems with several righthand sides, Mathematics of Computation, 48 (1987), pp. 651–662.

[244]

, Krylov subspace methods on supercomputers, SIAM Journal on Scientific and
Statistical Computing, 10 (1989), pp. 1200–1232.

[245]

, SPARSKIT: A basic tool kit for sparse matrix computations, Tech. Rep. RIACS90-20, Research Institute for Advanced Computer Science, NASA Ames Research
Center, Moffett Field, CA, 1990.
, Numerical Methods for Large Eigenvalue Problems, Halstead Press, New York,

[246]
1992.
[247]

, A flexible inner-outer preconditioned GMRES algorithm, SIAM Journal on
Scientific and Statistical Computing, 14 (1993), pp. 461–469.

[248]

, Highly parallel preconditioners for general sparse matrices, in Recent Advances in Iterative Methods, IMA Volumes in Mathematics and Its Applications,
G. Golub, M. Luskin, and A. Greenbaum, eds., vol. 60, New York, 1994, Springer
Verlag, pp. 165–199.

[249]

, ILUT: a dual threshold incomplete ILU factorization, Numerical Linear Algebra with Applications, 1 (1994), pp. 387–402.

[250]

, Analysis of augmented Krylov subspace techniques, SIAM J. Matrix Anal.
Appl., 18 (1997), pp. 435–449.

[251] Y. S AAD AND M. H. S CHULTZ, GMRES: a generalized minimal residual algorithm
for solving nonsymmetric linear systems, SIAM Journal on Scientific and Statistical
Computing, 7 (1986), pp. 856–869.
[252]

, Parallel implementations of preconditioned conjugate gradient methods, in
Mathematical and Computational Methods in Seismic Exploration and Reservoir
Modeling, W. E. Fitzgibbon, ed., Philadelphia, PA, 1986, SIAM.

[253] Y. S AAD AND B. S UCHOMEL, ARMS: An algebraic recursive multilevel solver for
general sparse linear systems, Numerical Linear Algebra with Applications, 9 (2002).
[254] Y. S AAD AND H. A. VAN DER VORST, Iterative solution of linear systems in the 20th
century, Journal of Computational and Applied Mathematics, 123 (2000), pp. 1–33.

530

BIBLIOGRAPHY

[255] Y. S AAD AND K. W U, DQGMRES: a direct quasi-minimal residual algorithm based
on incomplete orthogonalization, Numerical Linear Algebra with Applications, 3
(1996), pp. 329–343.
[256] H. S ADOK, Méthodes de projection pour les systèmes linéaires et non linéaires, University of Lille 1, Lille, France, 1994. Habilitation Thesis.
[257] J. S ALTZ , R. M IRCHANDANEY, AND K. C ROWLEY, Run-time paralellization and
scheduling of loops, IEEE Trans. Comput., 40 (1991), pp. 603–612.
[258] J. H. S ALTZ, Automated problem scheduling and reduction of synchronization delay
effects, Tech. Rep. 87-22, ICASE, Hampton, VA, 1987.
[259] W. S CHONAUER, The efficient solution of large linear systems, resulting from the
fdm for 3-d PDE’s, on vector computers. In Proceedings of the 1-st International
colloquium on vector and parallel computing in Scientific applications - Paris March
1983, 1983.
[260] W. S CH ÖNAUER, Scientific Computing on Vector Computers, North-Holland, New
York, 1987.
[261] H. A. S CHWARZ, Gesammelte Mathematische Abhandlungen, vol. 2, Springer Verlag,
Berlin, Germany / Heidelberg, Germany / London, UK / etc., 1890, pp. 133–143. First
published in Vierteljahrsschrift der Naturforschenden Gesellschaft in Zürich, volume
15, 1870, pp. 272–286.
[262] F. S HAKIB, Finite element analysis of the compressible Euler and Navier Stokes
Equations, PhD thesis, Department of Aeronautics, Stanford, CA, 1989.
[263] A. S IDI, Extrapolation vs. projection methods for linear systems of equations, Journal
of Computational and Applied Mathematics, 22 (1988), pp. 71–88.
[264] D. S ILVESTER AND A. WATHEN, Fast iterative solution of stabilized Stokes problems. part ii: using block preconditioners, SIAM Journal on Numerical Analysis, 30
(1983), pp. 143–144.
[265] H. D. S IMON, Incomplete LU preconditioners for conjugate gradient type iterative
methods, in Proceedings of the SPE 1985 reservoir simulation symposium, Dallas,
TX, 1988, Society of Petroleum Engineers of AIME, pp. 302–306. Paper number
13533.
[266] V. S IMONCINI AND E. G ALLOPOULOS, Convergence properties of block GMRES
and matrix polynomials, Linear Algebra and its Applications, 247 (1996), pp. 97–120.
[267]

, An iterative method for nonsymmetric systems with multiple right-hand sides,
SIAM Journal on Scientific Computing, 16 (July 1995), pp. 917–933.

[268] B. S MITH , P. B JØRSTAD , AND W. G ROPP, Domain decomposition: Parallel multilevel methods for elliptic partial differential equations, Cambridge University Press,
New-York, NY, 1996.
[269] B. F. S MITH, An optimal domain decomposition preconditioner for the finite element
solution of linear elasticity problems, SIAM Journal on Scientific and Statistical Computing, 13 (1992), pp. 364–378.
[270] D. A. S MITH , W. F. F ORD , AND A. S IDI, Extrapolation methods for vector sequences, SIAM review, 29 (1987), pp. 199–233.

BIBLIOGRAPHY

531

[271] D. C. S MOLARSKI AND P. E. S AYLOR, An optimum iterative method for solving any
linear system with a square matrix, BIT, 28 (1988), pp. 163–178.
[272] P. S ONNEVELD, CGS, a fast Lanczos-type solver for nonsymmetric linear systems,
SIAM Journal on Scientific and Statistical Computing, 10 (1989), pp. 36–52.
[273] G. W. S TEWART, Introduction to Matrix Computations, Academic Press, New York,
1973.
[274]

, Matrix Algorithms, volumes 1 to 5, SIAM, Philadelphia, 2002.

[275] W. J. S TEWART, Introduction to the Numerical Solution of Markov Chains, Princeton
University Press, Princeton, NJ, 1994.
[276] E. L. S TIEFEL, Kernel polynomials in linear algebra and their applications, U. S.
National Bureau of Standards, Applied Mathematics Series, 49 (1958), pp. 1–24.
[277] G. S TRANG AND G. J. F IX, An analysis of the finite element method, Prentice Hall,
Englewood Cliffs, NJ, 1973.
[278] K. S TUBEN AND U. T ROTTENBERG, Multi-grid methods: Fundamental algorithms,
model problem analysis and applications, in Multigrid Methods, W. Hackbusch and
U. Trottenberg, eds., vol. 960, Berlin, 1982, Springer Verlag.
[279] P. N. S WARTZRAUBER, A direct method for the discrete solution of separable elliptic
equations, SIAM Journal on Numerical Analysis, 11 (1974), pp. 1136–1150.
[280]

, The methods of cyclic reduction, Fourier analysis, and the FACR algorithm for
the discrete solution of Poisson’s equation on a rectangle, SIAM review, 19 (1977),
pp. 490–501.

[281] R. S WEET, A parallel and vector variant of the cyclic reduction algorithm, Supercomputer, 22 (1987), pp. 18–25.
[282] D. B. S ZYLD AND J. A. VOGEL, FQMR: A flexible quasi-minimal residual method
with inexact preconditioner, SIAM Journal on Scientific Computing, 23 (2001),
pp. 363–380.
[283] P. L. TALLEC , Y.-H. D. R OECK , AND M. V IDRASCU, Domain-decomposition methods for large linearly elliptic three dimensional problems, Journal of Computational
and Applied Mathematics, 34 (1991). Elsevier Science Publishers, Amsterdam.
[284] D. TAYLOR, Analysis of the look-ahead Lanczos algorithm, PhD thesis, Department
of Computer Science, Berkeley, CA, 1983.
[285] L. N. T REFETHEN, Approximation theory and numerical linear algebra, Tech. Rep.
Numerical Analysis Report 88-7, Massachussetts Institute of Technology, Cambridge,
MA, 1988.
[286] U. T ROTTENBERG , C. O OSTERLEE , AND A. S CH ÜLLER, Multigrid, Academic
Press, New York, 2001.
[287] R. U NDERWOOD, An iterative block Lanczos method for the solution of large sparse
symmetric eigenproblems, Tech. Rep. Stan-CS74-469, Stanford University, StanfordCA, 1975.
[288] H. A. VAN DER VORST, The performance of FORTRAN implementations for preconditioned conjugate gradient methods on vector computers, Parallel Computing, 3
(1986), pp. 49–58.

532

BIBLIOGRAPHY

[289] H. A. VAN DER VORST, Large tridiagonal and block tridiagonal linear systems on
vector and parallel computers, Parallel Computing, 5 (1987), pp. 303–311.
[290] H. A. VAN DER VORST, Bi-CGSTAB: A fast and smoothly converging variant of BiCG for the solution of non-symmetric linear systems, SIAM Journal on Scientific and
Statistical Computing, 12 (1992), pp. 631–644.
[291] H. A. VAN DER VORST AND C. V UIK, GMRESR: a family of nested GMRES methods, Numerical Linear Algebra with Applications, 1 (1994), pp. 369–386.
[292] R. S. VARGA, Factorizations and normalized iterative methods, in Boundary Problems in Differential Equations, Madison, WI, 1960, University of Wisconsin Press,
pp. 121–142.
[293]

, Matrix Iterative Analysis, Prentice Hall, Englewood Cliffs, NJ, 1962.

[294] V. V ENKATAKRISHNAN, Preconditioned Conjugate Gradient methods for the compressible Navier Stokes equations, AIAA Journal, 29 (1991), pp. 1092–1100.
[295]

, Parallel implicit methods for aerodynamic applications on unstructured grids,
in Domain-Based Parallelism and Problem Decomposition Methods in Computational
Science and Engineering, D. E. Keyes, Y. Saad, and D. G. Truhlar, eds., Philadelphia,
PA, 1995, SIAM, pp. 57–74.

[296] V. V ENKATAKRISHNAN AND D. J. M AVRIPLIS, Implicit solvers for unstructured
meshes, Journal of Computational Physics, 105 (1993), pp. 83–91.
[297] V. V ENKATAKRISHNAN , H. D. S IMON , AND T. J. BARTH, A MIMD Implementation
of a Parallel Euler Solver for Unstructured Grids, The Journal of Supercomputing, 6
(1992), pp. 117–137.
[298] P. K. W. V INSOME, ORTHOMIN, an iterative method for solving sparse sets of simultaneous linear equations, in Proceedings of the Fourth Symposium on Resevoir
Simulation, Society of Petroleum Engineers of AIME, 1976, pp. 149–159.
[299] V. V. VOEVODIN, The problem of a non-selfadjoint generalization of the conjugate
gradient method has been closed, USSR Computational Mathematics and Mathematical Physics, 23 (1983), pp. 143–144.
[300] E. L. WACHSPRESS, Iterative Solution of Elliptic Systems and Applications to the
Neutron Equations of Reactor Physics, Prentice Hall, Englewood Cliffs, NJ, 1966.
[301] C. WAGNER, Introduction to Algebraic Multigrid - Course Notes of an Algebraic
Multigrid Course at the University of Heidelberg in the Wintersemester 1998/99.
[302] C. WAGNER , W. K INZELBACH , AND G. W ITTUM, Schur-complement multigrid, a
robust method for groundwater flow and transport problems, Numer. Math., 75 (1997),
pp. 523–545.
[303] H. F. WALKER, Implementation of the GMRES method using Householder transformations, SIAM Journal on Scientific Computing, 9 (1988), pp. 152–163.
[304] X. WANG , K. G ALLIVAN , AND R. B RAMLEY, CIMGS: An incomplete orthogonal factorization preconditioner, SIAM Journal on Scientific Computing, 18 (1997),
pp. 516–536.
[305] A. WATHEN AND D. S ILVESTER, Fast iterative solution of stabilized Stokes problems. part i: using simple diagonal preconditioners, SIAM Journal on Numerical
Analysis, 30 (1983), pp. 143–144.

BIBLIOGRAPHY

533

[306] J. W. WATTS III, A conjugate gradient truncated direct method for the iterative solution of the reservoir simulation pressure equation, Society of Petroleum Engineers
Journal, 21 (1981), pp. 345–353.
[307] R. W EISS, Convergence behavior of generalized conjugate gradient methods, PhD
thesis, Karlsruhe, Germany, 1990.
[308]

, A theoretical overview of Krylov subspace methods, in Special Issue on Iterative Methods for Linear Systems, W. Schönauer and R. Weiss, eds., Applied Numerical Methods, 1995, pp. 33–56.

[309] P. W ESSELING, A robust and efficient multigrid method, in Multigrid methods: Proc.,
Koln-Porz, Nov. 1981, W. Hackbusch and U. Trottenberg, eds., Lecture notes in Math.
1228, Springer Verlag, Berlin, 1982, pp. 614–630.
[310]

, Theoretical and practical aspects of a multigrid method, SIAM J. Sci. Stat.
Comp., 3 (1982), pp. 387–407.

[311]

, An Introduction to Multigrid Methods, John Wiley and Sons, Chichester, 1992.

[312] P. W ESSELING AND P. S ONNEVELD, Numerical experiments with a multiple-grid
and a preconditioned Lanczos-type method, vol. 771 of Lecture notes in mathematics,
Springer Verlag, Berlin. Heidelberg, New-York, 1980, pp. 543–562.
[313] O. W IDLUND, A Lanczos method for a class of non-symmetric systems of linear equations, SIAM Journal on Numerical Analysis, 15 (1978), pp. 801–812.
[314] L. B. W IGTON, Application of MACSYMA and sparse matrix technology to multielement airfoil calculations, in Proceedings of the AIAA-87 conference, Honolulu,
Hawai, June 9-11, 1987, New York, 1987, AIAA, pp. 444–457. Paper number AIAA87-1142-CP.
[315] P. W ILDERS AND W. B RAKKEE, Schwarz and Schur: an algebraic note on equivalence properties, SIAM Journal on Scientific Computing, 20 (1999), pp. 2297–2303.
[316] B. W ILKINSON AND C. M. A LLEN, Parallel Programming: Techniques and Applications Using Networked Workstations and Parallel Computers, Prentice Hall, 1998.
[317] J. H. W ILKINSON, The Algebraic Eigenvalue Problem, Clarendon Press, Oxford,
1965.
[318] O. W ING AND J. W. H UANG, A computation model of parallel solution of linear
equations, IEEE Transactions on Computers, C-29 (1980), pp. 632–638.
[319] C. H. W U, A multicolor SOR method for the finite-element method, Journal of Computational and Applied Mathematics, 30 (1990), pp. 283–294.
[320] J. X U, Iterative methods by space decomposition and subspace correction, SIAM
Review, 34 (1992), pp. 581–613.
[321] Q. Y E, A breakdown-free variation of the Lanczos algorithm, Mathematics of Computation, 62 (1994), pp. 179–207.
[322] D. M. YOUNG, Iterative Solution of Large Linear Systems, Academic Press, New
York, 1971.
[323] D. P. YOUNG , R. G. M ELVIN , F. T. J OHNSON , J. E. B USSOLETTI , L. B. W IGTON ,
AND S. S. S AMANT , Application of sparse matrix solvers as effective preconditioners,
SIAM Journal on Scientific and Statistical Computing, 10 (1989), pp. 1186–1199.

534

BIBLIOGRAPHY

[324] L. Z HOU AND H. F. WALKER, Residual smoothing techniques for iterative methods,
SIAM Journal on Scientific Computing, 15 (1994), pp. 297–312.
[325] Z. Z LATEV, Use of iterative refinement in the solution of sparse linear systems, SIAM
Journal on Numerical Analysis, 19 (1982), pp. 381–399.

Index
A
B
A-norm, 34, 137, 214
Bakhvalov, N. S., 467
Adams, L. M., 104, 422
banded matrices, 5
additive projection procedure, 148
bandwidth
ADI, 127
of a bus, 373
Peaceman-Rachford algorithm, 128
of a matrix, 5
adjacency graph, 77
Bank, R., 468
of PDE matrices, 78
Barker, V. A., 74, 367
adjoint of a matrix, 7
Barth, T. J., 256
AINV, 348
basis of a subspace, 10
algebraic multigrid, 455–464
BCG, 234–239
algebraic multiplicity, 15
algorithm, 235
Aliga, J. I., 256
transpose-free variants, 241–254
Allen, M. C., 392
BCR, see block cyclic reduction
Alternating Direction Implicit, see ADI
Benantar, M., 104
AMG, see algebraic multigrid
Benzi, M., 348, 353, 367
coarsening, 455
BFS
Anderson, E., 392
see Breadth First Search, 83
angle between a vector and a subspace, 141 BICGSTAB, 244
anisotropic medium, 49
Biconjugate Gradient, see BCG
Approximate Inverse
bidiagonal matrices, 5
AINV, 348
bilinear form, 63
approximate inverse preconditioners, 336
binary search trees, 332
column-oriented, 339
biorthogonal bases, 36
global iteration, 337
biorthogonal vectors, 36, 230
for improving a preconditioner, 348
biorthogonalization, 229
approximate inverse techniques, 417
bipartite graph, 90, 123, 352
Arnldi, W.E., 160
bipartite matching, 352
Arnoldi’s method, 159–171
bipartite transversal, 352
basic algorithm, 160
Birkhoff, G., 129
breakdown of, 161
Björk, A., 274
with Householder orthogonalization, 163 Bjørstad, P., 513
for linear systems, 165
block Arnoldi
lucky breakdown, 162
algorithm, 219
with Modified Gram-Schmidt, 162
Ruhe’s variant, 220
practical implementation, 162
block cyclic reduction, 59
Arrow-Hurwicz’s Algorithm, 271
Buneman’s variant, 61
assembled matrix, 68
block diagonal matrices, 5
assembly process, 66
block FOM, 222
Axelsson, O., 74, 227, 295, 367
block Gaussian elimination, 472–475
algorithm, 475

535

536
block GMRES, 222–223
multiple right-hand sides, 222
block Gram-Schmidt, 219
block independent sets, 462
block Jacobi, 112
as a preconditioner, 394
block Krylov subspace methods, 158, 218–
223
block preconditioners, 354
block relaxation, 108
block tridiagonal matrices, 5, 354
preconditioning, 354
Bodewig, E., 367
Boley, D. L., 256
Bollhöfer, M., 367
bottleneck transversal, 353
boundary conditions, 48, 49
Dirichlet, 49
mixed, 49
Neumann, 49
Brakhage, H., 467
Brakkee, W., 513
Bramble, J. H., 513
Bramley, R., 274
Brandt, A., 467
Breadth First Search, 83
Brezinski, C., 256, 257
Brinkkemper, S., 367
Brown, P. N., 186, 189, 227, 240
Buleev, N. I., 367
Buneman’s algorithm, 61
Buneman, O., 60

INDEX

algorithm, 268
optimality, 268
CGNR, 266
algorithm, 266
optimality, 266
CGS, 241–244
algorithm, 243
CGW algorithm, 292
Chan, T. F., 256, 486, 500, 513
characteristic polynomial, 3
Chebyshev
acceleration, 399
Chebyshev polynomials, 209–214, 217, 396–
406
complex, 210, 227
and ellipses, 210
optimality, 211–213
for preconditioning, 396
real, 209
Cheney, C. C., 210
Chow, E., 332, 367
Ciarlet, P. G., 74
Cimmino’s method, 263
Cimmino, G., 274
circuit switching, 373
coarse grid correction, 442
coarse-grain, 393
coarsening, 455, 461
coefficient matrix, 105
coloring vertices, 90
column reordering, 80
Complex GMRES, 193
Compressed Sparse Column storage, see CSC
C
Compressed Sparse Row storage, see CSR
cache memory, 373
Concus, Golub, and Widlund algorithm, 292
canonical form, 15
Concus, P., 292, 367
Jordan, 16
condition number, 41
Schur, 17
for normal equation systems, 260
Cauchy-Schwartz inequality, 6, 8
condition numbers and CG, 202
Cayley-Hamilton theorem, 158
Conjugate Gradient algorithm, 195–203
cell-centered scheme, 71
algorithm, 199
cell-vertex scheme, 71
alternative formulations, 200
centered difference approximation, 51
convergence, 213, 215
centered difference formula, 51
derivation, 196, 199
centerpoint, 505
eigenvalue estimates, 201
Cesari, L., 367, 422
for the normal equations, 265
CG algorithm, see Conjugate Gradient algopreconditioned, 276
rithm
Conjugate Gradient Squared, see CGS
CG for normal equations, 266, 267
Conjugate Residual algorithm, 203
CGNE, 267
consistent matrix norms, 9

INDEX
consistent orderings, 122–127
control volume, 70
convection-diffusion equation, 49
convergence
factor, 116
general, 116
specific, 116
of GMRES, 215
of the Minimal Residual method, 146
rate, 116
of relaxation methods, 114
of Schwarz procedures, 492
COO storage scheme, 92
coordinate storage format, see COO
Cormen, T. H., 332
Cosgrove, J. D. F., 367
Courant characterization, 27
Craig’s method, 268
CSC storage format, 93
matvecs in, 378
CSR storage format, 93, 305
matvecs in, 378
Cullum, J., 187
Cuthill-McKee ordering, 84
queue implementation, 85
D
Dahlquist, G., 467
data coherence, 373
data-parallel, 372
Datta, B. N., 45
Davis, T. A., 422
defective eigenvalue, 16
Delong, M. A., 422
Demmel, J., 45
derogatory, 16
determinant, 3
Deuflhard, P., 257
DIA storage format, 94, 380
matvecs in, 381
diagonal
compensation, 319
dominance, 119
form of matrices, 16
matrices, 5
diagonal storage format, see DIA
diagonalizable matrix, 16
diagonally dominant matrix, 119
diagonally structured matrices, 93
diameter of a graph, 314, 507

537
diameter of a triangle, 65
Diaz, J. C., 367
difference equation, 483
DIOM, 168–171, 196
algorithm, 170
direct IOM, see DIOM
direct sum of subspaces, 10, 35
directed graph, 77
Dirichlet boundary conditions, 48, 49
distributed
computing, 371
ILU, 414
memory, 374
sparse matrices, 383, 414
divergence of a vector, 49
divergence operator, 49
domain decomposition
convergence, 492
and direct solution, 474
full matrix methods, 501
induced preconditioners, 497
Schur complement approaches, 497
Schwarz alternating procedure, 484
domain sweep, 486
double orthogonalization, 162
double-striping, 510
DQGMRES, 180–185, 190, 290
algorithm, 181
Dryja, M., 497
Duff, I. S., 100, 104, 367, 422
E
EBE preconditioner, 417
EBE regularization, 418
edge in a graph, 77
edge-cuts, 507
eigenspace, 11
eigenvalues, 3
definition, 3
from CG iteration, 201
index, 17
of an orthogonal projector, 39
eigenvector, 3
left, 4
right, 4
Eisenstat’s implementation, 280, 295
Eisenstat’s trick, see Eisenstat’s implementation
Eisenstat, S. C., 295, 334

538

INDEX

Element-By-Element preconditioner, see EBE finite volume method, 69
Fischer, B., 213, 227
preconditioner
Fix, G. J., 74
Elfving, T., 274
Flaherty, J. E., 104
ELL storage format, 94
Fletcher, R., 234, 256
matvecs in, 381
flexible GMRES, see FGMRES
Ell storage format, 381
flexible iteration, 287
elliptic operators, 47
Ellpack-Itpack storage format, see ELL stor- flux vector, 69
FMG, 441, 447
age format
FOM, 165
Elman, H. C., 367, 422
algorithm, 166
energy norm, 34, 137, 266, 268
with restarting, 167
Erisman, A. M., 104
Foster, I. T., 392
error projection methods, 139
FPS, see Fast Poisson Solvers
Euclidean inner product, 7
Freund, R. W., 184, 213, 227, 247, 256, 257
Euclidean norm, 7
Frobenius norm, 9
F
frontal methods, 68, 417
Faber, V, 207, 208, 227
full matrix methods, 501–503
Faber-Manteuffel theorem, 206
full multigrid, 441, 447
FACR, 62
Full Orthogonalization Method, see FOM
factored approximate inverse, 345
full weighting, 438
Fan, K., 302
full wrighting, 439
fan-in
FW, 438
in multigrid, 439
fan-out
G
in multigrid, 439
Galerkin conditions, 135
Farhat, C., 513
Galerkin projection, 440
Fast Poisson Solvers, 50, 58–62, 469
in multigrid, 440
Block cyclic reduction, 59
Gallopoulos, E., 74, 227, 256
Buneman’s algorithm, 61
Gastinel’s method, 151
FACR, 62
Gastinel, N., 155, 227
FFT based, 58, 59
gather operation, 379
Fedorenko, R. P., 467
Gauss-Seidel iteration, 105
FFT, 59, 484
backward, 107
FFT solvers, 58
for normal equations, 261
FGMRES, 287–290
in parallel, 420
algorithm, 287
symmetric, 107
fictitious domain methods, 472
Gaussian elimination, 68, 197, 302–306, 311,
Fiedler vector, 506
316, 318, 319, 321, 409, 410, 470
field of values, 23
block, 472
fill-factor, 350
frontal methods, 417
fill-in elements, 307
IKJ variant, 305
fill-path, 313
in IOM and DIOM, 170
fine-grain algorithms, 393
in Lanczos process, 198
finite difference scheme, 50
parallel, 499
for 1-D problems, 53
parallelism in, 78
for 2-D problems, 56
reordering in, 82
for the Laplacean, 52
in skyline format, 330
upwind schemes, 54
sparse, 76
finite element method, 47, 62
Gautschi, W., 195

INDEX
GCR, 204–206
Generalized Conjugate Residual, see GCR
geometric multiplicity, 16
George, A., 86, 97, 104, 313, 507
Gershgorin discs, 120
Gershgorin’s theorem, 119, 120
Gilbert, J. R., 332
Gilbert-Peierls algorithm, 332
global iteration, 337–339, 344
global reduction operations, 378
GMRES, 171–185, 206, 215–218
algorithm, 172
block algorithm, 222
breakdown, 178, 179
convergence, 215
flexible variant, 282, 287–290
Householder version, 172
lucky breakdown, 179
with polynomial preconditioning, 404
practical implementation, 174
relation with FOM, 185, 189
with restarting, 179
stagnation, 179
truncated, 180
via residual smoothing, 191
GMRES:complex version, 193
Godunov, S. K., 227
Golub, G. H., 45, 292, 295, 335, 367
Goovaerts, D., 486, 513
grade of a vector, 158
Gram-Schmidt algorithm, 11–12, 359
block, 219
cancellations in, 162
modified, 12
standard, 11
graph, 77
bipartite, 90, 352
coloring, 90, 493
diameter, 314
directed, 77
edges, 77
Laplacean of a, 506
partitioning, 469, 503
geometric, 504
graph theory techniques, 507
spectral techniques, 506
type, 471
separator, 85
undirected, 77
vertices, 77

539
graph separator, 85
Greenbaum, A., 187, 392
grid transfer, 430
Griewank, A., 367
Gropp, W. D., 376, 513
Grote, M., 367
group independent sets, 462
Gutknecht, M. H., 256
H
Hackbusch, W., 467, 513
Halmos, P. R., 17
Hankel matrix, 233
harmonic functions, 49
Harwell-Boeing collection, 98, 100
Hausdorff’s convex hull theorem, 24
Haws, J. C., 353
heap-sort, in ILUT, 326
heaps, 332
Hendrickson, B., 513
Hermitian inner product, 6
Hermitian matrices, 4, 24
Hermitian Positive Definite, 32
Hessenberg matrices, 5
Hesteness, M. R., 226
high frequency, 429
high frequency modes, 423
high modes, 429
Hindmarsh, A. C., 227
Hirsch, C., 74
Hockney, R. W., 74
Hölder norms, 8
Horn, R. A., 24
Householder algorithm, 12
Householder orthogonalization
in Arnoldi’s method, 163
Householder reflectors, 12
Householder, A. S., 155
HPD, see Hermitian Positive Definite
Huckle, T., 367
hypercube, 375
I
idempotent, 10, 34
if and only if, 3
iff, see if and only if
Ill’n, V. P., 367
ILQ
factorization, 360
preconditioning, 359

540

INDEX

induced preconditioners, 497
ILU, 301–332
inhomogeneous medium, 49
Crout variant, 332
injection, 438
distributed, 414
inner products, 5
factorization, 301
indefinite, 233
instability in, 328, 336
inner-products
general algorithm, 303
B-inner product, 34
IKJ version, 305
invariant subspace, 11, 141
ILUC, 332
inverse LU factors, 345, 346
ILUS, 330–332
IOM, 168
algorithm, 331
algorithm, 168
modified, 319–321
direct version, 168
preconditioner, 301
irreducibility, 90
for Schur complement, 499
irreducible, 28
reordering, 349
isometry, 8
static pattern, 306
iteration matrix, 112, 114
with threshold, see ILUT and ILUTP
iterations:Rirchadson, 116
with multi-elimination, see ILUM
zero pattern, 303
J
ILU(0), 297, 301, 307–309
j-diagonal, 382
algorithm, 307
Jacobi iteration, 105
distributed factorization, 416
for the normal equations, 263
for distributed sparse matrices, 414
JAD storage format, 382
for red-black ordering, 407
definition, 382
ILU(1), 311
in level scheduling, 390
ILUM, 411, 461
matvecs in, 383
ILUT, 321–327
jagged diagonal format, see JAD storage foralgorithm, 321
mat
analysis, 323
jagged diagonals, 382
implementation, 325
Jbilou, K., 227
with pivoting, see ILUTP
Jea, K. C., 206, 227
ILUTP, 327
Johnson, C., 74
for normal equations, 356
Johnson, C. R., 24
incomplete
Johnson, O. G., 401
orthogonalization
Jordan block, 17
algorithm, 168
Jordan box, 17
incomplete factorization, 297, 301
Jordan canonical form, 16
Gram-Schmidt, 360
Jordan submatrix, 17
ILQ, 359, 360
Jordan, H., 104
QR, 360
Joukowski mapping, 210
incomplete Gram-Schmidt, 361
Incomplete LQ, see ILQ
K
Incomplete LU, see ILU
Incomplete Orthogonalization Method, see IOMKaczmarz, S., 274
Kamath, C., 274
indefinite inner product, 233
Karp, R. M., 88
independent set orderings, 87, 461
Karush, T. I., 392, 422
independent sets, 87, 410
Karypis, G., 513
maximal, 88
kernel, 10
index of an eigenvalue, 17
Kershaw, D. S., 367
indirect addressing, 76
Keyes, D. E., 513
induced norm, 8

INDEX
Kolotolina, L. Y., 367
Koster, J., 367
Kranoselskii, M. A., 155
Kronsjö, L., 467
Krylov subspace, 158
dimension of a, 158
invariant, 159
methods, 157
Krylov subspace method
vs multigrid, 464
Krylov subspace methods, 229
Kumar, V., 392, 513
L
Lanczos algorithm
breakdown
serious, 232
look-ahead version, 232
Lanczos algorithm, 193, 194
algorithm, 194, 229
biorthogonalization, 229
breakdown, 231
incurable, 232
lucky, 232
for linear systems, 233
look-ahead version, 232
loss of orthogonality, 195
modified Gram-Schmidt version, 194
nonsymmetric, 229
and orthogonal polynomials, 195
partial reorthogonalization, 195
practical implementations, 232
selective reorthogonalization, 195
symmetric case, 193
Lanczos, C., 226, 234, 256, 422
Laplacean, see Laplacean operator
Laplacean operator, 49, 62
of a graph, 506
Le Tallec, P., 513
least-squares polynomials, 400
least-squares problem, 259
left eigenvector, 4
left versus right preconditioning, 286
Leisersen, C. E., 332
Leland, R., 513
Leuze, R., 422
level of fill-in, 311
level scheduling, 387–390
for 5-point matrices, 387
for general matrices, 388

541
level set orderings, 83, 507
Lewis, J. G., 392, 422
line relaxation, 109
linear mappings, 2
linear span, 10
linear system, 39, 105
existence of a solution, 40
right-hand side of a, 39
singular, 40
unknown of a, 39
linked lists, 96
Liou, K. P., 513
Liu, J. W-H., 97, 313, 507
Liu, Z. S., 233
local Schur complement, 480
Look-ahead Lanczos algorithm, 232
low frequency modes, 423
lower triangular matrices, 5
LQ factorization, 359
algorithm, 360
lucky breakdowns, 162
Lusk, E., 376
M
M-matrix, 27
Manteuffel, T., 207, 208, 227, 256, 367
Marı́n, J., 367
mask, 365
matching, 352
Mathew, T. P., 513
matrix, 1
addition, 2
adjoint of a, 7
banded, 5
bidiagonal, 5
canonical forms, 15
characteristic polynomial, 3
diagonal, 5
diagonal dominant, 119
diagonal form, 16
diagonalizable, 16
Hermitian, 4, 21, 24
Hessenberg, 5
irreducible, 90
Jordan canonical form, 16
M-, 27
multiplication, 2
nonnegative, 4, 27
nonsingular, 3
norm of a, 8

542
normal, 4, 21
orthogonal, 5
outer product, 5
positive definite, 32–34
powers of a, 19
reduction, 15
Schur form, 17
self-adjoint, 7, 493
singular, 3
skew-Hermitian, 4
skew-symmetric, 4
spectral radius, 4
spectrum, 3
square, 3
symmetric, 4
Symmetric Positive Definite, 32, 122
trace, 4
transpose, 2
transpose conjugate, 2
triangular, 5
tridiagonal, 5
unitary, 5
matrix norm, 9
matrix-by-vector product, 378
dense matrices, 378
for distributed matrices, 385
in DIA format, 380
in Ellpack format, 381
in triad form, 381
maximum transversal, 352
Mc Cormick, S. F., 467
Meijerink, J. A., 295, 367
mesh generation, 69
mesh refinement, 69
mesh size, 65
message passing, 374
Meurant, G. A., 367
Meyer, C. D., 45
Micchelli, C. A., 401
Miller, G. L., 505, 506
MILU, 319–321
Minimal Residual iteration, 145
algorithm, 145
convergence, 146
Minimal Residual Smoothing, 190–193
minimum degree ordering, 96, 350
min-max theorem, 25
mixed boundary conditions, 48, 49
M -matrix, 27, 302, 355
modified Gram-Schmidt, 162

INDEX
Modified ILU, see MILU
Modified Sparse Row storage, see MSR
molecule, 51
moment matrix, 233
in Lanczos procedure, 233
moment of intertia, 505
MR iteration, see Minimal Residual iteration
MRS, 190, 240
MSR storage format, 93
multi-elimination, 409, 410
multicolor orderings, 90
multicoloring, 406–409
for general sparse matrices, 408
multifrontal methods, 422
multigrid methods, 423–465
algebraic multigrid, 455
AMG, 455
FMG, 447
full multigrid, 447
Galerkin projection, 440
nested iteration, 441, 447
V-cyle, 444
W-cyle, 444
multinode expansion algorithm, 510
multiple eigenvalue, 15
multiple vector pipelines, 371
multiplicative projection process, 150
multiplicative Schwarz preconditioning, 489
multiprocessing, 371
Munksgaard, N., 367
N
Nachtigal, N. M., 184, 227, 256
natural ordering, 57
near singularity, 41
Nested dissection, 350
nested iteration, 441, 447
nested-dissection ordering, 96
Neumann boundary conditions, 48, 49
Neumann polynomials, 396
nonnegative matrix, 4, 27
nonsingular matrix, 3
norm
A-norm,energy norm, 34
energy norm, A-norm, 137
Euclidean, 7
Hölder, 8
induced, 8
of matrices, 8
p-norm, 8

INDEX
of vectors, 5
normal derivative, 63
normal equations, 259
normal matrix, 4, 21
Notay, Y., 295
null space, 10
of a projector, 34, 35
numerical radius, 24
O
O’Leary, D., 227
oblique projection methods, 229
oblique projector, 37
operator
elliptic, 47
Laplacean, 49
optimality of projection methods, 137
order relation for matrices, 27
Ortega, J., 295
Ortega, J. M., 104, 422
ORTHODIR, 204–206
orthogonal
complement, 11
matrix, 5
projector, 11, 37
vectors, 11
orthogonal bases, 11
orthogonality, 11
between vectors, 11
of a vector to a subspace, 11
ORTHOMIN, 204–206
orthonormal, 11
orthonormal bases, 11
oscillatory modes, 423
Osterby, O., 104, 367
outer product matrices, 5
overdetermined systems, 259
overlapping domains, 472
over-relaxation, 107
Overton, M. L., 295
P
p-norm, 8
packet switching, 374
Paige, C. C., 198, 227
parallel architectures, 371
parallel sparse techniques, 79
parallelism, 370
forms of, 370
Parlett, B. N., 163, 195, 232, 233

543
partial differential equations, 47
partial Schur decomposition, 19
partition, 111
partition vector, 507
partitioning, 471
Pasciak, J. E., 513
Paul, G., 401
PDE, see partial differential equations
PE, see Processing Element
Peaceman, D., 129, 132
Peaceman-Rachford algorithm, 128
Peacman, D., 127
Peierls, T., 332
peripheral node, 507
permutation matrices, 5, 80
permutations, 79
Perron-Frobenius theorem, 28
perturbation analysis, 40
Petrov-Galerkin conditions, 133–135
Peyton, B. W., 422
physical mesh versus graph, 79
pipelining, 370
polynomial approximation, 158
polynomial preconditioning, 393, 395–406
Poole, E. L., 104, 422
positive definite matrix, 6, 26, 32–34
positive matrix, 27
positive real matrix, see positive definite matrix
positive semidefinite, 26
Pothen, A., 422, 513
preconditioned
CG, 276
efficient implementations, 279
left, 277
for the normal equations, 290
parallel implementation, 376
split, 278
symmetry in, 276
fixed-point iteration, 113
GMRES, 281
comparison, 285
flexible variant, 286, 287
left preconditioning, 282
right preconditioning, 283
split preconditioning, 284
preconditioner, 113
preconditioning, 112, 180, 275
approximate inverse, 336
block, 354

544

INDEX

by ILQ, 359
Q
EBE, 417
QMR, 234–239
incomplete LU, 301
algorithm, 237
induced, 497
approximation, 237
Jacobi, 298
QMR:from residual smoothing, 240
left, 275
QMR:peaks and plateaus of residuals, 240
normalequationsfor normal equations, 356 QMRS, 192
polynomial, 395–406
QR decomposition, 12
with Chebyshev polynomials, 396
quasi minimal residual smoothing, 240
with least-squares polynomials, 400
Quasi-GMRES, 180
with Neumann polynomials, 396
algorithm, 180
and relaxation scheme, 113
direct version, 180
right, 275
DQGMRES, 180
SOR, 298
Quasi-Minimal Residual, see QMR
split, 275
quasi-minimal residual smoothing, 192
SSOR, 298
quasi-residual norm, 182
probing, 499
quasi-residual smoothing, 240
Processing Element (PE), 371
quasi-Schur form, 19
profile, 86
quick-split, in ILUT, 326
projection
quotient graph, 79
operator, see projector
R
orthogonal to, 35
Rachford, H., 127, 129, 132
parallel to, 35
range, 2, 10
projection methods, 133
of a projector, 34, 35
additive, 148
rank, 10
approximate problem, 134
full, 10
definitions, 133
Rapid elliptic solvers, see Fast Poisson Solvers
error bounds, 139
Rayleigh quotient, 23, 25
general, 133
RCM, 350
matrix representation, 135
real Schur form, 19
multiplicative, 150
recursive graph bisection, 509
oblique, 133, 229
red-black ordering, 406
one-dimensional, 142
Redivo Zaglia, M., 256
optimality, 137
reduced system, 363, 474
orthogonal, 133, 135
reducible, 28
prototype, 135
reduction of matrices, 15
residual, 138
reduction operations, 377
theory, 136
refinement, 69
projector, 10, 34–39, 111
reflectors, 12
existence, 36
regular splitting, 118
matrix representation, 36
regularization, 271
oblique, 37
Reid, J. K., 104, 227
orthogonal, 37
relaxation methods
eigenvalues, 39
block, 108
properties, 38
convergence, 114
prolongation operator, 111, 487
reordering, 80, 349
property A, 122, 123
for ILU, 349
Propkopov, G. P., 227
reordering
rows, columns, 79
Przemieniecki, J. S., 513
reorthogonalization,
11
pseudo-peripheral node, 507

INDEX
residual norm steepest descent, 147
residual projection methods, 138
residual smoothing, 190
restarted FOM, 167
restriction, 438
restriction operator, 111, 487
reverse Cuthill McKee ordering, 350
Richardson’s iteration, 116, 264
Richardsons iteration, 428
right versus left preconditioning, 286
right-hand side, 39, 105
multiple, 222
Rivest, R. L., 332
Rivlin, T. J., 211
Rose-Tarjan theorem, 313
Roux, J. X., 513
row projection methods, 261, 419
parallel, 419
row reordering, 80
row sum, 320
Ruge, A., 468
Ruhe, A., 219
Rutishauser, H., 422
S
saddle-point problems, 268
Sadok, H., 227, 256
Saltz, J., 392
Sameh, A., 274
Saunders, M. A., 198
SAXPY, 142, 340, 377
parallel, 377
sparse, 340
scatter and gather operations, 379–380
Schönauer, W., 227, 256
Schultz, M. H., 334
Schur complement, 474
approaches, 497
and direct solution, 474
for finite-element partitionings, 479
local, 478
methods, 497
for model problems, 481
properties, 475
for vertex partitionings, 476
Schur form, 17
example, 19
nonuniqueness, 19
partial, 19
quasi, 19

545
real, 19
Schwarz alternating procedure, 472, 484
additive, 491
algorithm, 485
multiplicative, 484
Schwarz, H. A., 513
search subspace, 133
section of an operator, 159
self preconditioning, 340
convergence behavior, 342
self-adjoint, 7, 493
semisimple, 16
separators, 505
set decomposition, 111
shared memory computers, 372
Sherman, A. H., 334
Sidi, A., 257
similarity transformation, 15
Simon, H. D., 367, 392, 513
Simoncini, V., 227, 256
simple eigenvalue, 15
singular matrix, 3
singular values, 9
sites (in graph partitioning), 510
skew-Hermitian
matrices, 4, 21, 208
part, 33
skew-symmetric matrices, 4
Skjellum, A., 376
skyline solvers, 87
Smith, B., 513
smooth modes, 423
smoother, 440
smoothing operator, 440
smoothing property, 453
Sonneveld, P., 241, 256
SOR, 108
convergence, 122
iteration, 105
multicolor sweep, 409
for SPD matrices, 122
span of q vectors, 10
sparse, 66
sparse Gaussian elimination, 76, 96
sparse matrices
adjacency graph, 76, 77
basic operations, 95
direct methods, 96
graph representation, 76
matrix-by-vector operation, 95

INDEX

546
permutation and reordering, 79
storage, 92–95
sparse matrix-by-vector product, 95
sparse skyline storage format, see SSK
sparse triangular system solution, 96
sparse-sparse mode computations, 339
sparse-sparse mode computations, 339
sparsity, 75
SPARSKIT, 98–100
SPD, see Symmetric Positive Definite
spectral bisection, 506
spectral radius, 4
spectrum of a matrix, 3
split preconditioning, 276
splitting, 107
square matrices, 3
SSK storage format, 330
SSOR, 108
Stüben, K., 468
steepest descent, 142
stencil, 51
stereographic projection, 505
Stewart, G. W., 45
Stewart, W. J., 468
Stiefel, E. L., 226, 396, 422
Stieljes algorithm, 195
stiffness matrix, 66, 68
Stokes problem, 270
storage format
COO, 92
CSC, 93
CSR, 93, 305
ELL, 94
MSR, 93
SSK, 330
storage of sparse matrices, 92–95
Strang, G., 74
structural nonsingularity, 352
structured sparse matrix, 75
subdomain, 414
subspace, 10
direct sum, 10
of approximants, 133
of constraints, 133
orthogonal, 11
sum, 10
Successive Over-Relaxation, see SOR
Swartzrauber, P. N., 62
Sweet, R., 74
symbolic factorization, 96

symmetric Gauss Seidel, 107
symmetric matrices, 4
Symmetric Positive Definite, 32, 122
Symmetric SOR, see SSOR
symmetric squaring, 360
symmetry in preconditioned CG, 276
Szyld, D. B., 295, 367
T
Tang, W. P., 367
Taylor, D. R., 232, 233
Teng, S. H., 505, 506
tensor product, 427
tensor sum, 427
test problems, 98
TFQMR, 247
algorithm, 252
topological sorting, 388
trace, 4
Transpose-Free QMR, see TFQMR
transversal, 352
triad operation, 381
triangular systems, 386
distributed, 416
level scheduling, 388
sparse, 386
tridiagonal matrices, 5
Trottenberg, U., 467
Tůma, M., 367
Tůma, M. T., 348, 353
U
unassembled matrix, 68
under-determined, 259
undirected graph, 78
unitary matrices, 5
unstructured sparse matrix, 75
upper triangular matrices, 5
upwind schemes, 54
Uzawa’s method, 268, 269
V
van der Vorst, H. A., 246, 256, 295, 367, 392
Varga, R. S., 45, 124, 129, 131, 367, 422
variable preconditioner, 287
Vassilevski, P., 295
Vavasis, S. A., 505, 506
vector
computers, 371
operations, 377

INDEX
orthogonality, 11
processors, 371
of unknowns, 105
updates, 142, 377
parallel, 377
vertex (in a graph), 77
Vinsome, P. K. W., 227
Voevodin, V. V., 227
W
Wachspress, E. L., 132
Wagner, C., 467, 468
Walker, H. F., 163, 191, 227, 240, 256
Walter, A., 257
Wang, X., 362, 368
Wathens, A. J., 367
Watts, J. W., 367
wavefronts, 388
weak formulation, 63
weakly diagonally dominant matrix, 119
Weiss, R, 190
Weiss, R., 227, 256
Wesseling, P., 256, 467
Widlund, O. B., 292, 497
Wigton, L. B., 367
Wilders, P., 513
Wilkinson, B., 392
Wilkinson, J. H., 227, 232
Winget regularization, 418
Wu, C. H., 104
X
Xu, J., 497, 513
Y
Ye, Q., 295
Yeremin, A. Y., 367
Young, D. M., 124, 126, 129, 131, 206, 422
Young, D. P., 367
Z
Zarantonello’s lemma, 211
Zhou, L., 191, 227, 240, 256
Zlatev, Z., 104, 367

547

